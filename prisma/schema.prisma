// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// CRITICAL: This schema is designed for SQLite-to-PostgreSQL migration compatibility
// - ALL IDs use CUID (String @id @default(cuid())) - NEVER use auto-incrementing integers
// - Avoid SQLite-specific features to maintain PostgreSQL compatibility
// - This ensures zero ID collisions when merging local databases to Supabase

generator client {
  provider   = "prisma-client-js"
  engineType = "binary"
}

datasource db {
  provider = "sqlite"
}

// ============================================================================
// AUTHENTICATION (Local)
// ============================================================================

model User {
  id        String   @id @default(cuid())
  username  String   @unique
  password  String   // Hashed password (never store plaintext)
  createdAt DateTime @default(now()) @map("created_at")

  @@map("users")
}

// ============================================================================
// STATIC DATA (Catalog)
// ============================================================================

model Element {
  id          String   @id @default(cuid())
  uniqueName  String   @map("unique_name")          // Element category/name (e.g., "Bucket", "Lid")
  label       String   @default("") @map("label")   // Optional unique label for element identification
  color       String                                 // Primary color (e.g., "Red")
  color2      String?  @map("color_2")               // Optional second color for dual-color elements
  isDualColor Boolean  @default(false) @map("is_dual_color") // When true, production quantity is halved
  material    String
  weightGrams Decimal  @default(0) @map("weight_grams") // Used to calculate total weight in pick lists
  imageUrl    String?  @map("image_url")
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  productElements       ProductElement[]
  inventory             Inventory[]
  inventoryTransactions InventoryTransaction[]
  materialRequirements  MaterialRequirement[]

  @@map("elements")
}

model Product {
  id                String   @id @default(cuid())
  serialNumber      String   @unique @map("serial_number")
  category          String
  label             String   @default("")                    // User-defined text label displayed on product card
  unitsPerAssembly  Int      @default(1) @map("units_per_assembly") // How many finished units per assembly batch
  unitsPerBox       Int      @default(1) @map("units_per_box")      // How many finished units per shippable box
  imageUrl          String?  @map("image_url")
  createdAt         DateTime @default(now()) @map("created_at")

  // Relations
  productElements     ProductElement[]
  productStock        ProductStock?
  orderItems          OrderItem[]
  manufacturingOrders ManufacturingOrder[]

  @@map("products")
}

model ProductElement {
  id             String   @id @default(cuid())
  productId      String   @map("product_id")
  elementId      String   @map("element_id")
  quantityNeeded Int      @default(1) @map("quantity_needed") // Quantity per ONE finished product unit
  createdAt      DateTime @default(now()) @map("created_at")

  // Relations
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  element Element @relation(fields: [elementId], references: [id], onDelete: Restrict)

  @@unique([productId, elementId])
  @@map("product_elements")
}

// ============================================================================
// DYNAMIC DATA (Inventory & Orders)
// ============================================================================

model Inventory {
  id          String   @id @default(cuid())
  elementId   String   @unique @map("element_id") // One inventory record per element
  totalAmount Int      @default(0) @map("total_amount")
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at")

  // Relations
  element Element @relation(fields: [elementId], references: [id])

  @@map("inventory")
}

model ProductStock {
  id               String   @id @default(cuid())
  productId        String   @unique @map("product_id")
  stockBoxedAmount Int      @default(0) @map("stock_boxed_amount")
  updatedAt        DateTime @default(now()) @updatedAt @map("updated_at")

  // Relations
  product Product @relation(fields: [productId], references: [id])

  @@map("product_stock")
}

model InventoryTransaction {
  id           String   @id @default(cuid())
  elementId    String?  @map("element_id")
  changeAmount Int      @map("change_amount")
  reason       String
  createdAt    DateTime @default(now()) @map("created_at")

  // Relations
  element Element? @relation(fields: [elementId], references: [id])

  @@map("inventory_transactions")
}

model Order {
  id          String    @id @default(cuid())
  // Sequential order number managed by application layer (max+1 on create)
  // For PostgreSQL migration, switch to: @default(dbgenerated("nextval('orders_order_number_seq')"))
  orderNumber Int       @unique @map("order_number")
  clientName  String    @map("client_name")
  createdAt   DateTime  @default(now()) @map("created_at")
  shippedAt   DateTime? @map("shipped_at")               // Set when status â†’ shipped
  status      String    @default("pending") // Zod: 'pending' | 'in_production' | 'shipped'
  notes       String?

  // Relations
  orderItems          OrderItem[]
  manufacturingOrders ManufacturingOrder[]

  @@map("orders")
}

model OrderItem {
  id              String   @id @default(cuid())
  orderId         String   @map("order_id")
  productId       String   @map("product_id")
  boxesNeeded     Int      @map("boxes_needed")
  boxesAssembled  Int      @default(0) @map("boxes_assembled") // Boxes assembled so far
  createdAt       DateTime @default(now()) @map("created_at")

  // Relations
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])

  @@map("order_items")
}

// ============================================================================
// MANUFACTURING LAYER (MRP - Material Requirements Planning)
// ============================================================================

model ManufacturingOrder {
  id             String   @id @default(cuid())
  orderId        String   @map("order_id")
  productId      String   @map("product_id")
  quantityToMake Int      @map("quantity_to_make") // Total finished units to produce
  status         String   @default("planned") // Zod: 'planned' | 'in_progress' | 'completed' | 'cancelled'
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  // Relations
  order        Order                 @relation(fields: [orderId], references: [id])
  product      Product               @relation(fields: [productId], references: [id])
  requirements MaterialRequirement[]

  @@map("manufacturing_orders")
}

model MaterialRequirement {
  id                   String   @id @default(cuid())
  manufacturingOrderId String   @map("manufacturing_order_id")
  elementId            String   @map("element_id")
  quantityNeeded       Int      @map("quantity_needed")       // Total count for this element
  quantityProduced     Int      @default(0) @map("quantity_produced") // Track production progress
  totalWeightGrams     Decimal  @map("total_weight_grams")    // Calculated: quantityNeeded * Element.weightGrams
  createdAt            DateTime @default(now()) @map("created_at")

  // Relations
  manufacturingOrder ManufacturingOrder @relation(fields: [manufacturingOrderId], references: [id], onDelete: Cascade)
  element            Element            @relation(fields: [elementId], references: [id])

  @@unique([manufacturingOrderId, elementId])
  @@map("material_requirements")
}
