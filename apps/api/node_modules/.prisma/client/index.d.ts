
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RawMaterial
 * 
 */
export type RawMaterial = $Result.DefaultSelection<Prisma.$RawMaterialPayload>
/**
 * Model RawMaterialTransaction
 * 
 */
export type RawMaterialTransaction = $Result.DefaultSelection<Prisma.$RawMaterialTransactionPayload>
/**
 * Model Element
 * 
 */
export type Element = $Result.DefaultSelection<Prisma.$ElementPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductElement
 * 
 */
export type ProductElement = $Result.DefaultSelection<Prisma.$ProductElementPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model ProductStock
 * 
 */
export type ProductStock = $Result.DefaultSelection<Prisma.$ProductStockPayload>
/**
 * Model InventoryTransaction
 * 
 */
export type InventoryTransaction = $Result.DefaultSelection<Prisma.$InventoryTransactionPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model InventoryAllocation
 * 
 */
export type InventoryAllocation = $Result.DefaultSelection<Prisma.$InventoryAllocationPayload>
/**
 * Model ManufacturingOrder
 * 
 */
export type ManufacturingOrder = $Result.DefaultSelection<Prisma.$ManufacturingOrderPayload>
/**
 * Model MaterialRequirement
 * 
 */
export type MaterialRequirement = $Result.DefaultSelection<Prisma.$MaterialRequirementPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rawMaterial`: Exposes CRUD operations for the **RawMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RawMaterials
    * const rawMaterials = await prisma.rawMaterial.findMany()
    * ```
    */
  get rawMaterial(): Prisma.RawMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rawMaterialTransaction`: Exposes CRUD operations for the **RawMaterialTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RawMaterialTransactions
    * const rawMaterialTransactions = await prisma.rawMaterialTransaction.findMany()
    * ```
    */
  get rawMaterialTransaction(): Prisma.RawMaterialTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.element`: Exposes CRUD operations for the **Element** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Elements
    * const elements = await prisma.element.findMany()
    * ```
    */
  get element(): Prisma.ElementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productElement`: Exposes CRUD operations for the **ProductElement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductElements
    * const productElements = await prisma.productElement.findMany()
    * ```
    */
  get productElement(): Prisma.ProductElementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productStock`: Exposes CRUD operations for the **ProductStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductStocks
    * const productStocks = await prisma.productStock.findMany()
    * ```
    */
  get productStock(): Prisma.ProductStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryTransaction`: Exposes CRUD operations for the **InventoryTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryTransactions
    * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
    * ```
    */
  get inventoryTransaction(): Prisma.InventoryTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryAllocation`: Exposes CRUD operations for the **InventoryAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryAllocations
    * const inventoryAllocations = await prisma.inventoryAllocation.findMany()
    * ```
    */
  get inventoryAllocation(): Prisma.InventoryAllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manufacturingOrder`: Exposes CRUD operations for the **ManufacturingOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManufacturingOrders
    * const manufacturingOrders = await prisma.manufacturingOrder.findMany()
    * ```
    */
  get manufacturingOrder(): Prisma.ManufacturingOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materialRequirement`: Exposes CRUD operations for the **MaterialRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialRequirements
    * const materialRequirements = await prisma.materialRequirement.findMany()
    * ```
    */
  get materialRequirement(): Prisma.MaterialRequirementDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RawMaterial: 'RawMaterial',
    RawMaterialTransaction: 'RawMaterialTransaction',
    Element: 'Element',
    Product: 'Product',
    ProductElement: 'ProductElement',
    Inventory: 'Inventory',
    ProductStock: 'ProductStock',
    InventoryTransaction: 'InventoryTransaction',
    Order: 'Order',
    OrderItem: 'OrderItem',
    InventoryAllocation: 'InventoryAllocation',
    ManufacturingOrder: 'ManufacturingOrder',
    MaterialRequirement: 'MaterialRequirement'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "rawMaterial" | "rawMaterialTransaction" | "element" | "product" | "productElement" | "inventory" | "productStock" | "inventoryTransaction" | "order" | "orderItem" | "inventoryAllocation" | "manufacturingOrder" | "materialRequirement"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RawMaterial: {
        payload: Prisma.$RawMaterialPayload<ExtArgs>
        fields: Prisma.RawMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RawMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RawMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload>
          }
          findFirst: {
            args: Prisma.RawMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RawMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload>
          }
          findMany: {
            args: Prisma.RawMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload>[]
          }
          create: {
            args: Prisma.RawMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload>
          }
          createMany: {
            args: Prisma.RawMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RawMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload>[]
          }
          delete: {
            args: Prisma.RawMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload>
          }
          update: {
            args: Prisma.RawMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload>
          }
          deleteMany: {
            args: Prisma.RawMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RawMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RawMaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload>[]
          }
          upsert: {
            args: Prisma.RawMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialPayload>
          }
          aggregate: {
            args: Prisma.RawMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRawMaterial>
          }
          groupBy: {
            args: Prisma.RawMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<RawMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.RawMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<RawMaterialCountAggregateOutputType> | number
          }
        }
      }
      RawMaterialTransaction: {
        payload: Prisma.$RawMaterialTransactionPayload<ExtArgs>
        fields: Prisma.RawMaterialTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RawMaterialTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RawMaterialTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload>
          }
          findFirst: {
            args: Prisma.RawMaterialTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RawMaterialTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload>
          }
          findMany: {
            args: Prisma.RawMaterialTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload>[]
          }
          create: {
            args: Prisma.RawMaterialTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload>
          }
          createMany: {
            args: Prisma.RawMaterialTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RawMaterialTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload>[]
          }
          delete: {
            args: Prisma.RawMaterialTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload>
          }
          update: {
            args: Prisma.RawMaterialTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload>
          }
          deleteMany: {
            args: Prisma.RawMaterialTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RawMaterialTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RawMaterialTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload>[]
          }
          upsert: {
            args: Prisma.RawMaterialTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialTransactionPayload>
          }
          aggregate: {
            args: Prisma.RawMaterialTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRawMaterialTransaction>
          }
          groupBy: {
            args: Prisma.RawMaterialTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RawMaterialTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RawMaterialTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<RawMaterialTransactionCountAggregateOutputType> | number
          }
        }
      }
      Element: {
        payload: Prisma.$ElementPayload<ExtArgs>
        fields: Prisma.ElementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload>
          }
          findFirst: {
            args: Prisma.ElementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload>
          }
          findMany: {
            args: Prisma.ElementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload>[]
          }
          create: {
            args: Prisma.ElementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload>
          }
          createMany: {
            args: Prisma.ElementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload>[]
          }
          delete: {
            args: Prisma.ElementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload>
          }
          update: {
            args: Prisma.ElementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload>
          }
          deleteMany: {
            args: Prisma.ElementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload>[]
          }
          upsert: {
            args: Prisma.ElementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementPayload>
          }
          aggregate: {
            args: Prisma.ElementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElement>
          }
          groupBy: {
            args: Prisma.ElementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElementCountArgs<ExtArgs>
            result: $Utils.Optional<ElementCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductElement: {
        payload: Prisma.$ProductElementPayload<ExtArgs>
        fields: Prisma.ProductElementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductElementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductElementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload>
          }
          findFirst: {
            args: Prisma.ProductElementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductElementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload>
          }
          findMany: {
            args: Prisma.ProductElementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload>[]
          }
          create: {
            args: Prisma.ProductElementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload>
          }
          createMany: {
            args: Prisma.ProductElementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductElementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload>[]
          }
          delete: {
            args: Prisma.ProductElementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload>
          }
          update: {
            args: Prisma.ProductElementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload>
          }
          deleteMany: {
            args: Prisma.ProductElementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductElementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductElementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload>[]
          }
          upsert: {
            args: Prisma.ProductElementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductElementPayload>
          }
          aggregate: {
            args: Prisma.ProductElementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductElement>
          }
          groupBy: {
            args: Prisma.ProductElementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductElementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductElementCountArgs<ExtArgs>
            result: $Utils.Optional<ProductElementCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      ProductStock: {
        payload: Prisma.$ProductStockPayload<ExtArgs>
        fields: Prisma.ProductStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          findFirst: {
            args: Prisma.ProductStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          findMany: {
            args: Prisma.ProductStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>[]
          }
          create: {
            args: Prisma.ProductStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          createMany: {
            args: Prisma.ProductStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductStockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>[]
          }
          delete: {
            args: Prisma.ProductStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          update: {
            args: Prisma.ProductStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          deleteMany: {
            args: Prisma.ProductStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductStockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>[]
          }
          upsert: {
            args: Prisma.ProductStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          aggregate: {
            args: Prisma.ProductStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductStock>
          }
          groupBy: {
            args: Prisma.ProductStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductStockCountArgs<ExtArgs>
            result: $Utils.Optional<ProductStockCountAggregateOutputType> | number
          }
        }
      }
      InventoryTransaction: {
        payload: Prisma.$InventoryTransactionPayload<ExtArgs>
        fields: Prisma.InventoryTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findFirst: {
            args: Prisma.InventoryTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findMany: {
            args: Prisma.InventoryTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          create: {
            args: Prisma.InventoryTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          createMany: {
            args: Prisma.InventoryTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          delete: {
            args: Prisma.InventoryTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          update: {
            args: Prisma.InventoryTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          deleteMany: {
            args: Prisma.InventoryTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          upsert: {
            args: Prisma.InventoryTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          aggregate: {
            args: Prisma.InventoryTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryTransaction>
          }
          groupBy: {
            args: Prisma.InventoryTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryAllocation: {
        payload: Prisma.$InventoryAllocationPayload<ExtArgs>
        fields: Prisma.InventoryAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload>
          }
          findFirst: {
            args: Prisma.InventoryAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload>
          }
          findMany: {
            args: Prisma.InventoryAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload>[]
          }
          create: {
            args: Prisma.InventoryAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload>
          }
          createMany: {
            args: Prisma.InventoryAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload>[]
          }
          delete: {
            args: Prisma.InventoryAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload>
          }
          update: {
            args: Prisma.InventoryAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload>
          }
          deleteMany: {
            args: Prisma.InventoryAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryAllocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload>[]
          }
          upsert: {
            args: Prisma.InventoryAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAllocationPayload>
          }
          aggregate: {
            args: Prisma.InventoryAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryAllocation>
          }
          groupBy: {
            args: Prisma.InventoryAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryAllocationCountAggregateOutputType> | number
          }
        }
      }
      ManufacturingOrder: {
        payload: Prisma.$ManufacturingOrderPayload<ExtArgs>
        fields: Prisma.ManufacturingOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManufacturingOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManufacturingOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload>
          }
          findFirst: {
            args: Prisma.ManufacturingOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManufacturingOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload>
          }
          findMany: {
            args: Prisma.ManufacturingOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload>[]
          }
          create: {
            args: Prisma.ManufacturingOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload>
          }
          createMany: {
            args: Prisma.ManufacturingOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManufacturingOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload>[]
          }
          delete: {
            args: Prisma.ManufacturingOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload>
          }
          update: {
            args: Prisma.ManufacturingOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload>
          }
          deleteMany: {
            args: Prisma.ManufacturingOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManufacturingOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManufacturingOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload>[]
          }
          upsert: {
            args: Prisma.ManufacturingOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManufacturingOrderPayload>
          }
          aggregate: {
            args: Prisma.ManufacturingOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManufacturingOrder>
          }
          groupBy: {
            args: Prisma.ManufacturingOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManufacturingOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManufacturingOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ManufacturingOrderCountAggregateOutputType> | number
          }
        }
      }
      MaterialRequirement: {
        payload: Prisma.$MaterialRequirementPayload<ExtArgs>
        fields: Prisma.MaterialRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload>
          }
          findFirst: {
            args: Prisma.MaterialRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload>
          }
          findMany: {
            args: Prisma.MaterialRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload>[]
          }
          create: {
            args: Prisma.MaterialRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload>
          }
          createMany: {
            args: Prisma.MaterialRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialRequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload>[]
          }
          delete: {
            args: Prisma.MaterialRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload>
          }
          update: {
            args: Prisma.MaterialRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload>
          }
          deleteMany: {
            args: Prisma.MaterialRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialRequirementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload>[]
          }
          upsert: {
            args: Prisma.MaterialRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequirementPayload>
          }
          aggregate: {
            args: Prisma.MaterialRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialRequirement>
          }
          groupBy: {
            args: Prisma.MaterialRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialRequirementCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    rawMaterial?: RawMaterialOmit
    rawMaterialTransaction?: RawMaterialTransactionOmit
    element?: ElementOmit
    product?: ProductOmit
    productElement?: ProductElementOmit
    inventory?: InventoryOmit
    productStock?: ProductStockOmit
    inventoryTransaction?: InventoryTransactionOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    inventoryAllocation?: InventoryAllocationOmit
    manufacturingOrder?: ManufacturingOrderOmit
    materialRequirement?: MaterialRequirementOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RawMaterialCountOutputType
   */

  export type RawMaterialCountOutputType = {
    elements: number
    packagingForProducts: number
    transactions: number
  }

  export type RawMaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elements?: boolean | RawMaterialCountOutputTypeCountElementsArgs
    packagingForProducts?: boolean | RawMaterialCountOutputTypeCountPackagingForProductsArgs
    transactions?: boolean | RawMaterialCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * RawMaterialCountOutputType without action
   */
  export type RawMaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialCountOutputType
     */
    select?: RawMaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RawMaterialCountOutputType without action
   */
  export type RawMaterialCountOutputTypeCountElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElementWhereInput
  }

  /**
   * RawMaterialCountOutputType without action
   */
  export type RawMaterialCountOutputTypeCountPackagingForProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * RawMaterialCountOutputType without action
   */
  export type RawMaterialCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawMaterialTransactionWhereInput
  }


  /**
   * Count Type ElementCountOutputType
   */

  export type ElementCountOutputType = {
    productElements: number
    inventory: number
    inventoryTransactions: number
    materialRequirements: number
    inventoryAllocations: number
  }

  export type ElementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productElements?: boolean | ElementCountOutputTypeCountProductElementsArgs
    inventory?: boolean | ElementCountOutputTypeCountInventoryArgs
    inventoryTransactions?: boolean | ElementCountOutputTypeCountInventoryTransactionsArgs
    materialRequirements?: boolean | ElementCountOutputTypeCountMaterialRequirementsArgs
    inventoryAllocations?: boolean | ElementCountOutputTypeCountInventoryAllocationsArgs
  }

  // Custom InputTypes
  /**
   * ElementCountOutputType without action
   */
  export type ElementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementCountOutputType
     */
    select?: ElementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ElementCountOutputType without action
   */
  export type ElementCountOutputTypeCountProductElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductElementWhereInput
  }

  /**
   * ElementCountOutputType without action
   */
  export type ElementCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * ElementCountOutputType without action
   */
  export type ElementCountOutputTypeCountInventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * ElementCountOutputType without action
   */
  export type ElementCountOutputTypeCountMaterialRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequirementWhereInput
  }

  /**
   * ElementCountOutputType without action
   */
  export type ElementCountOutputTypeCountInventoryAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAllocationWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    productElements: number
    orderItems: number
    manufacturingOrders: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productElements?: boolean | ProductCountOutputTypeCountProductElementsArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    manufacturingOrders?: boolean | ProductCountOutputTypeCountManufacturingOrdersArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductElementWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountManufacturingOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManufacturingOrderWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    orderItems: number
    manufacturingOrders: number
    inventoryAllocations: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs
    manufacturingOrders?: boolean | OrderCountOutputTypeCountManufacturingOrdersArgs
    inventoryAllocations?: boolean | OrderCountOutputTypeCountInventoryAllocationsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountManufacturingOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManufacturingOrderWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountInventoryAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAllocationWhereInput
  }


  /**
   * Count Type ManufacturingOrderCountOutputType
   */

  export type ManufacturingOrderCountOutputType = {
    requirements: number
  }

  export type ManufacturingOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirements?: boolean | ManufacturingOrderCountOutputTypeCountRequirementsArgs
  }

  // Custom InputTypes
  /**
   * ManufacturingOrderCountOutputType without action
   */
  export type ManufacturingOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrderCountOutputType
     */
    select?: ManufacturingOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ManufacturingOrderCountOutputType without action
   */
  export type ManufacturingOrderCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequirementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    password: string
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "createdAt", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model RawMaterial
   */

  export type AggregateRawMaterial = {
    _count: RawMaterialCountAggregateOutputType | null
    _avg: RawMaterialAvgAggregateOutputType | null
    _sum: RawMaterialSumAggregateOutputType | null
    _min: RawMaterialMinAggregateOutputType | null
    _max: RawMaterialMaxAggregateOutputType | null
  }

  export type RawMaterialAvgAggregateOutputType = {
    stockQty: number | null
  }

  export type RawMaterialSumAggregateOutputType = {
    stockQty: number | null
  }

  export type RawMaterialMinAggregateOutputType = {
    id: string | null
    name: string | null
    unit: string | null
    stockQty: number | null
    createdAt: Date | null
  }

  export type RawMaterialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    unit: string | null
    stockQty: number | null
    createdAt: Date | null
  }

  export type RawMaterialCountAggregateOutputType = {
    id: number
    name: number
    unit: number
    stockQty: number
    createdAt: number
    _all: number
  }


  export type RawMaterialAvgAggregateInputType = {
    stockQty?: true
  }

  export type RawMaterialSumAggregateInputType = {
    stockQty?: true
  }

  export type RawMaterialMinAggregateInputType = {
    id?: true
    name?: true
    unit?: true
    stockQty?: true
    createdAt?: true
  }

  export type RawMaterialMaxAggregateInputType = {
    id?: true
    name?: true
    unit?: true
    stockQty?: true
    createdAt?: true
  }

  export type RawMaterialCountAggregateInputType = {
    id?: true
    name?: true
    unit?: true
    stockQty?: true
    createdAt?: true
    _all?: true
  }

  export type RawMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawMaterial to aggregate.
     */
    where?: RawMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterials to fetch.
     */
    orderBy?: RawMaterialOrderByWithRelationInput | RawMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RawMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RawMaterials
    **/
    _count?: true | RawMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RawMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RawMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RawMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RawMaterialMaxAggregateInputType
  }

  export type GetRawMaterialAggregateType<T extends RawMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateRawMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRawMaterial[P]>
      : GetScalarType<T[P], AggregateRawMaterial[P]>
  }




  export type RawMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawMaterialWhereInput
    orderBy?: RawMaterialOrderByWithAggregationInput | RawMaterialOrderByWithAggregationInput[]
    by: RawMaterialScalarFieldEnum[] | RawMaterialScalarFieldEnum
    having?: RawMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RawMaterialCountAggregateInputType | true
    _avg?: RawMaterialAvgAggregateInputType
    _sum?: RawMaterialSumAggregateInputType
    _min?: RawMaterialMinAggregateInputType
    _max?: RawMaterialMaxAggregateInputType
  }

  export type RawMaterialGroupByOutputType = {
    id: string
    name: string
    unit: string
    stockQty: number
    createdAt: Date
    _count: RawMaterialCountAggregateOutputType | null
    _avg: RawMaterialAvgAggregateOutputType | null
    _sum: RawMaterialSumAggregateOutputType | null
    _min: RawMaterialMinAggregateOutputType | null
    _max: RawMaterialMaxAggregateOutputType | null
  }

  type GetRawMaterialGroupByPayload<T extends RawMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RawMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RawMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RawMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], RawMaterialGroupByOutputType[P]>
        }
      >
    >


  export type RawMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    unit?: boolean
    stockQty?: boolean
    createdAt?: boolean
    elements?: boolean | RawMaterial$elementsArgs<ExtArgs>
    packagingForProducts?: boolean | RawMaterial$packagingForProductsArgs<ExtArgs>
    transactions?: boolean | RawMaterial$transactionsArgs<ExtArgs>
    _count?: boolean | RawMaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawMaterial"]>

  export type RawMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    unit?: boolean
    stockQty?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rawMaterial"]>

  export type RawMaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    unit?: boolean
    stockQty?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rawMaterial"]>

  export type RawMaterialSelectScalar = {
    id?: boolean
    name?: boolean
    unit?: boolean
    stockQty?: boolean
    createdAt?: boolean
  }

  export type RawMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "unit" | "stockQty" | "createdAt", ExtArgs["result"]["rawMaterial"]>
  export type RawMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elements?: boolean | RawMaterial$elementsArgs<ExtArgs>
    packagingForProducts?: boolean | RawMaterial$packagingForProductsArgs<ExtArgs>
    transactions?: boolean | RawMaterial$transactionsArgs<ExtArgs>
    _count?: boolean | RawMaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RawMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RawMaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RawMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RawMaterial"
    objects: {
      elements: Prisma.$ElementPayload<ExtArgs>[]
      packagingForProducts: Prisma.$ProductPayload<ExtArgs>[]
      transactions: Prisma.$RawMaterialTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      unit: string
      stockQty: number
      createdAt: Date
    }, ExtArgs["result"]["rawMaterial"]>
    composites: {}
  }

  type RawMaterialGetPayload<S extends boolean | null | undefined | RawMaterialDefaultArgs> = $Result.GetResult<Prisma.$RawMaterialPayload, S>

  type RawMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RawMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RawMaterialCountAggregateInputType | true
    }

  export interface RawMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RawMaterial'], meta: { name: 'RawMaterial' } }
    /**
     * Find zero or one RawMaterial that matches the filter.
     * @param {RawMaterialFindUniqueArgs} args - Arguments to find a RawMaterial
     * @example
     * // Get one RawMaterial
     * const rawMaterial = await prisma.rawMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RawMaterialFindUniqueArgs>(args: SelectSubset<T, RawMaterialFindUniqueArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RawMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RawMaterialFindUniqueOrThrowArgs} args - Arguments to find a RawMaterial
     * @example
     * // Get one RawMaterial
     * const rawMaterial = await prisma.rawMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RawMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, RawMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialFindFirstArgs} args - Arguments to find a RawMaterial
     * @example
     * // Get one RawMaterial
     * const rawMaterial = await prisma.rawMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RawMaterialFindFirstArgs>(args?: SelectSubset<T, RawMaterialFindFirstArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialFindFirstOrThrowArgs} args - Arguments to find a RawMaterial
     * @example
     * // Get one RawMaterial
     * const rawMaterial = await prisma.rawMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RawMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, RawMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RawMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RawMaterials
     * const rawMaterials = await prisma.rawMaterial.findMany()
     * 
     * // Get first 10 RawMaterials
     * const rawMaterials = await prisma.rawMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rawMaterialWithIdOnly = await prisma.rawMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RawMaterialFindManyArgs>(args?: SelectSubset<T, RawMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RawMaterial.
     * @param {RawMaterialCreateArgs} args - Arguments to create a RawMaterial.
     * @example
     * // Create one RawMaterial
     * const RawMaterial = await prisma.rawMaterial.create({
     *   data: {
     *     // ... data to create a RawMaterial
     *   }
     * })
     * 
     */
    create<T extends RawMaterialCreateArgs>(args: SelectSubset<T, RawMaterialCreateArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RawMaterials.
     * @param {RawMaterialCreateManyArgs} args - Arguments to create many RawMaterials.
     * @example
     * // Create many RawMaterials
     * const rawMaterial = await prisma.rawMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RawMaterialCreateManyArgs>(args?: SelectSubset<T, RawMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RawMaterials and returns the data saved in the database.
     * @param {RawMaterialCreateManyAndReturnArgs} args - Arguments to create many RawMaterials.
     * @example
     * // Create many RawMaterials
     * const rawMaterial = await prisma.rawMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RawMaterials and only return the `id`
     * const rawMaterialWithIdOnly = await prisma.rawMaterial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RawMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, RawMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RawMaterial.
     * @param {RawMaterialDeleteArgs} args - Arguments to delete one RawMaterial.
     * @example
     * // Delete one RawMaterial
     * const RawMaterial = await prisma.rawMaterial.delete({
     *   where: {
     *     // ... filter to delete one RawMaterial
     *   }
     * })
     * 
     */
    delete<T extends RawMaterialDeleteArgs>(args: SelectSubset<T, RawMaterialDeleteArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RawMaterial.
     * @param {RawMaterialUpdateArgs} args - Arguments to update one RawMaterial.
     * @example
     * // Update one RawMaterial
     * const rawMaterial = await prisma.rawMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RawMaterialUpdateArgs>(args: SelectSubset<T, RawMaterialUpdateArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RawMaterials.
     * @param {RawMaterialDeleteManyArgs} args - Arguments to filter RawMaterials to delete.
     * @example
     * // Delete a few RawMaterials
     * const { count } = await prisma.rawMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RawMaterialDeleteManyArgs>(args?: SelectSubset<T, RawMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RawMaterials
     * const rawMaterial = await prisma.rawMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RawMaterialUpdateManyArgs>(args: SelectSubset<T, RawMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawMaterials and returns the data updated in the database.
     * @param {RawMaterialUpdateManyAndReturnArgs} args - Arguments to update many RawMaterials.
     * @example
     * // Update many RawMaterials
     * const rawMaterial = await prisma.rawMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RawMaterials and only return the `id`
     * const rawMaterialWithIdOnly = await prisma.rawMaterial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RawMaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, RawMaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RawMaterial.
     * @param {RawMaterialUpsertArgs} args - Arguments to update or create a RawMaterial.
     * @example
     * // Update or create a RawMaterial
     * const rawMaterial = await prisma.rawMaterial.upsert({
     *   create: {
     *     // ... data to create a RawMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RawMaterial we want to update
     *   }
     * })
     */
    upsert<T extends RawMaterialUpsertArgs>(args: SelectSubset<T, RawMaterialUpsertArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RawMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialCountArgs} args - Arguments to filter RawMaterials to count.
     * @example
     * // Count the number of RawMaterials
     * const count = await prisma.rawMaterial.count({
     *   where: {
     *     // ... the filter for the RawMaterials we want to count
     *   }
     * })
    **/
    count<T extends RawMaterialCountArgs>(
      args?: Subset<T, RawMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RawMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RawMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RawMaterialAggregateArgs>(args: Subset<T, RawMaterialAggregateArgs>): Prisma.PrismaPromise<GetRawMaterialAggregateType<T>>

    /**
     * Group by RawMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RawMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RawMaterialGroupByArgs['orderBy'] }
        : { orderBy?: RawMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RawMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRawMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RawMaterial model
   */
  readonly fields: RawMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RawMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RawMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    elements<T extends RawMaterial$elementsArgs<ExtArgs> = {}>(args?: Subset<T, RawMaterial$elementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    packagingForProducts<T extends RawMaterial$packagingForProductsArgs<ExtArgs> = {}>(args?: Subset<T, RawMaterial$packagingForProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends RawMaterial$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, RawMaterial$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RawMaterial model
   */
  interface RawMaterialFieldRefs {
    readonly id: FieldRef<"RawMaterial", 'String'>
    readonly name: FieldRef<"RawMaterial", 'String'>
    readonly unit: FieldRef<"RawMaterial", 'String'>
    readonly stockQty: FieldRef<"RawMaterial", 'Float'>
    readonly createdAt: FieldRef<"RawMaterial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RawMaterial findUnique
   */
  export type RawMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterial to fetch.
     */
    where: RawMaterialWhereUniqueInput
  }

  /**
   * RawMaterial findUniqueOrThrow
   */
  export type RawMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterial to fetch.
     */
    where: RawMaterialWhereUniqueInput
  }

  /**
   * RawMaterial findFirst
   */
  export type RawMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterial to fetch.
     */
    where?: RawMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterials to fetch.
     */
    orderBy?: RawMaterialOrderByWithRelationInput | RawMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawMaterials.
     */
    cursor?: RawMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawMaterials.
     */
    distinct?: RawMaterialScalarFieldEnum | RawMaterialScalarFieldEnum[]
  }

  /**
   * RawMaterial findFirstOrThrow
   */
  export type RawMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterial to fetch.
     */
    where?: RawMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterials to fetch.
     */
    orderBy?: RawMaterialOrderByWithRelationInput | RawMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawMaterials.
     */
    cursor?: RawMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawMaterials.
     */
    distinct?: RawMaterialScalarFieldEnum | RawMaterialScalarFieldEnum[]
  }

  /**
   * RawMaterial findMany
   */
  export type RawMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterials to fetch.
     */
    where?: RawMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterials to fetch.
     */
    orderBy?: RawMaterialOrderByWithRelationInput | RawMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RawMaterials.
     */
    cursor?: RawMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterials.
     */
    skip?: number
    distinct?: RawMaterialScalarFieldEnum | RawMaterialScalarFieldEnum[]
  }

  /**
   * RawMaterial create
   */
  export type RawMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a RawMaterial.
     */
    data: XOR<RawMaterialCreateInput, RawMaterialUncheckedCreateInput>
  }

  /**
   * RawMaterial createMany
   */
  export type RawMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RawMaterials.
     */
    data: RawMaterialCreateManyInput | RawMaterialCreateManyInput[]
  }

  /**
   * RawMaterial createManyAndReturn
   */
  export type RawMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * The data used to create many RawMaterials.
     */
    data: RawMaterialCreateManyInput | RawMaterialCreateManyInput[]
  }

  /**
   * RawMaterial update
   */
  export type RawMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a RawMaterial.
     */
    data: XOR<RawMaterialUpdateInput, RawMaterialUncheckedUpdateInput>
    /**
     * Choose, which RawMaterial to update.
     */
    where: RawMaterialWhereUniqueInput
  }

  /**
   * RawMaterial updateMany
   */
  export type RawMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RawMaterials.
     */
    data: XOR<RawMaterialUpdateManyMutationInput, RawMaterialUncheckedUpdateManyInput>
    /**
     * Filter which RawMaterials to update
     */
    where?: RawMaterialWhereInput
    /**
     * Limit how many RawMaterials to update.
     */
    limit?: number
  }

  /**
   * RawMaterial updateManyAndReturn
   */
  export type RawMaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * The data used to update RawMaterials.
     */
    data: XOR<RawMaterialUpdateManyMutationInput, RawMaterialUncheckedUpdateManyInput>
    /**
     * Filter which RawMaterials to update
     */
    where?: RawMaterialWhereInput
    /**
     * Limit how many RawMaterials to update.
     */
    limit?: number
  }

  /**
   * RawMaterial upsert
   */
  export type RawMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the RawMaterial to update in case it exists.
     */
    where: RawMaterialWhereUniqueInput
    /**
     * In case the RawMaterial found by the `where` argument doesn't exist, create a new RawMaterial with this data.
     */
    create: XOR<RawMaterialCreateInput, RawMaterialUncheckedCreateInput>
    /**
     * In case the RawMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RawMaterialUpdateInput, RawMaterialUncheckedUpdateInput>
  }

  /**
   * RawMaterial delete
   */
  export type RawMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    /**
     * Filter which RawMaterial to delete.
     */
    where: RawMaterialWhereUniqueInput
  }

  /**
   * RawMaterial deleteMany
   */
  export type RawMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawMaterials to delete
     */
    where?: RawMaterialWhereInput
    /**
     * Limit how many RawMaterials to delete.
     */
    limit?: number
  }

  /**
   * RawMaterial.elements
   */
  export type RawMaterial$elementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    where?: ElementWhereInput
    orderBy?: ElementOrderByWithRelationInput | ElementOrderByWithRelationInput[]
    cursor?: ElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElementScalarFieldEnum | ElementScalarFieldEnum[]
  }

  /**
   * RawMaterial.packagingForProducts
   */
  export type RawMaterial$packagingForProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * RawMaterial.transactions
   */
  export type RawMaterial$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
    where?: RawMaterialTransactionWhereInput
    orderBy?: RawMaterialTransactionOrderByWithRelationInput | RawMaterialTransactionOrderByWithRelationInput[]
    cursor?: RawMaterialTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RawMaterialTransactionScalarFieldEnum | RawMaterialTransactionScalarFieldEnum[]
  }

  /**
   * RawMaterial without action
   */
  export type RawMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
  }


  /**
   * Model RawMaterialTransaction
   */

  export type AggregateRawMaterialTransaction = {
    _count: RawMaterialTransactionCountAggregateOutputType | null
    _avg: RawMaterialTransactionAvgAggregateOutputType | null
    _sum: RawMaterialTransactionSumAggregateOutputType | null
    _min: RawMaterialTransactionMinAggregateOutputType | null
    _max: RawMaterialTransactionMaxAggregateOutputType | null
  }

  export type RawMaterialTransactionAvgAggregateOutputType = {
    changeAmount: number | null
  }

  export type RawMaterialTransactionSumAggregateOutputType = {
    changeAmount: number | null
  }

  export type RawMaterialTransactionMinAggregateOutputType = {
    id: string | null
    rawMaterialId: string | null
    changeAmount: number | null
    reason: string | null
    createdAt: Date | null
  }

  export type RawMaterialTransactionMaxAggregateOutputType = {
    id: string | null
    rawMaterialId: string | null
    changeAmount: number | null
    reason: string | null
    createdAt: Date | null
  }

  export type RawMaterialTransactionCountAggregateOutputType = {
    id: number
    rawMaterialId: number
    changeAmount: number
    reason: number
    createdAt: number
    _all: number
  }


  export type RawMaterialTransactionAvgAggregateInputType = {
    changeAmount?: true
  }

  export type RawMaterialTransactionSumAggregateInputType = {
    changeAmount?: true
  }

  export type RawMaterialTransactionMinAggregateInputType = {
    id?: true
    rawMaterialId?: true
    changeAmount?: true
    reason?: true
    createdAt?: true
  }

  export type RawMaterialTransactionMaxAggregateInputType = {
    id?: true
    rawMaterialId?: true
    changeAmount?: true
    reason?: true
    createdAt?: true
  }

  export type RawMaterialTransactionCountAggregateInputType = {
    id?: true
    rawMaterialId?: true
    changeAmount?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type RawMaterialTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawMaterialTransaction to aggregate.
     */
    where?: RawMaterialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterialTransactions to fetch.
     */
    orderBy?: RawMaterialTransactionOrderByWithRelationInput | RawMaterialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RawMaterialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RawMaterialTransactions
    **/
    _count?: true | RawMaterialTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RawMaterialTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RawMaterialTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RawMaterialTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RawMaterialTransactionMaxAggregateInputType
  }

  export type GetRawMaterialTransactionAggregateType<T extends RawMaterialTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateRawMaterialTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRawMaterialTransaction[P]>
      : GetScalarType<T[P], AggregateRawMaterialTransaction[P]>
  }




  export type RawMaterialTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawMaterialTransactionWhereInput
    orderBy?: RawMaterialTransactionOrderByWithAggregationInput | RawMaterialTransactionOrderByWithAggregationInput[]
    by: RawMaterialTransactionScalarFieldEnum[] | RawMaterialTransactionScalarFieldEnum
    having?: RawMaterialTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RawMaterialTransactionCountAggregateInputType | true
    _avg?: RawMaterialTransactionAvgAggregateInputType
    _sum?: RawMaterialTransactionSumAggregateInputType
    _min?: RawMaterialTransactionMinAggregateInputType
    _max?: RawMaterialTransactionMaxAggregateInputType
  }

  export type RawMaterialTransactionGroupByOutputType = {
    id: string
    rawMaterialId: string
    changeAmount: number
    reason: string
    createdAt: Date
    _count: RawMaterialTransactionCountAggregateOutputType | null
    _avg: RawMaterialTransactionAvgAggregateOutputType | null
    _sum: RawMaterialTransactionSumAggregateOutputType | null
    _min: RawMaterialTransactionMinAggregateOutputType | null
    _max: RawMaterialTransactionMaxAggregateOutputType | null
  }

  type GetRawMaterialTransactionGroupByPayload<T extends RawMaterialTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RawMaterialTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RawMaterialTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RawMaterialTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], RawMaterialTransactionGroupByOutputType[P]>
        }
      >
    >


  export type RawMaterialTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rawMaterialId?: boolean
    changeAmount?: boolean
    reason?: boolean
    createdAt?: boolean
    rawMaterial?: boolean | RawMaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawMaterialTransaction"]>

  export type RawMaterialTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rawMaterialId?: boolean
    changeAmount?: boolean
    reason?: boolean
    createdAt?: boolean
    rawMaterial?: boolean | RawMaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawMaterialTransaction"]>

  export type RawMaterialTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rawMaterialId?: boolean
    changeAmount?: boolean
    reason?: boolean
    createdAt?: boolean
    rawMaterial?: boolean | RawMaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawMaterialTransaction"]>

  export type RawMaterialTransactionSelectScalar = {
    id?: boolean
    rawMaterialId?: boolean
    changeAmount?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type RawMaterialTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rawMaterialId" | "changeAmount" | "reason" | "createdAt", ExtArgs["result"]["rawMaterialTransaction"]>
  export type RawMaterialTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawMaterial?: boolean | RawMaterialDefaultArgs<ExtArgs>
  }
  export type RawMaterialTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawMaterial?: boolean | RawMaterialDefaultArgs<ExtArgs>
  }
  export type RawMaterialTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawMaterial?: boolean | RawMaterialDefaultArgs<ExtArgs>
  }

  export type $RawMaterialTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RawMaterialTransaction"
    objects: {
      rawMaterial: Prisma.$RawMaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rawMaterialId: string
      changeAmount: number
      reason: string
      createdAt: Date
    }, ExtArgs["result"]["rawMaterialTransaction"]>
    composites: {}
  }

  type RawMaterialTransactionGetPayload<S extends boolean | null | undefined | RawMaterialTransactionDefaultArgs> = $Result.GetResult<Prisma.$RawMaterialTransactionPayload, S>

  type RawMaterialTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RawMaterialTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RawMaterialTransactionCountAggregateInputType | true
    }

  export interface RawMaterialTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RawMaterialTransaction'], meta: { name: 'RawMaterialTransaction' } }
    /**
     * Find zero or one RawMaterialTransaction that matches the filter.
     * @param {RawMaterialTransactionFindUniqueArgs} args - Arguments to find a RawMaterialTransaction
     * @example
     * // Get one RawMaterialTransaction
     * const rawMaterialTransaction = await prisma.rawMaterialTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RawMaterialTransactionFindUniqueArgs>(args: SelectSubset<T, RawMaterialTransactionFindUniqueArgs<ExtArgs>>): Prisma__RawMaterialTransactionClient<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RawMaterialTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RawMaterialTransactionFindUniqueOrThrowArgs} args - Arguments to find a RawMaterialTransaction
     * @example
     * // Get one RawMaterialTransaction
     * const rawMaterialTransaction = await prisma.rawMaterialTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RawMaterialTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, RawMaterialTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RawMaterialTransactionClient<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawMaterialTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialTransactionFindFirstArgs} args - Arguments to find a RawMaterialTransaction
     * @example
     * // Get one RawMaterialTransaction
     * const rawMaterialTransaction = await prisma.rawMaterialTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RawMaterialTransactionFindFirstArgs>(args?: SelectSubset<T, RawMaterialTransactionFindFirstArgs<ExtArgs>>): Prisma__RawMaterialTransactionClient<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawMaterialTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialTransactionFindFirstOrThrowArgs} args - Arguments to find a RawMaterialTransaction
     * @example
     * // Get one RawMaterialTransaction
     * const rawMaterialTransaction = await prisma.rawMaterialTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RawMaterialTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, RawMaterialTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RawMaterialTransactionClient<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RawMaterialTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RawMaterialTransactions
     * const rawMaterialTransactions = await prisma.rawMaterialTransaction.findMany()
     * 
     * // Get first 10 RawMaterialTransactions
     * const rawMaterialTransactions = await prisma.rawMaterialTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rawMaterialTransactionWithIdOnly = await prisma.rawMaterialTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RawMaterialTransactionFindManyArgs>(args?: SelectSubset<T, RawMaterialTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RawMaterialTransaction.
     * @param {RawMaterialTransactionCreateArgs} args - Arguments to create a RawMaterialTransaction.
     * @example
     * // Create one RawMaterialTransaction
     * const RawMaterialTransaction = await prisma.rawMaterialTransaction.create({
     *   data: {
     *     // ... data to create a RawMaterialTransaction
     *   }
     * })
     * 
     */
    create<T extends RawMaterialTransactionCreateArgs>(args: SelectSubset<T, RawMaterialTransactionCreateArgs<ExtArgs>>): Prisma__RawMaterialTransactionClient<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RawMaterialTransactions.
     * @param {RawMaterialTransactionCreateManyArgs} args - Arguments to create many RawMaterialTransactions.
     * @example
     * // Create many RawMaterialTransactions
     * const rawMaterialTransaction = await prisma.rawMaterialTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RawMaterialTransactionCreateManyArgs>(args?: SelectSubset<T, RawMaterialTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RawMaterialTransactions and returns the data saved in the database.
     * @param {RawMaterialTransactionCreateManyAndReturnArgs} args - Arguments to create many RawMaterialTransactions.
     * @example
     * // Create many RawMaterialTransactions
     * const rawMaterialTransaction = await prisma.rawMaterialTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RawMaterialTransactions and only return the `id`
     * const rawMaterialTransactionWithIdOnly = await prisma.rawMaterialTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RawMaterialTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, RawMaterialTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RawMaterialTransaction.
     * @param {RawMaterialTransactionDeleteArgs} args - Arguments to delete one RawMaterialTransaction.
     * @example
     * // Delete one RawMaterialTransaction
     * const RawMaterialTransaction = await prisma.rawMaterialTransaction.delete({
     *   where: {
     *     // ... filter to delete one RawMaterialTransaction
     *   }
     * })
     * 
     */
    delete<T extends RawMaterialTransactionDeleteArgs>(args: SelectSubset<T, RawMaterialTransactionDeleteArgs<ExtArgs>>): Prisma__RawMaterialTransactionClient<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RawMaterialTransaction.
     * @param {RawMaterialTransactionUpdateArgs} args - Arguments to update one RawMaterialTransaction.
     * @example
     * // Update one RawMaterialTransaction
     * const rawMaterialTransaction = await prisma.rawMaterialTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RawMaterialTransactionUpdateArgs>(args: SelectSubset<T, RawMaterialTransactionUpdateArgs<ExtArgs>>): Prisma__RawMaterialTransactionClient<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RawMaterialTransactions.
     * @param {RawMaterialTransactionDeleteManyArgs} args - Arguments to filter RawMaterialTransactions to delete.
     * @example
     * // Delete a few RawMaterialTransactions
     * const { count } = await prisma.rawMaterialTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RawMaterialTransactionDeleteManyArgs>(args?: SelectSubset<T, RawMaterialTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawMaterialTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RawMaterialTransactions
     * const rawMaterialTransaction = await prisma.rawMaterialTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RawMaterialTransactionUpdateManyArgs>(args: SelectSubset<T, RawMaterialTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawMaterialTransactions and returns the data updated in the database.
     * @param {RawMaterialTransactionUpdateManyAndReturnArgs} args - Arguments to update many RawMaterialTransactions.
     * @example
     * // Update many RawMaterialTransactions
     * const rawMaterialTransaction = await prisma.rawMaterialTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RawMaterialTransactions and only return the `id`
     * const rawMaterialTransactionWithIdOnly = await prisma.rawMaterialTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RawMaterialTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, RawMaterialTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RawMaterialTransaction.
     * @param {RawMaterialTransactionUpsertArgs} args - Arguments to update or create a RawMaterialTransaction.
     * @example
     * // Update or create a RawMaterialTransaction
     * const rawMaterialTransaction = await prisma.rawMaterialTransaction.upsert({
     *   create: {
     *     // ... data to create a RawMaterialTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RawMaterialTransaction we want to update
     *   }
     * })
     */
    upsert<T extends RawMaterialTransactionUpsertArgs>(args: SelectSubset<T, RawMaterialTransactionUpsertArgs<ExtArgs>>): Prisma__RawMaterialTransactionClient<$Result.GetResult<Prisma.$RawMaterialTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RawMaterialTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialTransactionCountArgs} args - Arguments to filter RawMaterialTransactions to count.
     * @example
     * // Count the number of RawMaterialTransactions
     * const count = await prisma.rawMaterialTransaction.count({
     *   where: {
     *     // ... the filter for the RawMaterialTransactions we want to count
     *   }
     * })
    **/
    count<T extends RawMaterialTransactionCountArgs>(
      args?: Subset<T, RawMaterialTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RawMaterialTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RawMaterialTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RawMaterialTransactionAggregateArgs>(args: Subset<T, RawMaterialTransactionAggregateArgs>): Prisma.PrismaPromise<GetRawMaterialTransactionAggregateType<T>>

    /**
     * Group by RawMaterialTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RawMaterialTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RawMaterialTransactionGroupByArgs['orderBy'] }
        : { orderBy?: RawMaterialTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RawMaterialTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRawMaterialTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RawMaterialTransaction model
   */
  readonly fields: RawMaterialTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RawMaterialTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RawMaterialTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rawMaterial<T extends RawMaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RawMaterialDefaultArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RawMaterialTransaction model
   */
  interface RawMaterialTransactionFieldRefs {
    readonly id: FieldRef<"RawMaterialTransaction", 'String'>
    readonly rawMaterialId: FieldRef<"RawMaterialTransaction", 'String'>
    readonly changeAmount: FieldRef<"RawMaterialTransaction", 'Float'>
    readonly reason: FieldRef<"RawMaterialTransaction", 'String'>
    readonly createdAt: FieldRef<"RawMaterialTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RawMaterialTransaction findUnique
   */
  export type RawMaterialTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterialTransaction to fetch.
     */
    where: RawMaterialTransactionWhereUniqueInput
  }

  /**
   * RawMaterialTransaction findUniqueOrThrow
   */
  export type RawMaterialTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterialTransaction to fetch.
     */
    where: RawMaterialTransactionWhereUniqueInput
  }

  /**
   * RawMaterialTransaction findFirst
   */
  export type RawMaterialTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterialTransaction to fetch.
     */
    where?: RawMaterialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterialTransactions to fetch.
     */
    orderBy?: RawMaterialTransactionOrderByWithRelationInput | RawMaterialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawMaterialTransactions.
     */
    cursor?: RawMaterialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawMaterialTransactions.
     */
    distinct?: RawMaterialTransactionScalarFieldEnum | RawMaterialTransactionScalarFieldEnum[]
  }

  /**
   * RawMaterialTransaction findFirstOrThrow
   */
  export type RawMaterialTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterialTransaction to fetch.
     */
    where?: RawMaterialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterialTransactions to fetch.
     */
    orderBy?: RawMaterialTransactionOrderByWithRelationInput | RawMaterialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawMaterialTransactions.
     */
    cursor?: RawMaterialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawMaterialTransactions.
     */
    distinct?: RawMaterialTransactionScalarFieldEnum | RawMaterialTransactionScalarFieldEnum[]
  }

  /**
   * RawMaterialTransaction findMany
   */
  export type RawMaterialTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterialTransactions to fetch.
     */
    where?: RawMaterialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterialTransactions to fetch.
     */
    orderBy?: RawMaterialTransactionOrderByWithRelationInput | RawMaterialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RawMaterialTransactions.
     */
    cursor?: RawMaterialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterialTransactions.
     */
    skip?: number
    distinct?: RawMaterialTransactionScalarFieldEnum | RawMaterialTransactionScalarFieldEnum[]
  }

  /**
   * RawMaterialTransaction create
   */
  export type RawMaterialTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a RawMaterialTransaction.
     */
    data: XOR<RawMaterialTransactionCreateInput, RawMaterialTransactionUncheckedCreateInput>
  }

  /**
   * RawMaterialTransaction createMany
   */
  export type RawMaterialTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RawMaterialTransactions.
     */
    data: RawMaterialTransactionCreateManyInput | RawMaterialTransactionCreateManyInput[]
  }

  /**
   * RawMaterialTransaction createManyAndReturn
   */
  export type RawMaterialTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many RawMaterialTransactions.
     */
    data: RawMaterialTransactionCreateManyInput | RawMaterialTransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RawMaterialTransaction update
   */
  export type RawMaterialTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a RawMaterialTransaction.
     */
    data: XOR<RawMaterialTransactionUpdateInput, RawMaterialTransactionUncheckedUpdateInput>
    /**
     * Choose, which RawMaterialTransaction to update.
     */
    where: RawMaterialTransactionWhereUniqueInput
  }

  /**
   * RawMaterialTransaction updateMany
   */
  export type RawMaterialTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RawMaterialTransactions.
     */
    data: XOR<RawMaterialTransactionUpdateManyMutationInput, RawMaterialTransactionUncheckedUpdateManyInput>
    /**
     * Filter which RawMaterialTransactions to update
     */
    where?: RawMaterialTransactionWhereInput
    /**
     * Limit how many RawMaterialTransactions to update.
     */
    limit?: number
  }

  /**
   * RawMaterialTransaction updateManyAndReturn
   */
  export type RawMaterialTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * The data used to update RawMaterialTransactions.
     */
    data: XOR<RawMaterialTransactionUpdateManyMutationInput, RawMaterialTransactionUncheckedUpdateManyInput>
    /**
     * Filter which RawMaterialTransactions to update
     */
    where?: RawMaterialTransactionWhereInput
    /**
     * Limit how many RawMaterialTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RawMaterialTransaction upsert
   */
  export type RawMaterialTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the RawMaterialTransaction to update in case it exists.
     */
    where: RawMaterialTransactionWhereUniqueInput
    /**
     * In case the RawMaterialTransaction found by the `where` argument doesn't exist, create a new RawMaterialTransaction with this data.
     */
    create: XOR<RawMaterialTransactionCreateInput, RawMaterialTransactionUncheckedCreateInput>
    /**
     * In case the RawMaterialTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RawMaterialTransactionUpdateInput, RawMaterialTransactionUncheckedUpdateInput>
  }

  /**
   * RawMaterialTransaction delete
   */
  export type RawMaterialTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
    /**
     * Filter which RawMaterialTransaction to delete.
     */
    where: RawMaterialTransactionWhereUniqueInput
  }

  /**
   * RawMaterialTransaction deleteMany
   */
  export type RawMaterialTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawMaterialTransactions to delete
     */
    where?: RawMaterialTransactionWhereInput
    /**
     * Limit how many RawMaterialTransactions to delete.
     */
    limit?: number
  }

  /**
   * RawMaterialTransaction without action
   */
  export type RawMaterialTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialTransaction
     */
    select?: RawMaterialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialTransaction
     */
    omit?: RawMaterialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Element
   */

  export type AggregateElement = {
    _count: ElementCountAggregateOutputType | null
    _avg: ElementAvgAggregateOutputType | null
    _sum: ElementSumAggregateOutputType | null
    _min: ElementMinAggregateOutputType | null
    _max: ElementMaxAggregateOutputType | null
  }

  export type ElementAvgAggregateOutputType = {
    weightGrams: Decimal | null
  }

  export type ElementSumAggregateOutputType = {
    weightGrams: Decimal | null
  }

  export type ElementMinAggregateOutputType = {
    id: string | null
    uniqueName: string | null
    label: string | null
    color: string | null
    color2: string | null
    isDualColor: boolean | null
    material: string | null
    rawMaterialId: string | null
    weightGrams: Decimal | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type ElementMaxAggregateOutputType = {
    id: string | null
    uniqueName: string | null
    label: string | null
    color: string | null
    color2: string | null
    isDualColor: boolean | null
    material: string | null
    rawMaterialId: string | null
    weightGrams: Decimal | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type ElementCountAggregateOutputType = {
    id: number
    uniqueName: number
    label: number
    color: number
    color2: number
    isDualColor: number
    material: number
    rawMaterialId: number
    weightGrams: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type ElementAvgAggregateInputType = {
    weightGrams?: true
  }

  export type ElementSumAggregateInputType = {
    weightGrams?: true
  }

  export type ElementMinAggregateInputType = {
    id?: true
    uniqueName?: true
    label?: true
    color?: true
    color2?: true
    isDualColor?: true
    material?: true
    rawMaterialId?: true
    weightGrams?: true
    imageUrl?: true
    createdAt?: true
  }

  export type ElementMaxAggregateInputType = {
    id?: true
    uniqueName?: true
    label?: true
    color?: true
    color2?: true
    isDualColor?: true
    material?: true
    rawMaterialId?: true
    weightGrams?: true
    imageUrl?: true
    createdAt?: true
  }

  export type ElementCountAggregateInputType = {
    id?: true
    uniqueName?: true
    label?: true
    color?: true
    color2?: true
    isDualColor?: true
    material?: true
    rawMaterialId?: true
    weightGrams?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type ElementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Element to aggregate.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: ElementOrderByWithRelationInput | ElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Elements
    **/
    _count?: true | ElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ElementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ElementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElementMaxAggregateInputType
  }

  export type GetElementAggregateType<T extends ElementAggregateArgs> = {
        [P in keyof T & keyof AggregateElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElement[P]>
      : GetScalarType<T[P], AggregateElement[P]>
  }




  export type ElementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElementWhereInput
    orderBy?: ElementOrderByWithAggregationInput | ElementOrderByWithAggregationInput[]
    by: ElementScalarFieldEnum[] | ElementScalarFieldEnum
    having?: ElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElementCountAggregateInputType | true
    _avg?: ElementAvgAggregateInputType
    _sum?: ElementSumAggregateInputType
    _min?: ElementMinAggregateInputType
    _max?: ElementMaxAggregateInputType
  }

  export type ElementGroupByOutputType = {
    id: string
    uniqueName: string
    label: string
    color: string
    color2: string | null
    isDualColor: boolean
    material: string
    rawMaterialId: string | null
    weightGrams: Decimal
    imageUrl: string | null
    createdAt: Date
    _count: ElementCountAggregateOutputType | null
    _avg: ElementAvgAggregateOutputType | null
    _sum: ElementSumAggregateOutputType | null
    _min: ElementMinAggregateOutputType | null
    _max: ElementMaxAggregateOutputType | null
  }

  type GetElementGroupByPayload<T extends ElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElementGroupByOutputType[P]>
            : GetScalarType<T[P], ElementGroupByOutputType[P]>
        }
      >
    >


  export type ElementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uniqueName?: boolean
    label?: boolean
    color?: boolean
    color2?: boolean
    isDualColor?: boolean
    material?: boolean
    rawMaterialId?: boolean
    weightGrams?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    rawMaterial?: boolean | Element$rawMaterialArgs<ExtArgs>
    productElements?: boolean | Element$productElementsArgs<ExtArgs>
    inventory?: boolean | Element$inventoryArgs<ExtArgs>
    inventoryTransactions?: boolean | Element$inventoryTransactionsArgs<ExtArgs>
    materialRequirements?: boolean | Element$materialRequirementsArgs<ExtArgs>
    inventoryAllocations?: boolean | Element$inventoryAllocationsArgs<ExtArgs>
    _count?: boolean | ElementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["element"]>

  export type ElementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uniqueName?: boolean
    label?: boolean
    color?: boolean
    color2?: boolean
    isDualColor?: boolean
    material?: boolean
    rawMaterialId?: boolean
    weightGrams?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    rawMaterial?: boolean | Element$rawMaterialArgs<ExtArgs>
  }, ExtArgs["result"]["element"]>

  export type ElementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uniqueName?: boolean
    label?: boolean
    color?: boolean
    color2?: boolean
    isDualColor?: boolean
    material?: boolean
    rawMaterialId?: boolean
    weightGrams?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    rawMaterial?: boolean | Element$rawMaterialArgs<ExtArgs>
  }, ExtArgs["result"]["element"]>

  export type ElementSelectScalar = {
    id?: boolean
    uniqueName?: boolean
    label?: boolean
    color?: boolean
    color2?: boolean
    isDualColor?: boolean
    material?: boolean
    rawMaterialId?: boolean
    weightGrams?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type ElementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uniqueName" | "label" | "color" | "color2" | "isDualColor" | "material" | "rawMaterialId" | "weightGrams" | "imageUrl" | "createdAt", ExtArgs["result"]["element"]>
  export type ElementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawMaterial?: boolean | Element$rawMaterialArgs<ExtArgs>
    productElements?: boolean | Element$productElementsArgs<ExtArgs>
    inventory?: boolean | Element$inventoryArgs<ExtArgs>
    inventoryTransactions?: boolean | Element$inventoryTransactionsArgs<ExtArgs>
    materialRequirements?: boolean | Element$materialRequirementsArgs<ExtArgs>
    inventoryAllocations?: boolean | Element$inventoryAllocationsArgs<ExtArgs>
    _count?: boolean | ElementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ElementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawMaterial?: boolean | Element$rawMaterialArgs<ExtArgs>
  }
  export type ElementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawMaterial?: boolean | Element$rawMaterialArgs<ExtArgs>
  }

  export type $ElementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Element"
    objects: {
      rawMaterial: Prisma.$RawMaterialPayload<ExtArgs> | null
      productElements: Prisma.$ProductElementPayload<ExtArgs>[]
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      inventoryTransactions: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      materialRequirements: Prisma.$MaterialRequirementPayload<ExtArgs>[]
      inventoryAllocations: Prisma.$InventoryAllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uniqueName: string
      label: string
      color: string
      color2: string | null
      isDualColor: boolean
      material: string
      rawMaterialId: string | null
      weightGrams: Prisma.Decimal
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["element"]>
    composites: {}
  }

  type ElementGetPayload<S extends boolean | null | undefined | ElementDefaultArgs> = $Result.GetResult<Prisma.$ElementPayload, S>

  type ElementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElementCountAggregateInputType | true
    }

  export interface ElementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Element'], meta: { name: 'Element' } }
    /**
     * Find zero or one Element that matches the filter.
     * @param {ElementFindUniqueArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElementFindUniqueArgs>(args: SelectSubset<T, ElementFindUniqueArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Element that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElementFindUniqueOrThrowArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElementFindUniqueOrThrowArgs>(args: SelectSubset<T, ElementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Element that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementFindFirstArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElementFindFirstArgs>(args?: SelectSubset<T, ElementFindFirstArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Element that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementFindFirstOrThrowArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElementFindFirstOrThrowArgs>(args?: SelectSubset<T, ElementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Elements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Elements
     * const elements = await prisma.element.findMany()
     * 
     * // Get first 10 Elements
     * const elements = await prisma.element.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const elementWithIdOnly = await prisma.element.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElementFindManyArgs>(args?: SelectSubset<T, ElementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Element.
     * @param {ElementCreateArgs} args - Arguments to create a Element.
     * @example
     * // Create one Element
     * const Element = await prisma.element.create({
     *   data: {
     *     // ... data to create a Element
     *   }
     * })
     * 
     */
    create<T extends ElementCreateArgs>(args: SelectSubset<T, ElementCreateArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Elements.
     * @param {ElementCreateManyArgs} args - Arguments to create many Elements.
     * @example
     * // Create many Elements
     * const element = await prisma.element.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElementCreateManyArgs>(args?: SelectSubset<T, ElementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Elements and returns the data saved in the database.
     * @param {ElementCreateManyAndReturnArgs} args - Arguments to create many Elements.
     * @example
     * // Create many Elements
     * const element = await prisma.element.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Elements and only return the `id`
     * const elementWithIdOnly = await prisma.element.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElementCreateManyAndReturnArgs>(args?: SelectSubset<T, ElementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Element.
     * @param {ElementDeleteArgs} args - Arguments to delete one Element.
     * @example
     * // Delete one Element
     * const Element = await prisma.element.delete({
     *   where: {
     *     // ... filter to delete one Element
     *   }
     * })
     * 
     */
    delete<T extends ElementDeleteArgs>(args: SelectSubset<T, ElementDeleteArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Element.
     * @param {ElementUpdateArgs} args - Arguments to update one Element.
     * @example
     * // Update one Element
     * const element = await prisma.element.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElementUpdateArgs>(args: SelectSubset<T, ElementUpdateArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Elements.
     * @param {ElementDeleteManyArgs} args - Arguments to filter Elements to delete.
     * @example
     * // Delete a few Elements
     * const { count } = await prisma.element.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElementDeleteManyArgs>(args?: SelectSubset<T, ElementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Elements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Elements
     * const element = await prisma.element.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElementUpdateManyArgs>(args: SelectSubset<T, ElementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Elements and returns the data updated in the database.
     * @param {ElementUpdateManyAndReturnArgs} args - Arguments to update many Elements.
     * @example
     * // Update many Elements
     * const element = await prisma.element.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Elements and only return the `id`
     * const elementWithIdOnly = await prisma.element.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElementUpdateManyAndReturnArgs>(args: SelectSubset<T, ElementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Element.
     * @param {ElementUpsertArgs} args - Arguments to update or create a Element.
     * @example
     * // Update or create a Element
     * const element = await prisma.element.upsert({
     *   create: {
     *     // ... data to create a Element
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Element we want to update
     *   }
     * })
     */
    upsert<T extends ElementUpsertArgs>(args: SelectSubset<T, ElementUpsertArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Elements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementCountArgs} args - Arguments to filter Elements to count.
     * @example
     * // Count the number of Elements
     * const count = await prisma.element.count({
     *   where: {
     *     // ... the filter for the Elements we want to count
     *   }
     * })
    **/
    count<T extends ElementCountArgs>(
      args?: Subset<T, ElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Element.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElementAggregateArgs>(args: Subset<T, ElementAggregateArgs>): Prisma.PrismaPromise<GetElementAggregateType<T>>

    /**
     * Group by Element.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElementGroupByArgs['orderBy'] }
        : { orderBy?: ElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Element model
   */
  readonly fields: ElementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Element.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rawMaterial<T extends Element$rawMaterialArgs<ExtArgs> = {}>(args?: Subset<T, Element$rawMaterialArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productElements<T extends Element$productElementsArgs<ExtArgs> = {}>(args?: Subset<T, Element$productElementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends Element$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Element$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryTransactions<T extends Element$inventoryTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Element$inventoryTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materialRequirements<T extends Element$materialRequirementsArgs<ExtArgs> = {}>(args?: Subset<T, Element$materialRequirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryAllocations<T extends Element$inventoryAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, Element$inventoryAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Element model
   */
  interface ElementFieldRefs {
    readonly id: FieldRef<"Element", 'String'>
    readonly uniqueName: FieldRef<"Element", 'String'>
    readonly label: FieldRef<"Element", 'String'>
    readonly color: FieldRef<"Element", 'String'>
    readonly color2: FieldRef<"Element", 'String'>
    readonly isDualColor: FieldRef<"Element", 'Boolean'>
    readonly material: FieldRef<"Element", 'String'>
    readonly rawMaterialId: FieldRef<"Element", 'String'>
    readonly weightGrams: FieldRef<"Element", 'Decimal'>
    readonly imageUrl: FieldRef<"Element", 'String'>
    readonly createdAt: FieldRef<"Element", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Element findUnique
   */
  export type ElementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    /**
     * Filter, which Element to fetch.
     */
    where: ElementWhereUniqueInput
  }

  /**
   * Element findUniqueOrThrow
   */
  export type ElementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    /**
     * Filter, which Element to fetch.
     */
    where: ElementWhereUniqueInput
  }

  /**
   * Element findFirst
   */
  export type ElementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    /**
     * Filter, which Element to fetch.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: ElementOrderByWithRelationInput | ElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Elements.
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Elements.
     */
    distinct?: ElementScalarFieldEnum | ElementScalarFieldEnum[]
  }

  /**
   * Element findFirstOrThrow
   */
  export type ElementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    /**
     * Filter, which Element to fetch.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: ElementOrderByWithRelationInput | ElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Elements.
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Elements.
     */
    distinct?: ElementScalarFieldEnum | ElementScalarFieldEnum[]
  }

  /**
   * Element findMany
   */
  export type ElementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    /**
     * Filter, which Elements to fetch.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: ElementOrderByWithRelationInput | ElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Elements.
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    distinct?: ElementScalarFieldEnum | ElementScalarFieldEnum[]
  }

  /**
   * Element create
   */
  export type ElementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    /**
     * The data needed to create a Element.
     */
    data: XOR<ElementCreateInput, ElementUncheckedCreateInput>
  }

  /**
   * Element createMany
   */
  export type ElementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Elements.
     */
    data: ElementCreateManyInput | ElementCreateManyInput[]
  }

  /**
   * Element createManyAndReturn
   */
  export type ElementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * The data used to create many Elements.
     */
    data: ElementCreateManyInput | ElementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Element update
   */
  export type ElementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    /**
     * The data needed to update a Element.
     */
    data: XOR<ElementUpdateInput, ElementUncheckedUpdateInput>
    /**
     * Choose, which Element to update.
     */
    where: ElementWhereUniqueInput
  }

  /**
   * Element updateMany
   */
  export type ElementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Elements.
     */
    data: XOR<ElementUpdateManyMutationInput, ElementUncheckedUpdateManyInput>
    /**
     * Filter which Elements to update
     */
    where?: ElementWhereInput
    /**
     * Limit how many Elements to update.
     */
    limit?: number
  }

  /**
   * Element updateManyAndReturn
   */
  export type ElementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * The data used to update Elements.
     */
    data: XOR<ElementUpdateManyMutationInput, ElementUncheckedUpdateManyInput>
    /**
     * Filter which Elements to update
     */
    where?: ElementWhereInput
    /**
     * Limit how many Elements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Element upsert
   */
  export type ElementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    /**
     * The filter to search for the Element to update in case it exists.
     */
    where: ElementWhereUniqueInput
    /**
     * In case the Element found by the `where` argument doesn't exist, create a new Element with this data.
     */
    create: XOR<ElementCreateInput, ElementUncheckedCreateInput>
    /**
     * In case the Element was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElementUpdateInput, ElementUncheckedUpdateInput>
  }

  /**
   * Element delete
   */
  export type ElementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    /**
     * Filter which Element to delete.
     */
    where: ElementWhereUniqueInput
  }

  /**
   * Element deleteMany
   */
  export type ElementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Elements to delete
     */
    where?: ElementWhereInput
    /**
     * Limit how many Elements to delete.
     */
    limit?: number
  }

  /**
   * Element.rawMaterial
   */
  export type Element$rawMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    where?: RawMaterialWhereInput
  }

  /**
   * Element.productElements
   */
  export type Element$productElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    where?: ProductElementWhereInput
    orderBy?: ProductElementOrderByWithRelationInput | ProductElementOrderByWithRelationInput[]
    cursor?: ProductElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductElementScalarFieldEnum | ProductElementScalarFieldEnum[]
  }

  /**
   * Element.inventory
   */
  export type Element$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Element.inventoryTransactions
   */
  export type Element$inventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * Element.materialRequirements
   */
  export type Element$materialRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    where?: MaterialRequirementWhereInput
    orderBy?: MaterialRequirementOrderByWithRelationInput | MaterialRequirementOrderByWithRelationInput[]
    cursor?: MaterialRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialRequirementScalarFieldEnum | MaterialRequirementScalarFieldEnum[]
  }

  /**
   * Element.inventoryAllocations
   */
  export type Element$inventoryAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    where?: InventoryAllocationWhereInput
    orderBy?: InventoryAllocationOrderByWithRelationInput | InventoryAllocationOrderByWithRelationInput[]
    cursor?: InventoryAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryAllocationScalarFieldEnum | InventoryAllocationScalarFieldEnum[]
  }

  /**
   * Element without action
   */
  export type ElementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    unitsPerAssembly: number | null
    unitsPerBox: number | null
  }

  export type ProductSumAggregateOutputType = {
    unitsPerAssembly: number | null
    unitsPerBox: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    category: string | null
    label: string | null
    unitsPerAssembly: number | null
    unitsPerBox: number | null
    boxRawMaterialId: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    serialNumber: string | null
    category: string | null
    label: string | null
    unitsPerAssembly: number | null
    unitsPerBox: number | null
    boxRawMaterialId: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    serialNumber: number
    category: number
    label: number
    unitsPerAssembly: number
    unitsPerBox: number
    boxRawMaterialId: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    unitsPerAssembly?: true
    unitsPerBox?: true
  }

  export type ProductSumAggregateInputType = {
    unitsPerAssembly?: true
    unitsPerBox?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    serialNumber?: true
    category?: true
    label?: true
    unitsPerAssembly?: true
    unitsPerBox?: true
    boxRawMaterialId?: true
    imageUrl?: true
    createdAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    serialNumber?: true
    category?: true
    label?: true
    unitsPerAssembly?: true
    unitsPerBox?: true
    boxRawMaterialId?: true
    imageUrl?: true
    createdAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    serialNumber?: true
    category?: true
    label?: true
    unitsPerAssembly?: true
    unitsPerBox?: true
    boxRawMaterialId?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    serialNumber: string
    category: string
    label: string
    unitsPerAssembly: number
    unitsPerBox: number
    boxRawMaterialId: string | null
    imageUrl: string | null
    createdAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    category?: boolean
    label?: boolean
    unitsPerAssembly?: boolean
    unitsPerBox?: boolean
    boxRawMaterialId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    boxRawMaterial?: boolean | Product$boxRawMaterialArgs<ExtArgs>
    productElements?: boolean | Product$productElementsArgs<ExtArgs>
    productStock?: boolean | Product$productStockArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    manufacturingOrders?: boolean | Product$manufacturingOrdersArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    category?: boolean
    label?: boolean
    unitsPerAssembly?: boolean
    unitsPerBox?: boolean
    boxRawMaterialId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    boxRawMaterial?: boolean | Product$boxRawMaterialArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    category?: boolean
    label?: boolean
    unitsPerAssembly?: boolean
    unitsPerBox?: boolean
    boxRawMaterialId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    boxRawMaterial?: boolean | Product$boxRawMaterialArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    serialNumber?: boolean
    category?: boolean
    label?: boolean
    unitsPerAssembly?: boolean
    unitsPerBox?: boolean
    boxRawMaterialId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serialNumber" | "category" | "label" | "unitsPerAssembly" | "unitsPerBox" | "boxRawMaterialId" | "imageUrl" | "createdAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boxRawMaterial?: boolean | Product$boxRawMaterialArgs<ExtArgs>
    productElements?: boolean | Product$productElementsArgs<ExtArgs>
    productStock?: boolean | Product$productStockArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    manufacturingOrders?: boolean | Product$manufacturingOrdersArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boxRawMaterial?: boolean | Product$boxRawMaterialArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boxRawMaterial?: boolean | Product$boxRawMaterialArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      boxRawMaterial: Prisma.$RawMaterialPayload<ExtArgs> | null
      productElements: Prisma.$ProductElementPayload<ExtArgs>[]
      productStock: Prisma.$ProductStockPayload<ExtArgs> | null
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      manufacturingOrders: Prisma.$ManufacturingOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serialNumber: string
      category: string
      label: string
      unitsPerAssembly: number
      unitsPerBox: number
      boxRawMaterialId: string | null
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boxRawMaterial<T extends Product$boxRawMaterialArgs<ExtArgs> = {}>(args?: Subset<T, Product$boxRawMaterialArgs<ExtArgs>>): Prisma__RawMaterialClient<$Result.GetResult<Prisma.$RawMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productElements<T extends Product$productElementsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productElementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productStock<T extends Product$productStockArgs<ExtArgs> = {}>(args?: Subset<T, Product$productStockArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manufacturingOrders<T extends Product$manufacturingOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Product$manufacturingOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly serialNumber: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly label: FieldRef<"Product", 'String'>
    readonly unitsPerAssembly: FieldRef<"Product", 'Int'>
    readonly unitsPerBox: FieldRef<"Product", 'Int'>
    readonly boxRawMaterialId: FieldRef<"Product", 'String'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.boxRawMaterial
   */
  export type Product$boxRawMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterial
     */
    select?: RawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterial
     */
    omit?: RawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialInclude<ExtArgs> | null
    where?: RawMaterialWhereInput
  }

  /**
   * Product.productElements
   */
  export type Product$productElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    where?: ProductElementWhereInput
    orderBy?: ProductElementOrderByWithRelationInput | ProductElementOrderByWithRelationInput[]
    cursor?: ProductElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductElementScalarFieldEnum | ProductElementScalarFieldEnum[]
  }

  /**
   * Product.productStock
   */
  export type Product$productStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    where?: ProductStockWhereInput
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.manufacturingOrders
   */
  export type Product$manufacturingOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    where?: ManufacturingOrderWhereInput
    orderBy?: ManufacturingOrderOrderByWithRelationInput | ManufacturingOrderOrderByWithRelationInput[]
    cursor?: ManufacturingOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManufacturingOrderScalarFieldEnum | ManufacturingOrderScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductElement
   */

  export type AggregateProductElement = {
    _count: ProductElementCountAggregateOutputType | null
    _avg: ProductElementAvgAggregateOutputType | null
    _sum: ProductElementSumAggregateOutputType | null
    _min: ProductElementMinAggregateOutputType | null
    _max: ProductElementMaxAggregateOutputType | null
  }

  export type ProductElementAvgAggregateOutputType = {
    quantityNeeded: number | null
  }

  export type ProductElementSumAggregateOutputType = {
    quantityNeeded: number | null
  }

  export type ProductElementMinAggregateOutputType = {
    id: string | null
    productId: string | null
    elementId: string | null
    quantityNeeded: number | null
    createdAt: Date | null
  }

  export type ProductElementMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    elementId: string | null
    quantityNeeded: number | null
    createdAt: Date | null
  }

  export type ProductElementCountAggregateOutputType = {
    id: number
    productId: number
    elementId: number
    quantityNeeded: number
    createdAt: number
    _all: number
  }


  export type ProductElementAvgAggregateInputType = {
    quantityNeeded?: true
  }

  export type ProductElementSumAggregateInputType = {
    quantityNeeded?: true
  }

  export type ProductElementMinAggregateInputType = {
    id?: true
    productId?: true
    elementId?: true
    quantityNeeded?: true
    createdAt?: true
  }

  export type ProductElementMaxAggregateInputType = {
    id?: true
    productId?: true
    elementId?: true
    quantityNeeded?: true
    createdAt?: true
  }

  export type ProductElementCountAggregateInputType = {
    id?: true
    productId?: true
    elementId?: true
    quantityNeeded?: true
    createdAt?: true
    _all?: true
  }

  export type ProductElementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductElement to aggregate.
     */
    where?: ProductElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductElements to fetch.
     */
    orderBy?: ProductElementOrderByWithRelationInput | ProductElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductElements
    **/
    _count?: true | ProductElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductElementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductElementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductElementMaxAggregateInputType
  }

  export type GetProductElementAggregateType<T extends ProductElementAggregateArgs> = {
        [P in keyof T & keyof AggregateProductElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductElement[P]>
      : GetScalarType<T[P], AggregateProductElement[P]>
  }




  export type ProductElementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductElementWhereInput
    orderBy?: ProductElementOrderByWithAggregationInput | ProductElementOrderByWithAggregationInput[]
    by: ProductElementScalarFieldEnum[] | ProductElementScalarFieldEnum
    having?: ProductElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductElementCountAggregateInputType | true
    _avg?: ProductElementAvgAggregateInputType
    _sum?: ProductElementSumAggregateInputType
    _min?: ProductElementMinAggregateInputType
    _max?: ProductElementMaxAggregateInputType
  }

  export type ProductElementGroupByOutputType = {
    id: string
    productId: string
    elementId: string
    quantityNeeded: number
    createdAt: Date
    _count: ProductElementCountAggregateOutputType | null
    _avg: ProductElementAvgAggregateOutputType | null
    _sum: ProductElementSumAggregateOutputType | null
    _min: ProductElementMinAggregateOutputType | null
    _max: ProductElementMaxAggregateOutputType | null
  }

  type GetProductElementGroupByPayload<T extends ProductElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductElementGroupByOutputType[P]>
            : GetScalarType<T[P], ProductElementGroupByOutputType[P]>
        }
      >
    >


  export type ProductElementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    elementId?: boolean
    quantityNeeded?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productElement"]>

  export type ProductElementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    elementId?: boolean
    quantityNeeded?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productElement"]>

  export type ProductElementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    elementId?: boolean
    quantityNeeded?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productElement"]>

  export type ProductElementSelectScalar = {
    id?: boolean
    productId?: boolean
    elementId?: boolean
    quantityNeeded?: boolean
    createdAt?: boolean
  }

  export type ProductElementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "elementId" | "quantityNeeded" | "createdAt", ExtArgs["result"]["productElement"]>
  export type ProductElementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }
  export type ProductElementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }
  export type ProductElementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }

  export type $ProductElementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductElement"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      element: Prisma.$ElementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      elementId: string
      quantityNeeded: number
      createdAt: Date
    }, ExtArgs["result"]["productElement"]>
    composites: {}
  }

  type ProductElementGetPayload<S extends boolean | null | undefined | ProductElementDefaultArgs> = $Result.GetResult<Prisma.$ProductElementPayload, S>

  type ProductElementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductElementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductElementCountAggregateInputType | true
    }

  export interface ProductElementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductElement'], meta: { name: 'ProductElement' } }
    /**
     * Find zero or one ProductElement that matches the filter.
     * @param {ProductElementFindUniqueArgs} args - Arguments to find a ProductElement
     * @example
     * // Get one ProductElement
     * const productElement = await prisma.productElement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductElementFindUniqueArgs>(args: SelectSubset<T, ProductElementFindUniqueArgs<ExtArgs>>): Prisma__ProductElementClient<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductElement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductElementFindUniqueOrThrowArgs} args - Arguments to find a ProductElement
     * @example
     * // Get one ProductElement
     * const productElement = await prisma.productElement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductElementFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductElementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductElementClient<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductElement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductElementFindFirstArgs} args - Arguments to find a ProductElement
     * @example
     * // Get one ProductElement
     * const productElement = await prisma.productElement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductElementFindFirstArgs>(args?: SelectSubset<T, ProductElementFindFirstArgs<ExtArgs>>): Prisma__ProductElementClient<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductElement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductElementFindFirstOrThrowArgs} args - Arguments to find a ProductElement
     * @example
     * // Get one ProductElement
     * const productElement = await prisma.productElement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductElementFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductElementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductElementClient<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductElements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductElementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductElements
     * const productElements = await prisma.productElement.findMany()
     * 
     * // Get first 10 ProductElements
     * const productElements = await prisma.productElement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productElementWithIdOnly = await prisma.productElement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductElementFindManyArgs>(args?: SelectSubset<T, ProductElementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductElement.
     * @param {ProductElementCreateArgs} args - Arguments to create a ProductElement.
     * @example
     * // Create one ProductElement
     * const ProductElement = await prisma.productElement.create({
     *   data: {
     *     // ... data to create a ProductElement
     *   }
     * })
     * 
     */
    create<T extends ProductElementCreateArgs>(args: SelectSubset<T, ProductElementCreateArgs<ExtArgs>>): Prisma__ProductElementClient<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductElements.
     * @param {ProductElementCreateManyArgs} args - Arguments to create many ProductElements.
     * @example
     * // Create many ProductElements
     * const productElement = await prisma.productElement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductElementCreateManyArgs>(args?: SelectSubset<T, ProductElementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductElements and returns the data saved in the database.
     * @param {ProductElementCreateManyAndReturnArgs} args - Arguments to create many ProductElements.
     * @example
     * // Create many ProductElements
     * const productElement = await prisma.productElement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductElements and only return the `id`
     * const productElementWithIdOnly = await prisma.productElement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductElementCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductElementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductElement.
     * @param {ProductElementDeleteArgs} args - Arguments to delete one ProductElement.
     * @example
     * // Delete one ProductElement
     * const ProductElement = await prisma.productElement.delete({
     *   where: {
     *     // ... filter to delete one ProductElement
     *   }
     * })
     * 
     */
    delete<T extends ProductElementDeleteArgs>(args: SelectSubset<T, ProductElementDeleteArgs<ExtArgs>>): Prisma__ProductElementClient<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductElement.
     * @param {ProductElementUpdateArgs} args - Arguments to update one ProductElement.
     * @example
     * // Update one ProductElement
     * const productElement = await prisma.productElement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductElementUpdateArgs>(args: SelectSubset<T, ProductElementUpdateArgs<ExtArgs>>): Prisma__ProductElementClient<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductElements.
     * @param {ProductElementDeleteManyArgs} args - Arguments to filter ProductElements to delete.
     * @example
     * // Delete a few ProductElements
     * const { count } = await prisma.productElement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductElementDeleteManyArgs>(args?: SelectSubset<T, ProductElementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductElements
     * const productElement = await prisma.productElement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductElementUpdateManyArgs>(args: SelectSubset<T, ProductElementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductElements and returns the data updated in the database.
     * @param {ProductElementUpdateManyAndReturnArgs} args - Arguments to update many ProductElements.
     * @example
     * // Update many ProductElements
     * const productElement = await prisma.productElement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductElements and only return the `id`
     * const productElementWithIdOnly = await prisma.productElement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductElementUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductElementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductElement.
     * @param {ProductElementUpsertArgs} args - Arguments to update or create a ProductElement.
     * @example
     * // Update or create a ProductElement
     * const productElement = await prisma.productElement.upsert({
     *   create: {
     *     // ... data to create a ProductElement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductElement we want to update
     *   }
     * })
     */
    upsert<T extends ProductElementUpsertArgs>(args: SelectSubset<T, ProductElementUpsertArgs<ExtArgs>>): Prisma__ProductElementClient<$Result.GetResult<Prisma.$ProductElementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductElementCountArgs} args - Arguments to filter ProductElements to count.
     * @example
     * // Count the number of ProductElements
     * const count = await prisma.productElement.count({
     *   where: {
     *     // ... the filter for the ProductElements we want to count
     *   }
     * })
    **/
    count<T extends ProductElementCountArgs>(
      args?: Subset<T, ProductElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductElementAggregateArgs>(args: Subset<T, ProductElementAggregateArgs>): Prisma.PrismaPromise<GetProductElementAggregateType<T>>

    /**
     * Group by ProductElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductElementGroupByArgs['orderBy'] }
        : { orderBy?: ProductElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductElement model
   */
  readonly fields: ProductElementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductElement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductElementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    element<T extends ElementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ElementDefaultArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductElement model
   */
  interface ProductElementFieldRefs {
    readonly id: FieldRef<"ProductElement", 'String'>
    readonly productId: FieldRef<"ProductElement", 'String'>
    readonly elementId: FieldRef<"ProductElement", 'String'>
    readonly quantityNeeded: FieldRef<"ProductElement", 'Int'>
    readonly createdAt: FieldRef<"ProductElement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductElement findUnique
   */
  export type ProductElementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    /**
     * Filter, which ProductElement to fetch.
     */
    where: ProductElementWhereUniqueInput
  }

  /**
   * ProductElement findUniqueOrThrow
   */
  export type ProductElementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    /**
     * Filter, which ProductElement to fetch.
     */
    where: ProductElementWhereUniqueInput
  }

  /**
   * ProductElement findFirst
   */
  export type ProductElementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    /**
     * Filter, which ProductElement to fetch.
     */
    where?: ProductElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductElements to fetch.
     */
    orderBy?: ProductElementOrderByWithRelationInput | ProductElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductElements.
     */
    cursor?: ProductElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductElements.
     */
    distinct?: ProductElementScalarFieldEnum | ProductElementScalarFieldEnum[]
  }

  /**
   * ProductElement findFirstOrThrow
   */
  export type ProductElementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    /**
     * Filter, which ProductElement to fetch.
     */
    where?: ProductElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductElements to fetch.
     */
    orderBy?: ProductElementOrderByWithRelationInput | ProductElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductElements.
     */
    cursor?: ProductElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductElements.
     */
    distinct?: ProductElementScalarFieldEnum | ProductElementScalarFieldEnum[]
  }

  /**
   * ProductElement findMany
   */
  export type ProductElementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    /**
     * Filter, which ProductElements to fetch.
     */
    where?: ProductElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductElements to fetch.
     */
    orderBy?: ProductElementOrderByWithRelationInput | ProductElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductElements.
     */
    cursor?: ProductElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductElements.
     */
    skip?: number
    distinct?: ProductElementScalarFieldEnum | ProductElementScalarFieldEnum[]
  }

  /**
   * ProductElement create
   */
  export type ProductElementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductElement.
     */
    data: XOR<ProductElementCreateInput, ProductElementUncheckedCreateInput>
  }

  /**
   * ProductElement createMany
   */
  export type ProductElementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductElements.
     */
    data: ProductElementCreateManyInput | ProductElementCreateManyInput[]
  }

  /**
   * ProductElement createManyAndReturn
   */
  export type ProductElementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * The data used to create many ProductElements.
     */
    data: ProductElementCreateManyInput | ProductElementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductElement update
   */
  export type ProductElementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductElement.
     */
    data: XOR<ProductElementUpdateInput, ProductElementUncheckedUpdateInput>
    /**
     * Choose, which ProductElement to update.
     */
    where: ProductElementWhereUniqueInput
  }

  /**
   * ProductElement updateMany
   */
  export type ProductElementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductElements.
     */
    data: XOR<ProductElementUpdateManyMutationInput, ProductElementUncheckedUpdateManyInput>
    /**
     * Filter which ProductElements to update
     */
    where?: ProductElementWhereInput
    /**
     * Limit how many ProductElements to update.
     */
    limit?: number
  }

  /**
   * ProductElement updateManyAndReturn
   */
  export type ProductElementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * The data used to update ProductElements.
     */
    data: XOR<ProductElementUpdateManyMutationInput, ProductElementUncheckedUpdateManyInput>
    /**
     * Filter which ProductElements to update
     */
    where?: ProductElementWhereInput
    /**
     * Limit how many ProductElements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductElement upsert
   */
  export type ProductElementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductElement to update in case it exists.
     */
    where: ProductElementWhereUniqueInput
    /**
     * In case the ProductElement found by the `where` argument doesn't exist, create a new ProductElement with this data.
     */
    create: XOR<ProductElementCreateInput, ProductElementUncheckedCreateInput>
    /**
     * In case the ProductElement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductElementUpdateInput, ProductElementUncheckedUpdateInput>
  }

  /**
   * ProductElement delete
   */
  export type ProductElementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
    /**
     * Filter which ProductElement to delete.
     */
    where: ProductElementWhereUniqueInput
  }

  /**
   * ProductElement deleteMany
   */
  export type ProductElementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductElements to delete
     */
    where?: ProductElementWhereInput
    /**
     * Limit how many ProductElements to delete.
     */
    limit?: number
  }

  /**
   * ProductElement without action
   */
  export type ProductElementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductElement
     */
    select?: ProductElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductElement
     */
    omit?: ProductElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductElementInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type InventorySumAggregateOutputType = {
    totalAmount: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    elementId: string | null
    totalAmount: number | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    elementId: string | null
    totalAmount: number | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    elementId: number
    totalAmount: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    totalAmount?: true
  }

  export type InventorySumAggregateInputType = {
    totalAmount?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    elementId?: true
    totalAmount?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    elementId?: true
    totalAmount?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    elementId?: true
    totalAmount?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    elementId: string
    totalAmount: number
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    totalAmount?: boolean
    updatedAt?: boolean
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    totalAmount?: boolean
    updatedAt?: boolean
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    totalAmount?: boolean
    updatedAt?: boolean
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    elementId?: boolean
    totalAmount?: boolean
    updatedAt?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "elementId" | "totalAmount" | "updatedAt", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      element: Prisma.$ElementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      elementId: string
      totalAmount: number
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {InventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    element<T extends ElementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ElementDefaultArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly elementId: FieldRef<"Inventory", 'String'>
    readonly totalAmount: FieldRef<"Inventory", 'Int'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory updateManyAndReturn
   */
  export type InventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductStock
   */

  export type AggregateProductStock = {
    _count: ProductStockCountAggregateOutputType | null
    _avg: ProductStockAvgAggregateOutputType | null
    _sum: ProductStockSumAggregateOutputType | null
    _min: ProductStockMinAggregateOutputType | null
    _max: ProductStockMaxAggregateOutputType | null
  }

  export type ProductStockAvgAggregateOutputType = {
    stockBoxedAmount: number | null
  }

  export type ProductStockSumAggregateOutputType = {
    stockBoxedAmount: number | null
  }

  export type ProductStockMinAggregateOutputType = {
    id: string | null
    productId: string | null
    stockBoxedAmount: number | null
    updatedAt: Date | null
  }

  export type ProductStockMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    stockBoxedAmount: number | null
    updatedAt: Date | null
  }

  export type ProductStockCountAggregateOutputType = {
    id: number
    productId: number
    stockBoxedAmount: number
    updatedAt: number
    _all: number
  }


  export type ProductStockAvgAggregateInputType = {
    stockBoxedAmount?: true
  }

  export type ProductStockSumAggregateInputType = {
    stockBoxedAmount?: true
  }

  export type ProductStockMinAggregateInputType = {
    id?: true
    productId?: true
    stockBoxedAmount?: true
    updatedAt?: true
  }

  export type ProductStockMaxAggregateInputType = {
    id?: true
    productId?: true
    stockBoxedAmount?: true
    updatedAt?: true
  }

  export type ProductStockCountAggregateInputType = {
    id?: true
    productId?: true
    stockBoxedAmount?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStock to aggregate.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductStocks
    **/
    _count?: true | ProductStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductStockMaxAggregateInputType
  }

  export type GetProductStockAggregateType<T extends ProductStockAggregateArgs> = {
        [P in keyof T & keyof AggregateProductStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductStock[P]>
      : GetScalarType<T[P], AggregateProductStock[P]>
  }




  export type ProductStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockWhereInput
    orderBy?: ProductStockOrderByWithAggregationInput | ProductStockOrderByWithAggregationInput[]
    by: ProductStockScalarFieldEnum[] | ProductStockScalarFieldEnum
    having?: ProductStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductStockCountAggregateInputType | true
    _avg?: ProductStockAvgAggregateInputType
    _sum?: ProductStockSumAggregateInputType
    _min?: ProductStockMinAggregateInputType
    _max?: ProductStockMaxAggregateInputType
  }

  export type ProductStockGroupByOutputType = {
    id: string
    productId: string
    stockBoxedAmount: number
    updatedAt: Date
    _count: ProductStockCountAggregateOutputType | null
    _avg: ProductStockAvgAggregateOutputType | null
    _sum: ProductStockSumAggregateOutputType | null
    _min: ProductStockMinAggregateOutputType | null
    _max: ProductStockMaxAggregateOutputType | null
  }

  type GetProductStockGroupByPayload<T extends ProductStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductStockGroupByOutputType[P]>
            : GetScalarType<T[P], ProductStockGroupByOutputType[P]>
        }
      >
    >


  export type ProductStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    stockBoxedAmount?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStock"]>

  export type ProductStockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    stockBoxedAmount?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStock"]>

  export type ProductStockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    stockBoxedAmount?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStock"]>

  export type ProductStockSelectScalar = {
    id?: boolean
    productId?: boolean
    stockBoxedAmount?: boolean
    updatedAt?: boolean
  }

  export type ProductStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "stockBoxedAmount" | "updatedAt", ExtArgs["result"]["productStock"]>
  export type ProductStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductStockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductStockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductStock"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      stockBoxedAmount: number
      updatedAt: Date
    }, ExtArgs["result"]["productStock"]>
    composites: {}
  }

  type ProductStockGetPayload<S extends boolean | null | undefined | ProductStockDefaultArgs> = $Result.GetResult<Prisma.$ProductStockPayload, S>

  type ProductStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductStockCountAggregateInputType | true
    }

  export interface ProductStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductStock'], meta: { name: 'ProductStock' } }
    /**
     * Find zero or one ProductStock that matches the filter.
     * @param {ProductStockFindUniqueArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductStockFindUniqueArgs>(args: SelectSubset<T, ProductStockFindUniqueArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductStockFindUniqueOrThrowArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductStockFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindFirstArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductStockFindFirstArgs>(args?: SelectSubset<T, ProductStockFindFirstArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindFirstOrThrowArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductStockFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductStocks
     * const productStocks = await prisma.productStock.findMany()
     * 
     * // Get first 10 ProductStocks
     * const productStocks = await prisma.productStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productStockWithIdOnly = await prisma.productStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductStockFindManyArgs>(args?: SelectSubset<T, ProductStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductStock.
     * @param {ProductStockCreateArgs} args - Arguments to create a ProductStock.
     * @example
     * // Create one ProductStock
     * const ProductStock = await prisma.productStock.create({
     *   data: {
     *     // ... data to create a ProductStock
     *   }
     * })
     * 
     */
    create<T extends ProductStockCreateArgs>(args: SelectSubset<T, ProductStockCreateArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductStocks.
     * @param {ProductStockCreateManyArgs} args - Arguments to create many ProductStocks.
     * @example
     * // Create many ProductStocks
     * const productStock = await prisma.productStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductStockCreateManyArgs>(args?: SelectSubset<T, ProductStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductStocks and returns the data saved in the database.
     * @param {ProductStockCreateManyAndReturnArgs} args - Arguments to create many ProductStocks.
     * @example
     * // Create many ProductStocks
     * const productStock = await prisma.productStock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductStocks and only return the `id`
     * const productStockWithIdOnly = await prisma.productStock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductStockCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductStockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductStock.
     * @param {ProductStockDeleteArgs} args - Arguments to delete one ProductStock.
     * @example
     * // Delete one ProductStock
     * const ProductStock = await prisma.productStock.delete({
     *   where: {
     *     // ... filter to delete one ProductStock
     *   }
     * })
     * 
     */
    delete<T extends ProductStockDeleteArgs>(args: SelectSubset<T, ProductStockDeleteArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductStock.
     * @param {ProductStockUpdateArgs} args - Arguments to update one ProductStock.
     * @example
     * // Update one ProductStock
     * const productStock = await prisma.productStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductStockUpdateArgs>(args: SelectSubset<T, ProductStockUpdateArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductStocks.
     * @param {ProductStockDeleteManyArgs} args - Arguments to filter ProductStocks to delete.
     * @example
     * // Delete a few ProductStocks
     * const { count } = await prisma.productStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductStockDeleteManyArgs>(args?: SelectSubset<T, ProductStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductStocks
     * const productStock = await prisma.productStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductStockUpdateManyArgs>(args: SelectSubset<T, ProductStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStocks and returns the data updated in the database.
     * @param {ProductStockUpdateManyAndReturnArgs} args - Arguments to update many ProductStocks.
     * @example
     * // Update many ProductStocks
     * const productStock = await prisma.productStock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductStocks and only return the `id`
     * const productStockWithIdOnly = await prisma.productStock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductStockUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductStockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductStock.
     * @param {ProductStockUpsertArgs} args - Arguments to update or create a ProductStock.
     * @example
     * // Update or create a ProductStock
     * const productStock = await prisma.productStock.upsert({
     *   create: {
     *     // ... data to create a ProductStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductStock we want to update
     *   }
     * })
     */
    upsert<T extends ProductStockUpsertArgs>(args: SelectSubset<T, ProductStockUpsertArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockCountArgs} args - Arguments to filter ProductStocks to count.
     * @example
     * // Count the number of ProductStocks
     * const count = await prisma.productStock.count({
     *   where: {
     *     // ... the filter for the ProductStocks we want to count
     *   }
     * })
    **/
    count<T extends ProductStockCountArgs>(
      args?: Subset<T, ProductStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductStockAggregateArgs>(args: Subset<T, ProductStockAggregateArgs>): Prisma.PrismaPromise<GetProductStockAggregateType<T>>

    /**
     * Group by ProductStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductStockGroupByArgs['orderBy'] }
        : { orderBy?: ProductStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductStock model
   */
  readonly fields: ProductStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductStock model
   */
  interface ProductStockFieldRefs {
    readonly id: FieldRef<"ProductStock", 'String'>
    readonly productId: FieldRef<"ProductStock", 'String'>
    readonly stockBoxedAmount: FieldRef<"ProductStock", 'Int'>
    readonly updatedAt: FieldRef<"ProductStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductStock findUnique
   */
  export type ProductStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock findUniqueOrThrow
   */
  export type ProductStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock findFirst
   */
  export type ProductStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStocks.
     */
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock findFirstOrThrow
   */
  export type ProductStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStocks.
     */
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock findMany
   */
  export type ProductStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStocks to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock create
   */
  export type ProductStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductStock.
     */
    data: XOR<ProductStockCreateInput, ProductStockUncheckedCreateInput>
  }

  /**
   * ProductStock createMany
   */
  export type ProductStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductStocks.
     */
    data: ProductStockCreateManyInput | ProductStockCreateManyInput[]
  }

  /**
   * ProductStock createManyAndReturn
   */
  export type ProductStockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * The data used to create many ProductStocks.
     */
    data: ProductStockCreateManyInput | ProductStockCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductStock update
   */
  export type ProductStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductStock.
     */
    data: XOR<ProductStockUpdateInput, ProductStockUncheckedUpdateInput>
    /**
     * Choose, which ProductStock to update.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock updateMany
   */
  export type ProductStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductStocks.
     */
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyInput>
    /**
     * Filter which ProductStocks to update
     */
    where?: ProductStockWhereInput
    /**
     * Limit how many ProductStocks to update.
     */
    limit?: number
  }

  /**
   * ProductStock updateManyAndReturn
   */
  export type ProductStockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * The data used to update ProductStocks.
     */
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyInput>
    /**
     * Filter which ProductStocks to update
     */
    where?: ProductStockWhereInput
    /**
     * Limit how many ProductStocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductStock upsert
   */
  export type ProductStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductStock to update in case it exists.
     */
    where: ProductStockWhereUniqueInput
    /**
     * In case the ProductStock found by the `where` argument doesn't exist, create a new ProductStock with this data.
     */
    create: XOR<ProductStockCreateInput, ProductStockUncheckedCreateInput>
    /**
     * In case the ProductStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductStockUpdateInput, ProductStockUncheckedUpdateInput>
  }

  /**
   * ProductStock delete
   */
  export type ProductStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter which ProductStock to delete.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock deleteMany
   */
  export type ProductStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStocks to delete
     */
    where?: ProductStockWhereInput
    /**
     * Limit how many ProductStocks to delete.
     */
    limit?: number
  }

  /**
   * ProductStock without action
   */
  export type ProductStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStock
     */
    omit?: ProductStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
  }


  /**
   * Model InventoryTransaction
   */

  export type AggregateInventoryTransaction = {
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  export type InventoryTransactionAvgAggregateOutputType = {
    changeAmount: number | null
  }

  export type InventoryTransactionSumAggregateOutputType = {
    changeAmount: number | null
  }

  export type InventoryTransactionMinAggregateOutputType = {
    id: string | null
    elementId: string | null
    changeAmount: number | null
    reason: string | null
    createdAt: Date | null
  }

  export type InventoryTransactionMaxAggregateOutputType = {
    id: string | null
    elementId: string | null
    changeAmount: number | null
    reason: string | null
    createdAt: Date | null
  }

  export type InventoryTransactionCountAggregateOutputType = {
    id: number
    elementId: number
    changeAmount: number
    reason: number
    createdAt: number
    _all: number
  }


  export type InventoryTransactionAvgAggregateInputType = {
    changeAmount?: true
  }

  export type InventoryTransactionSumAggregateInputType = {
    changeAmount?: true
  }

  export type InventoryTransactionMinAggregateInputType = {
    id?: true
    elementId?: true
    changeAmount?: true
    reason?: true
    createdAt?: true
  }

  export type InventoryTransactionMaxAggregateInputType = {
    id?: true
    elementId?: true
    changeAmount?: true
    reason?: true
    createdAt?: true
  }

  export type InventoryTransactionCountAggregateInputType = {
    id?: true
    elementId?: true
    changeAmount?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransaction to aggregate.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryTransactions
    **/
    _count?: true | InventoryTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type GetInventoryTransactionAggregateType<T extends InventoryTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryTransaction[P]>
      : GetScalarType<T[P], AggregateInventoryTransaction[P]>
  }




  export type InventoryTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithAggregationInput | InventoryTransactionOrderByWithAggregationInput[]
    by: InventoryTransactionScalarFieldEnum[] | InventoryTransactionScalarFieldEnum
    having?: InventoryTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryTransactionCountAggregateInputType | true
    _avg?: InventoryTransactionAvgAggregateInputType
    _sum?: InventoryTransactionSumAggregateInputType
    _min?: InventoryTransactionMinAggregateInputType
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type InventoryTransactionGroupByOutputType = {
    id: string
    elementId: string | null
    changeAmount: number
    reason: string
    createdAt: Date
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  type GetInventoryTransactionGroupByPayload<T extends InventoryTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
        }
      >
    >


  export type InventoryTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    changeAmount?: boolean
    reason?: boolean
    createdAt?: boolean
    element?: boolean | InventoryTransaction$elementArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    changeAmount?: boolean
    reason?: boolean
    createdAt?: boolean
    element?: boolean | InventoryTransaction$elementArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    changeAmount?: boolean
    reason?: boolean
    createdAt?: boolean
    element?: boolean | InventoryTransaction$elementArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectScalar = {
    id?: boolean
    elementId?: boolean
    changeAmount?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type InventoryTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "elementId" | "changeAmount" | "reason" | "createdAt", ExtArgs["result"]["inventoryTransaction"]>
  export type InventoryTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | InventoryTransaction$elementArgs<ExtArgs>
  }
  export type InventoryTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | InventoryTransaction$elementArgs<ExtArgs>
  }
  export type InventoryTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | InventoryTransaction$elementArgs<ExtArgs>
  }

  export type $InventoryTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryTransaction"
    objects: {
      element: Prisma.$ElementPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      elementId: string | null
      changeAmount: number
      reason: string
      createdAt: Date
    }, ExtArgs["result"]["inventoryTransaction"]>
    composites: {}
  }

  type InventoryTransactionGetPayload<S extends boolean | null | undefined | InventoryTransactionDefaultArgs> = $Result.GetResult<Prisma.$InventoryTransactionPayload, S>

  type InventoryTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryTransactionCountAggregateInputType | true
    }

  export interface InventoryTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryTransaction'], meta: { name: 'InventoryTransaction' } }
    /**
     * Find zero or one InventoryTransaction that matches the filter.
     * @param {InventoryTransactionFindUniqueArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryTransactionFindUniqueArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryTransactionFindUniqueOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryTransactionFindFirstArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
     * 
     * // Get first 10 InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryTransactionFindManyArgs>(args?: SelectSubset<T, InventoryTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryTransaction.
     * @param {InventoryTransactionCreateArgs} args - Arguments to create a InventoryTransaction.
     * @example
     * // Create one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.create({
     *   data: {
     *     // ... data to create a InventoryTransaction
     *   }
     * })
     * 
     */
    create<T extends InventoryTransactionCreateArgs>(args: SelectSubset<T, InventoryTransactionCreateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryTransactions.
     * @param {InventoryTransactionCreateManyArgs} args - Arguments to create many InventoryTransactions.
     * @example
     * // Create many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryTransactionCreateManyArgs>(args?: SelectSubset<T, InventoryTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryTransactions and returns the data saved in the database.
     * @param {InventoryTransactionCreateManyAndReturnArgs} args - Arguments to create many InventoryTransactions.
     * @example
     * // Create many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryTransactions and only return the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryTransaction.
     * @param {InventoryTransactionDeleteArgs} args - Arguments to delete one InventoryTransaction.
     * @example
     * // Delete one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.delete({
     *   where: {
     *     // ... filter to delete one InventoryTransaction
     *   }
     * })
     * 
     */
    delete<T extends InventoryTransactionDeleteArgs>(args: SelectSubset<T, InventoryTransactionDeleteArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryTransaction.
     * @param {InventoryTransactionUpdateArgs} args - Arguments to update one InventoryTransaction.
     * @example
     * // Update one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryTransactionUpdateArgs>(args: SelectSubset<T, InventoryTransactionUpdateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryTransactions.
     * @param {InventoryTransactionDeleteManyArgs} args - Arguments to filter InventoryTransactions to delete.
     * @example
     * // Delete a few InventoryTransactions
     * const { count } = await prisma.inventoryTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryTransactionDeleteManyArgs>(args?: SelectSubset<T, InventoryTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryTransactionUpdateManyArgs>(args: SelectSubset<T, InventoryTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryTransactions and returns the data updated in the database.
     * @param {InventoryTransactionUpdateManyAndReturnArgs} args - Arguments to update many InventoryTransactions.
     * @example
     * // Update many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryTransactions and only return the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryTransaction.
     * @param {InventoryTransactionUpsertArgs} args - Arguments to update or create a InventoryTransaction.
     * @example
     * // Update or create a InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.upsert({
     *   create: {
     *     // ... data to create a InventoryTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryTransaction we want to update
     *   }
     * })
     */
    upsert<T extends InventoryTransactionUpsertArgs>(args: SelectSubset<T, InventoryTransactionUpsertArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionCountArgs} args - Arguments to filter InventoryTransactions to count.
     * @example
     * // Count the number of InventoryTransactions
     * const count = await prisma.inventoryTransaction.count({
     *   where: {
     *     // ... the filter for the InventoryTransactions we want to count
     *   }
     * })
    **/
    count<T extends InventoryTransactionCountArgs>(
      args?: Subset<T, InventoryTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryTransactionAggregateArgs>(args: Subset<T, InventoryTransactionAggregateArgs>): Prisma.PrismaPromise<GetInventoryTransactionAggregateType<T>>

    /**
     * Group by InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryTransactionGroupByArgs['orderBy'] }
        : { orderBy?: InventoryTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryTransaction model
   */
  readonly fields: InventoryTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    element<T extends InventoryTransaction$elementArgs<ExtArgs> = {}>(args?: Subset<T, InventoryTransaction$elementArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryTransaction model
   */
  interface InventoryTransactionFieldRefs {
    readonly id: FieldRef<"InventoryTransaction", 'String'>
    readonly elementId: FieldRef<"InventoryTransaction", 'String'>
    readonly changeAmount: FieldRef<"InventoryTransaction", 'Int'>
    readonly reason: FieldRef<"InventoryTransaction", 'String'>
    readonly createdAt: FieldRef<"InventoryTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryTransaction findUnique
   */
  export type InventoryTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findUniqueOrThrow
   */
  export type InventoryTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findFirst
   */
  export type InventoryTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findFirstOrThrow
   */
  export type InventoryTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findMany
   */
  export type InventoryTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransactions to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction create
   */
  export type InventoryTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryTransaction.
     */
    data: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
  }

  /**
   * InventoryTransaction createMany
   */
  export type InventoryTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryTransactions.
     */
    data: InventoryTransactionCreateManyInput | InventoryTransactionCreateManyInput[]
  }

  /**
   * InventoryTransaction createManyAndReturn
   */
  export type InventoryTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryTransactions.
     */
    data: InventoryTransactionCreateManyInput | InventoryTransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryTransaction update
   */
  export type InventoryTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryTransaction.
     */
    data: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
    /**
     * Choose, which InventoryTransaction to update.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction updateMany
   */
  export type InventoryTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryTransactions.
     */
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryTransactions to update
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to update.
     */
    limit?: number
  }

  /**
   * InventoryTransaction updateManyAndReturn
   */
  export type InventoryTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * The data used to update InventoryTransactions.
     */
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryTransactions to update
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryTransaction upsert
   */
  export type InventoryTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryTransaction to update in case it exists.
     */
    where: InventoryTransactionWhereUniqueInput
    /**
     * In case the InventoryTransaction found by the `where` argument doesn't exist, create a new InventoryTransaction with this data.
     */
    create: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
    /**
     * In case the InventoryTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
  }

  /**
   * InventoryTransaction delete
   */
  export type InventoryTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter which InventoryTransaction to delete.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction deleteMany
   */
  export type InventoryTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransactions to delete
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to delete.
     */
    limit?: number
  }

  /**
   * InventoryTransaction.element
   */
  export type InventoryTransaction$elementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Element
     */
    omit?: ElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInclude<ExtArgs> | null
    where?: ElementWhereInput
  }

  /**
   * InventoryTransaction without action
   */
  export type InventoryTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    orderNumber: number | null
  }

  export type OrderSumAggregateOutputType = {
    orderNumber: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNumber: number | null
    clientName: string | null
    createdAt: Date | null
    shippedAt: Date | null
    status: string | null
    notes: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: number | null
    clientName: string | null
    createdAt: Date | null
    shippedAt: Date | null
    status: string | null
    notes: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    clientName: number
    createdAt: number
    shippedAt: number
    status: number
    notes: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    orderNumber?: true
  }

  export type OrderSumAggregateInputType = {
    orderNumber?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    clientName?: true
    createdAt?: true
    shippedAt?: true
    status?: true
    notes?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    clientName?: true
    createdAt?: true
    shippedAt?: true
    status?: true
    notes?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    clientName?: true
    createdAt?: true
    shippedAt?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNumber: number
    clientName: string
    createdAt: Date
    shippedAt: Date | null
    status: string
    notes: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientName?: boolean
    createdAt?: boolean
    shippedAt?: boolean
    status?: boolean
    notes?: boolean
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    manufacturingOrders?: boolean | Order$manufacturingOrdersArgs<ExtArgs>
    inventoryAllocations?: boolean | Order$inventoryAllocationsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientName?: boolean
    createdAt?: boolean
    shippedAt?: boolean
    status?: boolean
    notes?: boolean
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientName?: boolean
    createdAt?: boolean
    shippedAt?: boolean
    status?: boolean
    notes?: boolean
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    clientName?: boolean
    createdAt?: boolean
    shippedAt?: boolean
    status?: boolean
    notes?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "clientName" | "createdAt" | "shippedAt" | "status" | "notes", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    manufacturingOrders?: boolean | Order$manufacturingOrdersArgs<ExtArgs>
    inventoryAllocations?: boolean | Order$inventoryAllocationsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      manufacturingOrders: Prisma.$ManufacturingOrderPayload<ExtArgs>[]
      inventoryAllocations: Prisma.$InventoryAllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: number
      clientName: string
      createdAt: Date
      shippedAt: Date | null
      status: string
      notes: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manufacturingOrders<T extends Order$manufacturingOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Order$manufacturingOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryAllocations<T extends Order$inventoryAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, Order$inventoryAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'Int'>
    readonly clientName: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly shippedAt: FieldRef<"Order", 'DateTime'>
    readonly status: FieldRef<"Order", 'String'>
    readonly notes: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.manufacturingOrders
   */
  export type Order$manufacturingOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    where?: ManufacturingOrderWhereInput
    orderBy?: ManufacturingOrderOrderByWithRelationInput | ManufacturingOrderOrderByWithRelationInput[]
    cursor?: ManufacturingOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManufacturingOrderScalarFieldEnum | ManufacturingOrderScalarFieldEnum[]
  }

  /**
   * Order.inventoryAllocations
   */
  export type Order$inventoryAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    where?: InventoryAllocationWhereInput
    orderBy?: InventoryAllocationOrderByWithRelationInput | InventoryAllocationOrderByWithRelationInput[]
    cursor?: InventoryAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryAllocationScalarFieldEnum | InventoryAllocationScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    boxesNeeded: number | null
    boxesAssembled: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    boxesNeeded: number | null
    boxesAssembled: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    boxesNeeded: number | null
    boxesAssembled: number | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    boxesNeeded: number | null
    boxesAssembled: number | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    boxesNeeded: number
    boxesAssembled: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    boxesNeeded?: true
    boxesAssembled?: true
  }

  export type OrderItemSumAggregateInputType = {
    boxesNeeded?: true
    boxesAssembled?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    boxesNeeded?: true
    boxesAssembled?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    boxesNeeded?: true
    boxesAssembled?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    boxesNeeded?: true
    boxesAssembled?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    boxesNeeded: number
    boxesAssembled: number
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    boxesNeeded?: boolean
    boxesAssembled?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    boxesNeeded?: boolean
    boxesAssembled?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    boxesNeeded?: boolean
    boxesAssembled?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    boxesNeeded?: boolean
    boxesAssembled?: boolean
    createdAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "boxesNeeded" | "boxesAssembled" | "createdAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      boxesNeeded: number
      boxesAssembled: number
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly boxesNeeded: FieldRef<"OrderItem", 'Int'>
    readonly boxesAssembled: FieldRef<"OrderItem", 'Int'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryAllocation
   */

  export type AggregateInventoryAllocation = {
    _count: InventoryAllocationCountAggregateOutputType | null
    _avg: InventoryAllocationAvgAggregateOutputType | null
    _sum: InventoryAllocationSumAggregateOutputType | null
    _min: InventoryAllocationMinAggregateOutputType | null
    _max: InventoryAllocationMaxAggregateOutputType | null
  }

  export type InventoryAllocationAvgAggregateOutputType = {
    amountAllocated: number | null
  }

  export type InventoryAllocationSumAggregateOutputType = {
    amountAllocated: number | null
  }

  export type InventoryAllocationMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    elementId: string | null
    amountAllocated: number | null
    createdAt: Date | null
  }

  export type InventoryAllocationMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    elementId: string | null
    amountAllocated: number | null
    createdAt: Date | null
  }

  export type InventoryAllocationCountAggregateOutputType = {
    id: number
    orderId: number
    elementId: number
    amountAllocated: number
    createdAt: number
    _all: number
  }


  export type InventoryAllocationAvgAggregateInputType = {
    amountAllocated?: true
  }

  export type InventoryAllocationSumAggregateInputType = {
    amountAllocated?: true
  }

  export type InventoryAllocationMinAggregateInputType = {
    id?: true
    orderId?: true
    elementId?: true
    amountAllocated?: true
    createdAt?: true
  }

  export type InventoryAllocationMaxAggregateInputType = {
    id?: true
    orderId?: true
    elementId?: true
    amountAllocated?: true
    createdAt?: true
  }

  export type InventoryAllocationCountAggregateInputType = {
    id?: true
    orderId?: true
    elementId?: true
    amountAllocated?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAllocation to aggregate.
     */
    where?: InventoryAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAllocations to fetch.
     */
    orderBy?: InventoryAllocationOrderByWithRelationInput | InventoryAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryAllocations
    **/
    _count?: true | InventoryAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryAllocationMaxAggregateInputType
  }

  export type GetInventoryAllocationAggregateType<T extends InventoryAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryAllocation[P]>
      : GetScalarType<T[P], AggregateInventoryAllocation[P]>
  }




  export type InventoryAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAllocationWhereInput
    orderBy?: InventoryAllocationOrderByWithAggregationInput | InventoryAllocationOrderByWithAggregationInput[]
    by: InventoryAllocationScalarFieldEnum[] | InventoryAllocationScalarFieldEnum
    having?: InventoryAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryAllocationCountAggregateInputType | true
    _avg?: InventoryAllocationAvgAggregateInputType
    _sum?: InventoryAllocationSumAggregateInputType
    _min?: InventoryAllocationMinAggregateInputType
    _max?: InventoryAllocationMaxAggregateInputType
  }

  export type InventoryAllocationGroupByOutputType = {
    id: string
    orderId: string
    elementId: string
    amountAllocated: number
    createdAt: Date
    _count: InventoryAllocationCountAggregateOutputType | null
    _avg: InventoryAllocationAvgAggregateOutputType | null
    _sum: InventoryAllocationSumAggregateOutputType | null
    _min: InventoryAllocationMinAggregateOutputType | null
    _max: InventoryAllocationMaxAggregateOutputType | null
  }

  type GetInventoryAllocationGroupByPayload<T extends InventoryAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryAllocationGroupByOutputType[P]>
        }
      >
    >


  export type InventoryAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    elementId?: boolean
    amountAllocated?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAllocation"]>

  export type InventoryAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    elementId?: boolean
    amountAllocated?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAllocation"]>

  export type InventoryAllocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    elementId?: boolean
    amountAllocated?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAllocation"]>

  export type InventoryAllocationSelectScalar = {
    id?: boolean
    orderId?: boolean
    elementId?: boolean
    amountAllocated?: boolean
    createdAt?: boolean
  }

  export type InventoryAllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "elementId" | "amountAllocated" | "createdAt", ExtArgs["result"]["inventoryAllocation"]>
  export type InventoryAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }
  export type InventoryAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }
  export type InventoryAllocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }

  export type $InventoryAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryAllocation"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      element: Prisma.$ElementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      elementId: string
      amountAllocated: number
      createdAt: Date
    }, ExtArgs["result"]["inventoryAllocation"]>
    composites: {}
  }

  type InventoryAllocationGetPayload<S extends boolean | null | undefined | InventoryAllocationDefaultArgs> = $Result.GetResult<Prisma.$InventoryAllocationPayload, S>

  type InventoryAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryAllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryAllocationCountAggregateInputType | true
    }

  export interface InventoryAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryAllocation'], meta: { name: 'InventoryAllocation' } }
    /**
     * Find zero or one InventoryAllocation that matches the filter.
     * @param {InventoryAllocationFindUniqueArgs} args - Arguments to find a InventoryAllocation
     * @example
     * // Get one InventoryAllocation
     * const inventoryAllocation = await prisma.inventoryAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryAllocationFindUniqueArgs>(args: SelectSubset<T, InventoryAllocationFindUniqueArgs<ExtArgs>>): Prisma__InventoryAllocationClient<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryAllocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryAllocationFindUniqueOrThrowArgs} args - Arguments to find a InventoryAllocation
     * @example
     * // Get one InventoryAllocation
     * const inventoryAllocation = await prisma.inventoryAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryAllocationClient<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAllocationFindFirstArgs} args - Arguments to find a InventoryAllocation
     * @example
     * // Get one InventoryAllocation
     * const inventoryAllocation = await prisma.inventoryAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryAllocationFindFirstArgs>(args?: SelectSubset<T, InventoryAllocationFindFirstArgs<ExtArgs>>): Prisma__InventoryAllocationClient<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAllocationFindFirstOrThrowArgs} args - Arguments to find a InventoryAllocation
     * @example
     * // Get one InventoryAllocation
     * const inventoryAllocation = await prisma.inventoryAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryAllocationClient<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryAllocations
     * const inventoryAllocations = await prisma.inventoryAllocation.findMany()
     * 
     * // Get first 10 InventoryAllocations
     * const inventoryAllocations = await prisma.inventoryAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryAllocationWithIdOnly = await prisma.inventoryAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryAllocationFindManyArgs>(args?: SelectSubset<T, InventoryAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryAllocation.
     * @param {InventoryAllocationCreateArgs} args - Arguments to create a InventoryAllocation.
     * @example
     * // Create one InventoryAllocation
     * const InventoryAllocation = await prisma.inventoryAllocation.create({
     *   data: {
     *     // ... data to create a InventoryAllocation
     *   }
     * })
     * 
     */
    create<T extends InventoryAllocationCreateArgs>(args: SelectSubset<T, InventoryAllocationCreateArgs<ExtArgs>>): Prisma__InventoryAllocationClient<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryAllocations.
     * @param {InventoryAllocationCreateManyArgs} args - Arguments to create many InventoryAllocations.
     * @example
     * // Create many InventoryAllocations
     * const inventoryAllocation = await prisma.inventoryAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryAllocationCreateManyArgs>(args?: SelectSubset<T, InventoryAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryAllocations and returns the data saved in the database.
     * @param {InventoryAllocationCreateManyAndReturnArgs} args - Arguments to create many InventoryAllocations.
     * @example
     * // Create many InventoryAllocations
     * const inventoryAllocation = await prisma.inventoryAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryAllocations and only return the `id`
     * const inventoryAllocationWithIdOnly = await prisma.inventoryAllocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryAllocation.
     * @param {InventoryAllocationDeleteArgs} args - Arguments to delete one InventoryAllocation.
     * @example
     * // Delete one InventoryAllocation
     * const InventoryAllocation = await prisma.inventoryAllocation.delete({
     *   where: {
     *     // ... filter to delete one InventoryAllocation
     *   }
     * })
     * 
     */
    delete<T extends InventoryAllocationDeleteArgs>(args: SelectSubset<T, InventoryAllocationDeleteArgs<ExtArgs>>): Prisma__InventoryAllocationClient<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryAllocation.
     * @param {InventoryAllocationUpdateArgs} args - Arguments to update one InventoryAllocation.
     * @example
     * // Update one InventoryAllocation
     * const inventoryAllocation = await prisma.inventoryAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryAllocationUpdateArgs>(args: SelectSubset<T, InventoryAllocationUpdateArgs<ExtArgs>>): Prisma__InventoryAllocationClient<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryAllocations.
     * @param {InventoryAllocationDeleteManyArgs} args - Arguments to filter InventoryAllocations to delete.
     * @example
     * // Delete a few InventoryAllocations
     * const { count } = await prisma.inventoryAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryAllocationDeleteManyArgs>(args?: SelectSubset<T, InventoryAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryAllocations
     * const inventoryAllocation = await prisma.inventoryAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryAllocationUpdateManyArgs>(args: SelectSubset<T, InventoryAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryAllocations and returns the data updated in the database.
     * @param {InventoryAllocationUpdateManyAndReturnArgs} args - Arguments to update many InventoryAllocations.
     * @example
     * // Update many InventoryAllocations
     * const inventoryAllocation = await prisma.inventoryAllocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryAllocations and only return the `id`
     * const inventoryAllocationWithIdOnly = await prisma.inventoryAllocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryAllocationUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryAllocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryAllocation.
     * @param {InventoryAllocationUpsertArgs} args - Arguments to update or create a InventoryAllocation.
     * @example
     * // Update or create a InventoryAllocation
     * const inventoryAllocation = await prisma.inventoryAllocation.upsert({
     *   create: {
     *     // ... data to create a InventoryAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryAllocation we want to update
     *   }
     * })
     */
    upsert<T extends InventoryAllocationUpsertArgs>(args: SelectSubset<T, InventoryAllocationUpsertArgs<ExtArgs>>): Prisma__InventoryAllocationClient<$Result.GetResult<Prisma.$InventoryAllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAllocationCountArgs} args - Arguments to filter InventoryAllocations to count.
     * @example
     * // Count the number of InventoryAllocations
     * const count = await prisma.inventoryAllocation.count({
     *   where: {
     *     // ... the filter for the InventoryAllocations we want to count
     *   }
     * })
    **/
    count<T extends InventoryAllocationCountArgs>(
      args?: Subset<T, InventoryAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAllocationAggregateArgs>(args: Subset<T, InventoryAllocationAggregateArgs>): Prisma.PrismaPromise<GetInventoryAllocationAggregateType<T>>

    /**
     * Group by InventoryAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryAllocationGroupByArgs['orderBy'] }
        : { orderBy?: InventoryAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryAllocation model
   */
  readonly fields: InventoryAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    element<T extends ElementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ElementDefaultArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryAllocation model
   */
  interface InventoryAllocationFieldRefs {
    readonly id: FieldRef<"InventoryAllocation", 'String'>
    readonly orderId: FieldRef<"InventoryAllocation", 'String'>
    readonly elementId: FieldRef<"InventoryAllocation", 'String'>
    readonly amountAllocated: FieldRef<"InventoryAllocation", 'Int'>
    readonly createdAt: FieldRef<"InventoryAllocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryAllocation findUnique
   */
  export type InventoryAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAllocation to fetch.
     */
    where: InventoryAllocationWhereUniqueInput
  }

  /**
   * InventoryAllocation findUniqueOrThrow
   */
  export type InventoryAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAllocation to fetch.
     */
    where: InventoryAllocationWhereUniqueInput
  }

  /**
   * InventoryAllocation findFirst
   */
  export type InventoryAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAllocation to fetch.
     */
    where?: InventoryAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAllocations to fetch.
     */
    orderBy?: InventoryAllocationOrderByWithRelationInput | InventoryAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAllocations.
     */
    cursor?: InventoryAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAllocations.
     */
    distinct?: InventoryAllocationScalarFieldEnum | InventoryAllocationScalarFieldEnum[]
  }

  /**
   * InventoryAllocation findFirstOrThrow
   */
  export type InventoryAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAllocation to fetch.
     */
    where?: InventoryAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAllocations to fetch.
     */
    orderBy?: InventoryAllocationOrderByWithRelationInput | InventoryAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAllocations.
     */
    cursor?: InventoryAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAllocations.
     */
    distinct?: InventoryAllocationScalarFieldEnum | InventoryAllocationScalarFieldEnum[]
  }

  /**
   * InventoryAllocation findMany
   */
  export type InventoryAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAllocations to fetch.
     */
    where?: InventoryAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAllocations to fetch.
     */
    orderBy?: InventoryAllocationOrderByWithRelationInput | InventoryAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryAllocations.
     */
    cursor?: InventoryAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAllocations.
     */
    skip?: number
    distinct?: InventoryAllocationScalarFieldEnum | InventoryAllocationScalarFieldEnum[]
  }

  /**
   * InventoryAllocation create
   */
  export type InventoryAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryAllocation.
     */
    data: XOR<InventoryAllocationCreateInput, InventoryAllocationUncheckedCreateInput>
  }

  /**
   * InventoryAllocation createMany
   */
  export type InventoryAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryAllocations.
     */
    data: InventoryAllocationCreateManyInput | InventoryAllocationCreateManyInput[]
  }

  /**
   * InventoryAllocation createManyAndReturn
   */
  export type InventoryAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryAllocations.
     */
    data: InventoryAllocationCreateManyInput | InventoryAllocationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryAllocation update
   */
  export type InventoryAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryAllocation.
     */
    data: XOR<InventoryAllocationUpdateInput, InventoryAllocationUncheckedUpdateInput>
    /**
     * Choose, which InventoryAllocation to update.
     */
    where: InventoryAllocationWhereUniqueInput
  }

  /**
   * InventoryAllocation updateMany
   */
  export type InventoryAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryAllocations.
     */
    data: XOR<InventoryAllocationUpdateManyMutationInput, InventoryAllocationUncheckedUpdateManyInput>
    /**
     * Filter which InventoryAllocations to update
     */
    where?: InventoryAllocationWhereInput
    /**
     * Limit how many InventoryAllocations to update.
     */
    limit?: number
  }

  /**
   * InventoryAllocation updateManyAndReturn
   */
  export type InventoryAllocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * The data used to update InventoryAllocations.
     */
    data: XOR<InventoryAllocationUpdateManyMutationInput, InventoryAllocationUncheckedUpdateManyInput>
    /**
     * Filter which InventoryAllocations to update
     */
    where?: InventoryAllocationWhereInput
    /**
     * Limit how many InventoryAllocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryAllocation upsert
   */
  export type InventoryAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryAllocation to update in case it exists.
     */
    where: InventoryAllocationWhereUniqueInput
    /**
     * In case the InventoryAllocation found by the `where` argument doesn't exist, create a new InventoryAllocation with this data.
     */
    create: XOR<InventoryAllocationCreateInput, InventoryAllocationUncheckedCreateInput>
    /**
     * In case the InventoryAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryAllocationUpdateInput, InventoryAllocationUncheckedUpdateInput>
  }

  /**
   * InventoryAllocation delete
   */
  export type InventoryAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
    /**
     * Filter which InventoryAllocation to delete.
     */
    where: InventoryAllocationWhereUniqueInput
  }

  /**
   * InventoryAllocation deleteMany
   */
  export type InventoryAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAllocations to delete
     */
    where?: InventoryAllocationWhereInput
    /**
     * Limit how many InventoryAllocations to delete.
     */
    limit?: number
  }

  /**
   * InventoryAllocation without action
   */
  export type InventoryAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAllocation
     */
    select?: InventoryAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAllocation
     */
    omit?: InventoryAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAllocationInclude<ExtArgs> | null
  }


  /**
   * Model ManufacturingOrder
   */

  export type AggregateManufacturingOrder = {
    _count: ManufacturingOrderCountAggregateOutputType | null
    _avg: ManufacturingOrderAvgAggregateOutputType | null
    _sum: ManufacturingOrderSumAggregateOutputType | null
    _min: ManufacturingOrderMinAggregateOutputType | null
    _max: ManufacturingOrderMaxAggregateOutputType | null
  }

  export type ManufacturingOrderAvgAggregateOutputType = {
    quantityToMake: number | null
  }

  export type ManufacturingOrderSumAggregateOutputType = {
    quantityToMake: number | null
  }

  export type ManufacturingOrderMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantityToMake: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManufacturingOrderMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantityToMake: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManufacturingOrderCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantityToMake: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ManufacturingOrderAvgAggregateInputType = {
    quantityToMake?: true
  }

  export type ManufacturingOrderSumAggregateInputType = {
    quantityToMake?: true
  }

  export type ManufacturingOrderMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantityToMake?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManufacturingOrderMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantityToMake?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManufacturingOrderCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantityToMake?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ManufacturingOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManufacturingOrder to aggregate.
     */
    where?: ManufacturingOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManufacturingOrders to fetch.
     */
    orderBy?: ManufacturingOrderOrderByWithRelationInput | ManufacturingOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManufacturingOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManufacturingOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManufacturingOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManufacturingOrders
    **/
    _count?: true | ManufacturingOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManufacturingOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManufacturingOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManufacturingOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManufacturingOrderMaxAggregateInputType
  }

  export type GetManufacturingOrderAggregateType<T extends ManufacturingOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateManufacturingOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManufacturingOrder[P]>
      : GetScalarType<T[P], AggregateManufacturingOrder[P]>
  }




  export type ManufacturingOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManufacturingOrderWhereInput
    orderBy?: ManufacturingOrderOrderByWithAggregationInput | ManufacturingOrderOrderByWithAggregationInput[]
    by: ManufacturingOrderScalarFieldEnum[] | ManufacturingOrderScalarFieldEnum
    having?: ManufacturingOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManufacturingOrderCountAggregateInputType | true
    _avg?: ManufacturingOrderAvgAggregateInputType
    _sum?: ManufacturingOrderSumAggregateInputType
    _min?: ManufacturingOrderMinAggregateInputType
    _max?: ManufacturingOrderMaxAggregateInputType
  }

  export type ManufacturingOrderGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    quantityToMake: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ManufacturingOrderCountAggregateOutputType | null
    _avg: ManufacturingOrderAvgAggregateOutputType | null
    _sum: ManufacturingOrderSumAggregateOutputType | null
    _min: ManufacturingOrderMinAggregateOutputType | null
    _max: ManufacturingOrderMaxAggregateOutputType | null
  }

  type GetManufacturingOrderGroupByPayload<T extends ManufacturingOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManufacturingOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManufacturingOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManufacturingOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ManufacturingOrderGroupByOutputType[P]>
        }
      >
    >


  export type ManufacturingOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantityToMake?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    requirements?: boolean | ManufacturingOrder$requirementsArgs<ExtArgs>
    _count?: boolean | ManufacturingOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manufacturingOrder"]>

  export type ManufacturingOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantityToMake?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manufacturingOrder"]>

  export type ManufacturingOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantityToMake?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manufacturingOrder"]>

  export type ManufacturingOrderSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantityToMake?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ManufacturingOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantityToMake" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["manufacturingOrder"]>
  export type ManufacturingOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    requirements?: boolean | ManufacturingOrder$requirementsArgs<ExtArgs>
    _count?: boolean | ManufacturingOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ManufacturingOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ManufacturingOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ManufacturingOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManufacturingOrder"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      requirements: Prisma.$MaterialRequirementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      quantityToMake: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["manufacturingOrder"]>
    composites: {}
  }

  type ManufacturingOrderGetPayload<S extends boolean | null | undefined | ManufacturingOrderDefaultArgs> = $Result.GetResult<Prisma.$ManufacturingOrderPayload, S>

  type ManufacturingOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManufacturingOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManufacturingOrderCountAggregateInputType | true
    }

  export interface ManufacturingOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManufacturingOrder'], meta: { name: 'ManufacturingOrder' } }
    /**
     * Find zero or one ManufacturingOrder that matches the filter.
     * @param {ManufacturingOrderFindUniqueArgs} args - Arguments to find a ManufacturingOrder
     * @example
     * // Get one ManufacturingOrder
     * const manufacturingOrder = await prisma.manufacturingOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManufacturingOrderFindUniqueArgs>(args: SelectSubset<T, ManufacturingOrderFindUniqueArgs<ExtArgs>>): Prisma__ManufacturingOrderClient<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ManufacturingOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManufacturingOrderFindUniqueOrThrowArgs} args - Arguments to find a ManufacturingOrder
     * @example
     * // Get one ManufacturingOrder
     * const manufacturingOrder = await prisma.manufacturingOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManufacturingOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ManufacturingOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManufacturingOrderClient<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManufacturingOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturingOrderFindFirstArgs} args - Arguments to find a ManufacturingOrder
     * @example
     * // Get one ManufacturingOrder
     * const manufacturingOrder = await prisma.manufacturingOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManufacturingOrderFindFirstArgs>(args?: SelectSubset<T, ManufacturingOrderFindFirstArgs<ExtArgs>>): Prisma__ManufacturingOrderClient<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManufacturingOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturingOrderFindFirstOrThrowArgs} args - Arguments to find a ManufacturingOrder
     * @example
     * // Get one ManufacturingOrder
     * const manufacturingOrder = await prisma.manufacturingOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManufacturingOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ManufacturingOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManufacturingOrderClient<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ManufacturingOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturingOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManufacturingOrders
     * const manufacturingOrders = await prisma.manufacturingOrder.findMany()
     * 
     * // Get first 10 ManufacturingOrders
     * const manufacturingOrders = await prisma.manufacturingOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manufacturingOrderWithIdOnly = await prisma.manufacturingOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManufacturingOrderFindManyArgs>(args?: SelectSubset<T, ManufacturingOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ManufacturingOrder.
     * @param {ManufacturingOrderCreateArgs} args - Arguments to create a ManufacturingOrder.
     * @example
     * // Create one ManufacturingOrder
     * const ManufacturingOrder = await prisma.manufacturingOrder.create({
     *   data: {
     *     // ... data to create a ManufacturingOrder
     *   }
     * })
     * 
     */
    create<T extends ManufacturingOrderCreateArgs>(args: SelectSubset<T, ManufacturingOrderCreateArgs<ExtArgs>>): Prisma__ManufacturingOrderClient<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ManufacturingOrders.
     * @param {ManufacturingOrderCreateManyArgs} args - Arguments to create many ManufacturingOrders.
     * @example
     * // Create many ManufacturingOrders
     * const manufacturingOrder = await prisma.manufacturingOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManufacturingOrderCreateManyArgs>(args?: SelectSubset<T, ManufacturingOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ManufacturingOrders and returns the data saved in the database.
     * @param {ManufacturingOrderCreateManyAndReturnArgs} args - Arguments to create many ManufacturingOrders.
     * @example
     * // Create many ManufacturingOrders
     * const manufacturingOrder = await prisma.manufacturingOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ManufacturingOrders and only return the `id`
     * const manufacturingOrderWithIdOnly = await prisma.manufacturingOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManufacturingOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, ManufacturingOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ManufacturingOrder.
     * @param {ManufacturingOrderDeleteArgs} args - Arguments to delete one ManufacturingOrder.
     * @example
     * // Delete one ManufacturingOrder
     * const ManufacturingOrder = await prisma.manufacturingOrder.delete({
     *   where: {
     *     // ... filter to delete one ManufacturingOrder
     *   }
     * })
     * 
     */
    delete<T extends ManufacturingOrderDeleteArgs>(args: SelectSubset<T, ManufacturingOrderDeleteArgs<ExtArgs>>): Prisma__ManufacturingOrderClient<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ManufacturingOrder.
     * @param {ManufacturingOrderUpdateArgs} args - Arguments to update one ManufacturingOrder.
     * @example
     * // Update one ManufacturingOrder
     * const manufacturingOrder = await prisma.manufacturingOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManufacturingOrderUpdateArgs>(args: SelectSubset<T, ManufacturingOrderUpdateArgs<ExtArgs>>): Prisma__ManufacturingOrderClient<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ManufacturingOrders.
     * @param {ManufacturingOrderDeleteManyArgs} args - Arguments to filter ManufacturingOrders to delete.
     * @example
     * // Delete a few ManufacturingOrders
     * const { count } = await prisma.manufacturingOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManufacturingOrderDeleteManyArgs>(args?: SelectSubset<T, ManufacturingOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManufacturingOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturingOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManufacturingOrders
     * const manufacturingOrder = await prisma.manufacturingOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManufacturingOrderUpdateManyArgs>(args: SelectSubset<T, ManufacturingOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManufacturingOrders and returns the data updated in the database.
     * @param {ManufacturingOrderUpdateManyAndReturnArgs} args - Arguments to update many ManufacturingOrders.
     * @example
     * // Update many ManufacturingOrders
     * const manufacturingOrder = await prisma.manufacturingOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ManufacturingOrders and only return the `id`
     * const manufacturingOrderWithIdOnly = await prisma.manufacturingOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManufacturingOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, ManufacturingOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ManufacturingOrder.
     * @param {ManufacturingOrderUpsertArgs} args - Arguments to update or create a ManufacturingOrder.
     * @example
     * // Update or create a ManufacturingOrder
     * const manufacturingOrder = await prisma.manufacturingOrder.upsert({
     *   create: {
     *     // ... data to create a ManufacturingOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManufacturingOrder we want to update
     *   }
     * })
     */
    upsert<T extends ManufacturingOrderUpsertArgs>(args: SelectSubset<T, ManufacturingOrderUpsertArgs<ExtArgs>>): Prisma__ManufacturingOrderClient<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ManufacturingOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturingOrderCountArgs} args - Arguments to filter ManufacturingOrders to count.
     * @example
     * // Count the number of ManufacturingOrders
     * const count = await prisma.manufacturingOrder.count({
     *   where: {
     *     // ... the filter for the ManufacturingOrders we want to count
     *   }
     * })
    **/
    count<T extends ManufacturingOrderCountArgs>(
      args?: Subset<T, ManufacturingOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManufacturingOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManufacturingOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturingOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManufacturingOrderAggregateArgs>(args: Subset<T, ManufacturingOrderAggregateArgs>): Prisma.PrismaPromise<GetManufacturingOrderAggregateType<T>>

    /**
     * Group by ManufacturingOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturingOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManufacturingOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManufacturingOrderGroupByArgs['orderBy'] }
        : { orderBy?: ManufacturingOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManufacturingOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManufacturingOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManufacturingOrder model
   */
  readonly fields: ManufacturingOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManufacturingOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManufacturingOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requirements<T extends ManufacturingOrder$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, ManufacturingOrder$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManufacturingOrder model
   */
  interface ManufacturingOrderFieldRefs {
    readonly id: FieldRef<"ManufacturingOrder", 'String'>
    readonly orderId: FieldRef<"ManufacturingOrder", 'String'>
    readonly productId: FieldRef<"ManufacturingOrder", 'String'>
    readonly quantityToMake: FieldRef<"ManufacturingOrder", 'Int'>
    readonly status: FieldRef<"ManufacturingOrder", 'String'>
    readonly createdAt: FieldRef<"ManufacturingOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"ManufacturingOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ManufacturingOrder findUnique
   */
  export type ManufacturingOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    /**
     * Filter, which ManufacturingOrder to fetch.
     */
    where: ManufacturingOrderWhereUniqueInput
  }

  /**
   * ManufacturingOrder findUniqueOrThrow
   */
  export type ManufacturingOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    /**
     * Filter, which ManufacturingOrder to fetch.
     */
    where: ManufacturingOrderWhereUniqueInput
  }

  /**
   * ManufacturingOrder findFirst
   */
  export type ManufacturingOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    /**
     * Filter, which ManufacturingOrder to fetch.
     */
    where?: ManufacturingOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManufacturingOrders to fetch.
     */
    orderBy?: ManufacturingOrderOrderByWithRelationInput | ManufacturingOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManufacturingOrders.
     */
    cursor?: ManufacturingOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManufacturingOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManufacturingOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManufacturingOrders.
     */
    distinct?: ManufacturingOrderScalarFieldEnum | ManufacturingOrderScalarFieldEnum[]
  }

  /**
   * ManufacturingOrder findFirstOrThrow
   */
  export type ManufacturingOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    /**
     * Filter, which ManufacturingOrder to fetch.
     */
    where?: ManufacturingOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManufacturingOrders to fetch.
     */
    orderBy?: ManufacturingOrderOrderByWithRelationInput | ManufacturingOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManufacturingOrders.
     */
    cursor?: ManufacturingOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManufacturingOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManufacturingOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManufacturingOrders.
     */
    distinct?: ManufacturingOrderScalarFieldEnum | ManufacturingOrderScalarFieldEnum[]
  }

  /**
   * ManufacturingOrder findMany
   */
  export type ManufacturingOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    /**
     * Filter, which ManufacturingOrders to fetch.
     */
    where?: ManufacturingOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManufacturingOrders to fetch.
     */
    orderBy?: ManufacturingOrderOrderByWithRelationInput | ManufacturingOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManufacturingOrders.
     */
    cursor?: ManufacturingOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManufacturingOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManufacturingOrders.
     */
    skip?: number
    distinct?: ManufacturingOrderScalarFieldEnum | ManufacturingOrderScalarFieldEnum[]
  }

  /**
   * ManufacturingOrder create
   */
  export type ManufacturingOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a ManufacturingOrder.
     */
    data: XOR<ManufacturingOrderCreateInput, ManufacturingOrderUncheckedCreateInput>
  }

  /**
   * ManufacturingOrder createMany
   */
  export type ManufacturingOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManufacturingOrders.
     */
    data: ManufacturingOrderCreateManyInput | ManufacturingOrderCreateManyInput[]
  }

  /**
   * ManufacturingOrder createManyAndReturn
   */
  export type ManufacturingOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * The data used to create many ManufacturingOrders.
     */
    data: ManufacturingOrderCreateManyInput | ManufacturingOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ManufacturingOrder update
   */
  export type ManufacturingOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a ManufacturingOrder.
     */
    data: XOR<ManufacturingOrderUpdateInput, ManufacturingOrderUncheckedUpdateInput>
    /**
     * Choose, which ManufacturingOrder to update.
     */
    where: ManufacturingOrderWhereUniqueInput
  }

  /**
   * ManufacturingOrder updateMany
   */
  export type ManufacturingOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManufacturingOrders.
     */
    data: XOR<ManufacturingOrderUpdateManyMutationInput, ManufacturingOrderUncheckedUpdateManyInput>
    /**
     * Filter which ManufacturingOrders to update
     */
    where?: ManufacturingOrderWhereInput
    /**
     * Limit how many ManufacturingOrders to update.
     */
    limit?: number
  }

  /**
   * ManufacturingOrder updateManyAndReturn
   */
  export type ManufacturingOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * The data used to update ManufacturingOrders.
     */
    data: XOR<ManufacturingOrderUpdateManyMutationInput, ManufacturingOrderUncheckedUpdateManyInput>
    /**
     * Filter which ManufacturingOrders to update
     */
    where?: ManufacturingOrderWhereInput
    /**
     * Limit how many ManufacturingOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ManufacturingOrder upsert
   */
  export type ManufacturingOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the ManufacturingOrder to update in case it exists.
     */
    where: ManufacturingOrderWhereUniqueInput
    /**
     * In case the ManufacturingOrder found by the `where` argument doesn't exist, create a new ManufacturingOrder with this data.
     */
    create: XOR<ManufacturingOrderCreateInput, ManufacturingOrderUncheckedCreateInput>
    /**
     * In case the ManufacturingOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManufacturingOrderUpdateInput, ManufacturingOrderUncheckedUpdateInput>
  }

  /**
   * ManufacturingOrder delete
   */
  export type ManufacturingOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
    /**
     * Filter which ManufacturingOrder to delete.
     */
    where: ManufacturingOrderWhereUniqueInput
  }

  /**
   * ManufacturingOrder deleteMany
   */
  export type ManufacturingOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManufacturingOrders to delete
     */
    where?: ManufacturingOrderWhereInput
    /**
     * Limit how many ManufacturingOrders to delete.
     */
    limit?: number
  }

  /**
   * ManufacturingOrder.requirements
   */
  export type ManufacturingOrder$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    where?: MaterialRequirementWhereInput
    orderBy?: MaterialRequirementOrderByWithRelationInput | MaterialRequirementOrderByWithRelationInput[]
    cursor?: MaterialRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialRequirementScalarFieldEnum | MaterialRequirementScalarFieldEnum[]
  }

  /**
   * ManufacturingOrder without action
   */
  export type ManufacturingOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturingOrder
     */
    select?: ManufacturingOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManufacturingOrder
     */
    omit?: ManufacturingOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManufacturingOrderInclude<ExtArgs> | null
  }


  /**
   * Model MaterialRequirement
   */

  export type AggregateMaterialRequirement = {
    _count: MaterialRequirementCountAggregateOutputType | null
    _avg: MaterialRequirementAvgAggregateOutputType | null
    _sum: MaterialRequirementSumAggregateOutputType | null
    _min: MaterialRequirementMinAggregateOutputType | null
    _max: MaterialRequirementMaxAggregateOutputType | null
  }

  export type MaterialRequirementAvgAggregateOutputType = {
    quantityNeeded: number | null
    quantityProduced: number | null
    totalWeightGrams: Decimal | null
  }

  export type MaterialRequirementSumAggregateOutputType = {
    quantityNeeded: number | null
    quantityProduced: number | null
    totalWeightGrams: Decimal | null
  }

  export type MaterialRequirementMinAggregateOutputType = {
    id: string | null
    manufacturingOrderId: string | null
    elementId: string | null
    quantityNeeded: number | null
    quantityProduced: number | null
    totalWeightGrams: Decimal | null
    createdAt: Date | null
  }

  export type MaterialRequirementMaxAggregateOutputType = {
    id: string | null
    manufacturingOrderId: string | null
    elementId: string | null
    quantityNeeded: number | null
    quantityProduced: number | null
    totalWeightGrams: Decimal | null
    createdAt: Date | null
  }

  export type MaterialRequirementCountAggregateOutputType = {
    id: number
    manufacturingOrderId: number
    elementId: number
    quantityNeeded: number
    quantityProduced: number
    totalWeightGrams: number
    createdAt: number
    _all: number
  }


  export type MaterialRequirementAvgAggregateInputType = {
    quantityNeeded?: true
    quantityProduced?: true
    totalWeightGrams?: true
  }

  export type MaterialRequirementSumAggregateInputType = {
    quantityNeeded?: true
    quantityProduced?: true
    totalWeightGrams?: true
  }

  export type MaterialRequirementMinAggregateInputType = {
    id?: true
    manufacturingOrderId?: true
    elementId?: true
    quantityNeeded?: true
    quantityProduced?: true
    totalWeightGrams?: true
    createdAt?: true
  }

  export type MaterialRequirementMaxAggregateInputType = {
    id?: true
    manufacturingOrderId?: true
    elementId?: true
    quantityNeeded?: true
    quantityProduced?: true
    totalWeightGrams?: true
    createdAt?: true
  }

  export type MaterialRequirementCountAggregateInputType = {
    id?: true
    manufacturingOrderId?: true
    elementId?: true
    quantityNeeded?: true
    quantityProduced?: true
    totalWeightGrams?: true
    createdAt?: true
    _all?: true
  }

  export type MaterialRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialRequirement to aggregate.
     */
    where?: MaterialRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequirements to fetch.
     */
    orderBy?: MaterialRequirementOrderByWithRelationInput | MaterialRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialRequirements
    **/
    _count?: true | MaterialRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialRequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialRequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialRequirementMaxAggregateInputType
  }

  export type GetMaterialRequirementAggregateType<T extends MaterialRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialRequirement[P]>
      : GetScalarType<T[P], AggregateMaterialRequirement[P]>
  }




  export type MaterialRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequirementWhereInput
    orderBy?: MaterialRequirementOrderByWithAggregationInput | MaterialRequirementOrderByWithAggregationInput[]
    by: MaterialRequirementScalarFieldEnum[] | MaterialRequirementScalarFieldEnum
    having?: MaterialRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialRequirementCountAggregateInputType | true
    _avg?: MaterialRequirementAvgAggregateInputType
    _sum?: MaterialRequirementSumAggregateInputType
    _min?: MaterialRequirementMinAggregateInputType
    _max?: MaterialRequirementMaxAggregateInputType
  }

  export type MaterialRequirementGroupByOutputType = {
    id: string
    manufacturingOrderId: string
    elementId: string
    quantityNeeded: number
    quantityProduced: number
    totalWeightGrams: Decimal
    createdAt: Date
    _count: MaterialRequirementCountAggregateOutputType | null
    _avg: MaterialRequirementAvgAggregateOutputType | null
    _sum: MaterialRequirementSumAggregateOutputType | null
    _min: MaterialRequirementMinAggregateOutputType | null
    _max: MaterialRequirementMaxAggregateOutputType | null
  }

  type GetMaterialRequirementGroupByPayload<T extends MaterialRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialRequirementGroupByOutputType[P]>
        }
      >
    >


  export type MaterialRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    manufacturingOrderId?: boolean
    elementId?: boolean
    quantityNeeded?: boolean
    quantityProduced?: boolean
    totalWeightGrams?: boolean
    createdAt?: boolean
    manufacturingOrder?: boolean | ManufacturingOrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialRequirement"]>

  export type MaterialRequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    manufacturingOrderId?: boolean
    elementId?: boolean
    quantityNeeded?: boolean
    quantityProduced?: boolean
    totalWeightGrams?: boolean
    createdAt?: boolean
    manufacturingOrder?: boolean | ManufacturingOrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialRequirement"]>

  export type MaterialRequirementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    manufacturingOrderId?: boolean
    elementId?: boolean
    quantityNeeded?: boolean
    quantityProduced?: boolean
    totalWeightGrams?: boolean
    createdAt?: boolean
    manufacturingOrder?: boolean | ManufacturingOrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialRequirement"]>

  export type MaterialRequirementSelectScalar = {
    id?: boolean
    manufacturingOrderId?: boolean
    elementId?: boolean
    quantityNeeded?: boolean
    quantityProduced?: boolean
    totalWeightGrams?: boolean
    createdAt?: boolean
  }

  export type MaterialRequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "manufacturingOrderId" | "elementId" | "quantityNeeded" | "quantityProduced" | "totalWeightGrams" | "createdAt", ExtArgs["result"]["materialRequirement"]>
  export type MaterialRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manufacturingOrder?: boolean | ManufacturingOrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }
  export type MaterialRequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manufacturingOrder?: boolean | ManufacturingOrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }
  export type MaterialRequirementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manufacturingOrder?: boolean | ManufacturingOrderDefaultArgs<ExtArgs>
    element?: boolean | ElementDefaultArgs<ExtArgs>
  }

  export type $MaterialRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialRequirement"
    objects: {
      manufacturingOrder: Prisma.$ManufacturingOrderPayload<ExtArgs>
      element: Prisma.$ElementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      manufacturingOrderId: string
      elementId: string
      quantityNeeded: number
      quantityProduced: number
      totalWeightGrams: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["materialRequirement"]>
    composites: {}
  }

  type MaterialRequirementGetPayload<S extends boolean | null | undefined | MaterialRequirementDefaultArgs> = $Result.GetResult<Prisma.$MaterialRequirementPayload, S>

  type MaterialRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialRequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialRequirementCountAggregateInputType | true
    }

  export interface MaterialRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialRequirement'], meta: { name: 'MaterialRequirement' } }
    /**
     * Find zero or one MaterialRequirement that matches the filter.
     * @param {MaterialRequirementFindUniqueArgs} args - Arguments to find a MaterialRequirement
     * @example
     * // Get one MaterialRequirement
     * const materialRequirement = await prisma.materialRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialRequirementFindUniqueArgs>(args: SelectSubset<T, MaterialRequirementFindUniqueArgs<ExtArgs>>): Prisma__MaterialRequirementClient<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaterialRequirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialRequirementFindUniqueOrThrowArgs} args - Arguments to find a MaterialRequirement
     * @example
     * // Get one MaterialRequirement
     * const materialRequirement = await prisma.materialRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialRequirementClient<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequirementFindFirstArgs} args - Arguments to find a MaterialRequirement
     * @example
     * // Get one MaterialRequirement
     * const materialRequirement = await prisma.materialRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialRequirementFindFirstArgs>(args?: SelectSubset<T, MaterialRequirementFindFirstArgs<ExtArgs>>): Prisma__MaterialRequirementClient<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequirementFindFirstOrThrowArgs} args - Arguments to find a MaterialRequirement
     * @example
     * // Get one MaterialRequirement
     * const materialRequirement = await prisma.materialRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialRequirementClient<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaterialRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialRequirements
     * const materialRequirements = await prisma.materialRequirement.findMany()
     * 
     * // Get first 10 MaterialRequirements
     * const materialRequirements = await prisma.materialRequirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialRequirementWithIdOnly = await prisma.materialRequirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialRequirementFindManyArgs>(args?: SelectSubset<T, MaterialRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaterialRequirement.
     * @param {MaterialRequirementCreateArgs} args - Arguments to create a MaterialRequirement.
     * @example
     * // Create one MaterialRequirement
     * const MaterialRequirement = await prisma.materialRequirement.create({
     *   data: {
     *     // ... data to create a MaterialRequirement
     *   }
     * })
     * 
     */
    create<T extends MaterialRequirementCreateArgs>(args: SelectSubset<T, MaterialRequirementCreateArgs<ExtArgs>>): Prisma__MaterialRequirementClient<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaterialRequirements.
     * @param {MaterialRequirementCreateManyArgs} args - Arguments to create many MaterialRequirements.
     * @example
     * // Create many MaterialRequirements
     * const materialRequirement = await prisma.materialRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialRequirementCreateManyArgs>(args?: SelectSubset<T, MaterialRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaterialRequirements and returns the data saved in the database.
     * @param {MaterialRequirementCreateManyAndReturnArgs} args - Arguments to create many MaterialRequirements.
     * @example
     * // Create many MaterialRequirements
     * const materialRequirement = await prisma.materialRequirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaterialRequirements and only return the `id`
     * const materialRequirementWithIdOnly = await prisma.materialRequirement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialRequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialRequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaterialRequirement.
     * @param {MaterialRequirementDeleteArgs} args - Arguments to delete one MaterialRequirement.
     * @example
     * // Delete one MaterialRequirement
     * const MaterialRequirement = await prisma.materialRequirement.delete({
     *   where: {
     *     // ... filter to delete one MaterialRequirement
     *   }
     * })
     * 
     */
    delete<T extends MaterialRequirementDeleteArgs>(args: SelectSubset<T, MaterialRequirementDeleteArgs<ExtArgs>>): Prisma__MaterialRequirementClient<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaterialRequirement.
     * @param {MaterialRequirementUpdateArgs} args - Arguments to update one MaterialRequirement.
     * @example
     * // Update one MaterialRequirement
     * const materialRequirement = await prisma.materialRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialRequirementUpdateArgs>(args: SelectSubset<T, MaterialRequirementUpdateArgs<ExtArgs>>): Prisma__MaterialRequirementClient<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaterialRequirements.
     * @param {MaterialRequirementDeleteManyArgs} args - Arguments to filter MaterialRequirements to delete.
     * @example
     * // Delete a few MaterialRequirements
     * const { count } = await prisma.materialRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialRequirementDeleteManyArgs>(args?: SelectSubset<T, MaterialRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialRequirements
     * const materialRequirement = await prisma.materialRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialRequirementUpdateManyArgs>(args: SelectSubset<T, MaterialRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialRequirements and returns the data updated in the database.
     * @param {MaterialRequirementUpdateManyAndReturnArgs} args - Arguments to update many MaterialRequirements.
     * @example
     * // Update many MaterialRequirements
     * const materialRequirement = await prisma.materialRequirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaterialRequirements and only return the `id`
     * const materialRequirementWithIdOnly = await prisma.materialRequirement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialRequirementUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialRequirementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaterialRequirement.
     * @param {MaterialRequirementUpsertArgs} args - Arguments to update or create a MaterialRequirement.
     * @example
     * // Update or create a MaterialRequirement
     * const materialRequirement = await prisma.materialRequirement.upsert({
     *   create: {
     *     // ... data to create a MaterialRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialRequirement we want to update
     *   }
     * })
     */
    upsert<T extends MaterialRequirementUpsertArgs>(args: SelectSubset<T, MaterialRequirementUpsertArgs<ExtArgs>>): Prisma__MaterialRequirementClient<$Result.GetResult<Prisma.$MaterialRequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaterialRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequirementCountArgs} args - Arguments to filter MaterialRequirements to count.
     * @example
     * // Count the number of MaterialRequirements
     * const count = await prisma.materialRequirement.count({
     *   where: {
     *     // ... the filter for the MaterialRequirements we want to count
     *   }
     * })
    **/
    count<T extends MaterialRequirementCountArgs>(
      args?: Subset<T, MaterialRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialRequirementAggregateArgs>(args: Subset<T, MaterialRequirementAggregateArgs>): Prisma.PrismaPromise<GetMaterialRequirementAggregateType<T>>

    /**
     * Group by MaterialRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialRequirementGroupByArgs['orderBy'] }
        : { orderBy?: MaterialRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialRequirement model
   */
  readonly fields: MaterialRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manufacturingOrder<T extends ManufacturingOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManufacturingOrderDefaultArgs<ExtArgs>>): Prisma__ManufacturingOrderClient<$Result.GetResult<Prisma.$ManufacturingOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    element<T extends ElementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ElementDefaultArgs<ExtArgs>>): Prisma__ElementClient<$Result.GetResult<Prisma.$ElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialRequirement model
   */
  interface MaterialRequirementFieldRefs {
    readonly id: FieldRef<"MaterialRequirement", 'String'>
    readonly manufacturingOrderId: FieldRef<"MaterialRequirement", 'String'>
    readonly elementId: FieldRef<"MaterialRequirement", 'String'>
    readonly quantityNeeded: FieldRef<"MaterialRequirement", 'Int'>
    readonly quantityProduced: FieldRef<"MaterialRequirement", 'Int'>
    readonly totalWeightGrams: FieldRef<"MaterialRequirement", 'Decimal'>
    readonly createdAt: FieldRef<"MaterialRequirement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaterialRequirement findUnique
   */
  export type MaterialRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequirement to fetch.
     */
    where: MaterialRequirementWhereUniqueInput
  }

  /**
   * MaterialRequirement findUniqueOrThrow
   */
  export type MaterialRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequirement to fetch.
     */
    where: MaterialRequirementWhereUniqueInput
  }

  /**
   * MaterialRequirement findFirst
   */
  export type MaterialRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequirement to fetch.
     */
    where?: MaterialRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequirements to fetch.
     */
    orderBy?: MaterialRequirementOrderByWithRelationInput | MaterialRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialRequirements.
     */
    cursor?: MaterialRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialRequirements.
     */
    distinct?: MaterialRequirementScalarFieldEnum | MaterialRequirementScalarFieldEnum[]
  }

  /**
   * MaterialRequirement findFirstOrThrow
   */
  export type MaterialRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequirement to fetch.
     */
    where?: MaterialRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequirements to fetch.
     */
    orderBy?: MaterialRequirementOrderByWithRelationInput | MaterialRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialRequirements.
     */
    cursor?: MaterialRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialRequirements.
     */
    distinct?: MaterialRequirementScalarFieldEnum | MaterialRequirementScalarFieldEnum[]
  }

  /**
   * MaterialRequirement findMany
   */
  export type MaterialRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequirements to fetch.
     */
    where?: MaterialRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequirements to fetch.
     */
    orderBy?: MaterialRequirementOrderByWithRelationInput | MaterialRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialRequirements.
     */
    cursor?: MaterialRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequirements.
     */
    skip?: number
    distinct?: MaterialRequirementScalarFieldEnum | MaterialRequirementScalarFieldEnum[]
  }

  /**
   * MaterialRequirement create
   */
  export type MaterialRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialRequirement.
     */
    data: XOR<MaterialRequirementCreateInput, MaterialRequirementUncheckedCreateInput>
  }

  /**
   * MaterialRequirement createMany
   */
  export type MaterialRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialRequirements.
     */
    data: MaterialRequirementCreateManyInput | MaterialRequirementCreateManyInput[]
  }

  /**
   * MaterialRequirement createManyAndReturn
   */
  export type MaterialRequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * The data used to create many MaterialRequirements.
     */
    data: MaterialRequirementCreateManyInput | MaterialRequirementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialRequirement update
   */
  export type MaterialRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialRequirement.
     */
    data: XOR<MaterialRequirementUpdateInput, MaterialRequirementUncheckedUpdateInput>
    /**
     * Choose, which MaterialRequirement to update.
     */
    where: MaterialRequirementWhereUniqueInput
  }

  /**
   * MaterialRequirement updateMany
   */
  export type MaterialRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialRequirements.
     */
    data: XOR<MaterialRequirementUpdateManyMutationInput, MaterialRequirementUncheckedUpdateManyInput>
    /**
     * Filter which MaterialRequirements to update
     */
    where?: MaterialRequirementWhereInput
    /**
     * Limit how many MaterialRequirements to update.
     */
    limit?: number
  }

  /**
   * MaterialRequirement updateManyAndReturn
   */
  export type MaterialRequirementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * The data used to update MaterialRequirements.
     */
    data: XOR<MaterialRequirementUpdateManyMutationInput, MaterialRequirementUncheckedUpdateManyInput>
    /**
     * Filter which MaterialRequirements to update
     */
    where?: MaterialRequirementWhereInput
    /**
     * Limit how many MaterialRequirements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialRequirement upsert
   */
  export type MaterialRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialRequirement to update in case it exists.
     */
    where: MaterialRequirementWhereUniqueInput
    /**
     * In case the MaterialRequirement found by the `where` argument doesn't exist, create a new MaterialRequirement with this data.
     */
    create: XOR<MaterialRequirementCreateInput, MaterialRequirementUncheckedCreateInput>
    /**
     * In case the MaterialRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialRequirementUpdateInput, MaterialRequirementUncheckedUpdateInput>
  }

  /**
   * MaterialRequirement delete
   */
  export type MaterialRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
    /**
     * Filter which MaterialRequirement to delete.
     */
    where: MaterialRequirementWhereUniqueInput
  }

  /**
   * MaterialRequirement deleteMany
   */
  export type MaterialRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialRequirements to delete
     */
    where?: MaterialRequirementWhereInput
    /**
     * Limit how many MaterialRequirements to delete.
     */
    limit?: number
  }

  /**
   * MaterialRequirement without action
   */
  export type MaterialRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequirement
     */
    select?: MaterialRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialRequirement
     */
    omit?: MaterialRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequirementInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RawMaterialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    unit: 'unit',
    stockQty: 'stockQty',
    createdAt: 'createdAt'
  };

  export type RawMaterialScalarFieldEnum = (typeof RawMaterialScalarFieldEnum)[keyof typeof RawMaterialScalarFieldEnum]


  export const RawMaterialTransactionScalarFieldEnum: {
    id: 'id',
    rawMaterialId: 'rawMaterialId',
    changeAmount: 'changeAmount',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type RawMaterialTransactionScalarFieldEnum = (typeof RawMaterialTransactionScalarFieldEnum)[keyof typeof RawMaterialTransactionScalarFieldEnum]


  export const ElementScalarFieldEnum: {
    id: 'id',
    uniqueName: 'uniqueName',
    label: 'label',
    color: 'color',
    color2: 'color2',
    isDualColor: 'isDualColor',
    material: 'material',
    rawMaterialId: 'rawMaterialId',
    weightGrams: 'weightGrams',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type ElementScalarFieldEnum = (typeof ElementScalarFieldEnum)[keyof typeof ElementScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    serialNumber: 'serialNumber',
    category: 'category',
    label: 'label',
    unitsPerAssembly: 'unitsPerAssembly',
    unitsPerBox: 'unitsPerBox',
    boxRawMaterialId: 'boxRawMaterialId',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductElementScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    elementId: 'elementId',
    quantityNeeded: 'quantityNeeded',
    createdAt: 'createdAt'
  };

  export type ProductElementScalarFieldEnum = (typeof ProductElementScalarFieldEnum)[keyof typeof ProductElementScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    elementId: 'elementId',
    totalAmount: 'totalAmount',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const ProductStockScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    stockBoxedAmount: 'stockBoxedAmount',
    updatedAt: 'updatedAt'
  };

  export type ProductStockScalarFieldEnum = (typeof ProductStockScalarFieldEnum)[keyof typeof ProductStockScalarFieldEnum]


  export const InventoryTransactionScalarFieldEnum: {
    id: 'id',
    elementId: 'elementId',
    changeAmount: 'changeAmount',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type InventoryTransactionScalarFieldEnum = (typeof InventoryTransactionScalarFieldEnum)[keyof typeof InventoryTransactionScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    clientName: 'clientName',
    createdAt: 'createdAt',
    shippedAt: 'shippedAt',
    status: 'status',
    notes: 'notes'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    boxesNeeded: 'boxesNeeded',
    boxesAssembled: 'boxesAssembled',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const InventoryAllocationScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    elementId: 'elementId',
    amountAllocated: 'amountAllocated',
    createdAt: 'createdAt'
  };

  export type InventoryAllocationScalarFieldEnum = (typeof InventoryAllocationScalarFieldEnum)[keyof typeof InventoryAllocationScalarFieldEnum]


  export const ManufacturingOrderScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantityToMake: 'quantityToMake',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ManufacturingOrderScalarFieldEnum = (typeof ManufacturingOrderScalarFieldEnum)[keyof typeof ManufacturingOrderScalarFieldEnum]


  export const MaterialRequirementScalarFieldEnum: {
    id: 'id',
    manufacturingOrderId: 'manufacturingOrderId',
    elementId: 'elementId',
    quantityNeeded: 'quantityNeeded',
    quantityProduced: 'quantityProduced',
    totalWeightGrams: 'totalWeightGrams',
    createdAt: 'createdAt'
  };

  export type MaterialRequirementScalarFieldEnum = (typeof MaterialRequirementScalarFieldEnum)[keyof typeof MaterialRequirementScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RawMaterialWhereInput = {
    AND?: RawMaterialWhereInput | RawMaterialWhereInput[]
    OR?: RawMaterialWhereInput[]
    NOT?: RawMaterialWhereInput | RawMaterialWhereInput[]
    id?: StringFilter<"RawMaterial"> | string
    name?: StringFilter<"RawMaterial"> | string
    unit?: StringFilter<"RawMaterial"> | string
    stockQty?: FloatFilter<"RawMaterial"> | number
    createdAt?: DateTimeFilter<"RawMaterial"> | Date | string
    elements?: ElementListRelationFilter
    packagingForProducts?: ProductListRelationFilter
    transactions?: RawMaterialTransactionListRelationFilter
  }

  export type RawMaterialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    stockQty?: SortOrder
    createdAt?: SortOrder
    elements?: ElementOrderByRelationAggregateInput
    packagingForProducts?: ProductOrderByRelationAggregateInput
    transactions?: RawMaterialTransactionOrderByRelationAggregateInput
  }

  export type RawMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RawMaterialWhereInput | RawMaterialWhereInput[]
    OR?: RawMaterialWhereInput[]
    NOT?: RawMaterialWhereInput | RawMaterialWhereInput[]
    unit?: StringFilter<"RawMaterial"> | string
    stockQty?: FloatFilter<"RawMaterial"> | number
    createdAt?: DateTimeFilter<"RawMaterial"> | Date | string
    elements?: ElementListRelationFilter
    packagingForProducts?: ProductListRelationFilter
    transactions?: RawMaterialTransactionListRelationFilter
  }, "id" | "name">

  export type RawMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    stockQty?: SortOrder
    createdAt?: SortOrder
    _count?: RawMaterialCountOrderByAggregateInput
    _avg?: RawMaterialAvgOrderByAggregateInput
    _max?: RawMaterialMaxOrderByAggregateInput
    _min?: RawMaterialMinOrderByAggregateInput
    _sum?: RawMaterialSumOrderByAggregateInput
  }

  export type RawMaterialScalarWhereWithAggregatesInput = {
    AND?: RawMaterialScalarWhereWithAggregatesInput | RawMaterialScalarWhereWithAggregatesInput[]
    OR?: RawMaterialScalarWhereWithAggregatesInput[]
    NOT?: RawMaterialScalarWhereWithAggregatesInput | RawMaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RawMaterial"> | string
    name?: StringWithAggregatesFilter<"RawMaterial"> | string
    unit?: StringWithAggregatesFilter<"RawMaterial"> | string
    stockQty?: FloatWithAggregatesFilter<"RawMaterial"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RawMaterial"> | Date | string
  }

  export type RawMaterialTransactionWhereInput = {
    AND?: RawMaterialTransactionWhereInput | RawMaterialTransactionWhereInput[]
    OR?: RawMaterialTransactionWhereInput[]
    NOT?: RawMaterialTransactionWhereInput | RawMaterialTransactionWhereInput[]
    id?: StringFilter<"RawMaterialTransaction"> | string
    rawMaterialId?: StringFilter<"RawMaterialTransaction"> | string
    changeAmount?: FloatFilter<"RawMaterialTransaction"> | number
    reason?: StringFilter<"RawMaterialTransaction"> | string
    createdAt?: DateTimeFilter<"RawMaterialTransaction"> | Date | string
    rawMaterial?: XOR<RawMaterialScalarRelationFilter, RawMaterialWhereInput>
  }

  export type RawMaterialTransactionOrderByWithRelationInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    changeAmount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    rawMaterial?: RawMaterialOrderByWithRelationInput
  }

  export type RawMaterialTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RawMaterialTransactionWhereInput | RawMaterialTransactionWhereInput[]
    OR?: RawMaterialTransactionWhereInput[]
    NOT?: RawMaterialTransactionWhereInput | RawMaterialTransactionWhereInput[]
    rawMaterialId?: StringFilter<"RawMaterialTransaction"> | string
    changeAmount?: FloatFilter<"RawMaterialTransaction"> | number
    reason?: StringFilter<"RawMaterialTransaction"> | string
    createdAt?: DateTimeFilter<"RawMaterialTransaction"> | Date | string
    rawMaterial?: XOR<RawMaterialScalarRelationFilter, RawMaterialWhereInput>
  }, "id">

  export type RawMaterialTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    changeAmount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    _count?: RawMaterialTransactionCountOrderByAggregateInput
    _avg?: RawMaterialTransactionAvgOrderByAggregateInput
    _max?: RawMaterialTransactionMaxOrderByAggregateInput
    _min?: RawMaterialTransactionMinOrderByAggregateInput
    _sum?: RawMaterialTransactionSumOrderByAggregateInput
  }

  export type RawMaterialTransactionScalarWhereWithAggregatesInput = {
    AND?: RawMaterialTransactionScalarWhereWithAggregatesInput | RawMaterialTransactionScalarWhereWithAggregatesInput[]
    OR?: RawMaterialTransactionScalarWhereWithAggregatesInput[]
    NOT?: RawMaterialTransactionScalarWhereWithAggregatesInput | RawMaterialTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RawMaterialTransaction"> | string
    rawMaterialId?: StringWithAggregatesFilter<"RawMaterialTransaction"> | string
    changeAmount?: FloatWithAggregatesFilter<"RawMaterialTransaction"> | number
    reason?: StringWithAggregatesFilter<"RawMaterialTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RawMaterialTransaction"> | Date | string
  }

  export type ElementWhereInput = {
    AND?: ElementWhereInput | ElementWhereInput[]
    OR?: ElementWhereInput[]
    NOT?: ElementWhereInput | ElementWhereInput[]
    id?: StringFilter<"Element"> | string
    uniqueName?: StringFilter<"Element"> | string
    label?: StringFilter<"Element"> | string
    color?: StringFilter<"Element"> | string
    color2?: StringNullableFilter<"Element"> | string | null
    isDualColor?: BoolFilter<"Element"> | boolean
    material?: StringFilter<"Element"> | string
    rawMaterialId?: StringNullableFilter<"Element"> | string | null
    weightGrams?: DecimalFilter<"Element"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableFilter<"Element"> | string | null
    createdAt?: DateTimeFilter<"Element"> | Date | string
    rawMaterial?: XOR<RawMaterialNullableScalarRelationFilter, RawMaterialWhereInput> | null
    productElements?: ProductElementListRelationFilter
    inventory?: InventoryListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    materialRequirements?: MaterialRequirementListRelationFilter
    inventoryAllocations?: InventoryAllocationListRelationFilter
  }

  export type ElementOrderByWithRelationInput = {
    id?: SortOrder
    uniqueName?: SortOrder
    label?: SortOrder
    color?: SortOrder
    color2?: SortOrderInput | SortOrder
    isDualColor?: SortOrder
    material?: SortOrder
    rawMaterialId?: SortOrderInput | SortOrder
    weightGrams?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    rawMaterial?: RawMaterialOrderByWithRelationInput
    productElements?: ProductElementOrderByRelationAggregateInput
    inventory?: InventoryOrderByRelationAggregateInput
    inventoryTransactions?: InventoryTransactionOrderByRelationAggregateInput
    materialRequirements?: MaterialRequirementOrderByRelationAggregateInput
    inventoryAllocations?: InventoryAllocationOrderByRelationAggregateInput
  }

  export type ElementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ElementWhereInput | ElementWhereInput[]
    OR?: ElementWhereInput[]
    NOT?: ElementWhereInput | ElementWhereInput[]
    uniqueName?: StringFilter<"Element"> | string
    label?: StringFilter<"Element"> | string
    color?: StringFilter<"Element"> | string
    color2?: StringNullableFilter<"Element"> | string | null
    isDualColor?: BoolFilter<"Element"> | boolean
    material?: StringFilter<"Element"> | string
    rawMaterialId?: StringNullableFilter<"Element"> | string | null
    weightGrams?: DecimalFilter<"Element"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableFilter<"Element"> | string | null
    createdAt?: DateTimeFilter<"Element"> | Date | string
    rawMaterial?: XOR<RawMaterialNullableScalarRelationFilter, RawMaterialWhereInput> | null
    productElements?: ProductElementListRelationFilter
    inventory?: InventoryListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    materialRequirements?: MaterialRequirementListRelationFilter
    inventoryAllocations?: InventoryAllocationListRelationFilter
  }, "id">

  export type ElementOrderByWithAggregationInput = {
    id?: SortOrder
    uniqueName?: SortOrder
    label?: SortOrder
    color?: SortOrder
    color2?: SortOrderInput | SortOrder
    isDualColor?: SortOrder
    material?: SortOrder
    rawMaterialId?: SortOrderInput | SortOrder
    weightGrams?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ElementCountOrderByAggregateInput
    _avg?: ElementAvgOrderByAggregateInput
    _max?: ElementMaxOrderByAggregateInput
    _min?: ElementMinOrderByAggregateInput
    _sum?: ElementSumOrderByAggregateInput
  }

  export type ElementScalarWhereWithAggregatesInput = {
    AND?: ElementScalarWhereWithAggregatesInput | ElementScalarWhereWithAggregatesInput[]
    OR?: ElementScalarWhereWithAggregatesInput[]
    NOT?: ElementScalarWhereWithAggregatesInput | ElementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Element"> | string
    uniqueName?: StringWithAggregatesFilter<"Element"> | string
    label?: StringWithAggregatesFilter<"Element"> | string
    color?: StringWithAggregatesFilter<"Element"> | string
    color2?: StringNullableWithAggregatesFilter<"Element"> | string | null
    isDualColor?: BoolWithAggregatesFilter<"Element"> | boolean
    material?: StringWithAggregatesFilter<"Element"> | string
    rawMaterialId?: StringNullableWithAggregatesFilter<"Element"> | string | null
    weightGrams?: DecimalWithAggregatesFilter<"Element"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableWithAggregatesFilter<"Element"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Element"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    serialNumber?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    label?: StringFilter<"Product"> | string
    unitsPerAssembly?: IntFilter<"Product"> | number
    unitsPerBox?: IntFilter<"Product"> | number
    boxRawMaterialId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    boxRawMaterial?: XOR<RawMaterialNullableScalarRelationFilter, RawMaterialWhereInput> | null
    productElements?: ProductElementListRelationFilter
    productStock?: XOR<ProductStockNullableScalarRelationFilter, ProductStockWhereInput> | null
    orderItems?: OrderItemListRelationFilter
    manufacturingOrders?: ManufacturingOrderListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    category?: SortOrder
    label?: SortOrder
    unitsPerAssembly?: SortOrder
    unitsPerBox?: SortOrder
    boxRawMaterialId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    boxRawMaterial?: RawMaterialOrderByWithRelationInput
    productElements?: ProductElementOrderByRelationAggregateInput
    productStock?: ProductStockOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    manufacturingOrders?: ManufacturingOrderOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    category?: StringFilter<"Product"> | string
    label?: StringFilter<"Product"> | string
    unitsPerAssembly?: IntFilter<"Product"> | number
    unitsPerBox?: IntFilter<"Product"> | number
    boxRawMaterialId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    boxRawMaterial?: XOR<RawMaterialNullableScalarRelationFilter, RawMaterialWhereInput> | null
    productElements?: ProductElementListRelationFilter
    productStock?: XOR<ProductStockNullableScalarRelationFilter, ProductStockWhereInput> | null
    orderItems?: OrderItemListRelationFilter
    manufacturingOrders?: ManufacturingOrderListRelationFilter
  }, "id" | "serialNumber">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    category?: SortOrder
    label?: SortOrder
    unitsPerAssembly?: SortOrder
    unitsPerBox?: SortOrder
    boxRawMaterialId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    serialNumber?: StringWithAggregatesFilter<"Product"> | string
    category?: StringWithAggregatesFilter<"Product"> | string
    label?: StringWithAggregatesFilter<"Product"> | string
    unitsPerAssembly?: IntWithAggregatesFilter<"Product"> | number
    unitsPerBox?: IntWithAggregatesFilter<"Product"> | number
    boxRawMaterialId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductElementWhereInput = {
    AND?: ProductElementWhereInput | ProductElementWhereInput[]
    OR?: ProductElementWhereInput[]
    NOT?: ProductElementWhereInput | ProductElementWhereInput[]
    id?: StringFilter<"ProductElement"> | string
    productId?: StringFilter<"ProductElement"> | string
    elementId?: StringFilter<"ProductElement"> | string
    quantityNeeded?: IntFilter<"ProductElement"> | number
    createdAt?: DateTimeFilter<"ProductElement"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    element?: XOR<ElementScalarRelationFilter, ElementWhereInput>
  }

  export type ProductElementOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    elementId?: SortOrder
    quantityNeeded?: SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    element?: ElementOrderByWithRelationInput
  }

  export type ProductElementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_elementId?: ProductElementProductIdElementIdCompoundUniqueInput
    AND?: ProductElementWhereInput | ProductElementWhereInput[]
    OR?: ProductElementWhereInput[]
    NOT?: ProductElementWhereInput | ProductElementWhereInput[]
    productId?: StringFilter<"ProductElement"> | string
    elementId?: StringFilter<"ProductElement"> | string
    quantityNeeded?: IntFilter<"ProductElement"> | number
    createdAt?: DateTimeFilter<"ProductElement"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    element?: XOR<ElementScalarRelationFilter, ElementWhereInput>
  }, "id" | "productId_elementId">

  export type ProductElementOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    elementId?: SortOrder
    quantityNeeded?: SortOrder
    createdAt?: SortOrder
    _count?: ProductElementCountOrderByAggregateInput
    _avg?: ProductElementAvgOrderByAggregateInput
    _max?: ProductElementMaxOrderByAggregateInput
    _min?: ProductElementMinOrderByAggregateInput
    _sum?: ProductElementSumOrderByAggregateInput
  }

  export type ProductElementScalarWhereWithAggregatesInput = {
    AND?: ProductElementScalarWhereWithAggregatesInput | ProductElementScalarWhereWithAggregatesInput[]
    OR?: ProductElementScalarWhereWithAggregatesInput[]
    NOT?: ProductElementScalarWhereWithAggregatesInput | ProductElementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductElement"> | string
    productId?: StringWithAggregatesFilter<"ProductElement"> | string
    elementId?: StringWithAggregatesFilter<"ProductElement"> | string
    quantityNeeded?: IntWithAggregatesFilter<"ProductElement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductElement"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    elementId?: StringFilter<"Inventory"> | string
    totalAmount?: IntFilter<"Inventory"> | number
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    element?: XOR<ElementScalarRelationFilter, ElementWhereInput>
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    elementId?: SortOrder
    totalAmount?: SortOrder
    updatedAt?: SortOrder
    element?: ElementOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    elementId?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    totalAmount?: IntFilter<"Inventory"> | number
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    element?: XOR<ElementScalarRelationFilter, ElementWhereInput>
  }, "id" | "elementId">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    elementId?: SortOrder
    totalAmount?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    elementId?: StringWithAggregatesFilter<"Inventory"> | string
    totalAmount?: IntWithAggregatesFilter<"Inventory"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type ProductStockWhereInput = {
    AND?: ProductStockWhereInput | ProductStockWhereInput[]
    OR?: ProductStockWhereInput[]
    NOT?: ProductStockWhereInput | ProductStockWhereInput[]
    id?: StringFilter<"ProductStock"> | string
    productId?: StringFilter<"ProductStock"> | string
    stockBoxedAmount?: IntFilter<"ProductStock"> | number
    updatedAt?: DateTimeFilter<"ProductStock"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductStockOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    stockBoxedAmount?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductStockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: ProductStockWhereInput | ProductStockWhereInput[]
    OR?: ProductStockWhereInput[]
    NOT?: ProductStockWhereInput | ProductStockWhereInput[]
    stockBoxedAmount?: IntFilter<"ProductStock"> | number
    updatedAt?: DateTimeFilter<"ProductStock"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productId">

  export type ProductStockOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    stockBoxedAmount?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductStockCountOrderByAggregateInput
    _avg?: ProductStockAvgOrderByAggregateInput
    _max?: ProductStockMaxOrderByAggregateInput
    _min?: ProductStockMinOrderByAggregateInput
    _sum?: ProductStockSumOrderByAggregateInput
  }

  export type ProductStockScalarWhereWithAggregatesInput = {
    AND?: ProductStockScalarWhereWithAggregatesInput | ProductStockScalarWhereWithAggregatesInput[]
    OR?: ProductStockScalarWhereWithAggregatesInput[]
    NOT?: ProductStockScalarWhereWithAggregatesInput | ProductStockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductStock"> | string
    productId?: StringWithAggregatesFilter<"ProductStock"> | string
    stockBoxedAmount?: IntWithAggregatesFilter<"ProductStock"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"ProductStock"> | Date | string
  }

  export type InventoryTransactionWhereInput = {
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    id?: StringFilter<"InventoryTransaction"> | string
    elementId?: StringNullableFilter<"InventoryTransaction"> | string | null
    changeAmount?: IntFilter<"InventoryTransaction"> | number
    reason?: StringFilter<"InventoryTransaction"> | string
    createdAt?: DateTimeFilter<"InventoryTransaction"> | Date | string
    element?: XOR<ElementNullableScalarRelationFilter, ElementWhereInput> | null
  }

  export type InventoryTransactionOrderByWithRelationInput = {
    id?: SortOrder
    elementId?: SortOrderInput | SortOrder
    changeAmount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    element?: ElementOrderByWithRelationInput
  }

  export type InventoryTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    elementId?: StringNullableFilter<"InventoryTransaction"> | string | null
    changeAmount?: IntFilter<"InventoryTransaction"> | number
    reason?: StringFilter<"InventoryTransaction"> | string
    createdAt?: DateTimeFilter<"InventoryTransaction"> | Date | string
    element?: XOR<ElementNullableScalarRelationFilter, ElementWhereInput> | null
  }, "id">

  export type InventoryTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    elementId?: SortOrderInput | SortOrder
    changeAmount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    _count?: InventoryTransactionCountOrderByAggregateInput
    _avg?: InventoryTransactionAvgOrderByAggregateInput
    _max?: InventoryTransactionMaxOrderByAggregateInput
    _min?: InventoryTransactionMinOrderByAggregateInput
    _sum?: InventoryTransactionSumOrderByAggregateInput
  }

  export type InventoryTransactionScalarWhereWithAggregatesInput = {
    AND?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    OR?: InventoryTransactionScalarWhereWithAggregatesInput[]
    NOT?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    elementId?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    changeAmount?: IntWithAggregatesFilter<"InventoryTransaction"> | number
    reason?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InventoryTransaction"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: IntFilter<"Order"> | number
    clientName?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    shippedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    status?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    orderItems?: OrderItemListRelationFilter
    manufacturingOrders?: ManufacturingOrderListRelationFilter
    inventoryAllocations?: InventoryAllocationListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientName?: SortOrder
    createdAt?: SortOrder
    shippedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    manufacturingOrders?: ManufacturingOrderOrderByRelationAggregateInput
    inventoryAllocations?: InventoryAllocationOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: number
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    clientName?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    shippedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    status?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    orderItems?: OrderItemListRelationFilter
    manufacturingOrders?: ManufacturingOrderListRelationFilter
    inventoryAllocations?: InventoryAllocationListRelationFilter
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientName?: SortOrder
    createdAt?: SortOrder
    shippedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: IntWithAggregatesFilter<"Order"> | number
    clientName?: StringWithAggregatesFilter<"Order"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    shippedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    status?: StringWithAggregatesFilter<"Order"> | string
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    boxesNeeded?: IntFilter<"OrderItem"> | number
    boxesAssembled?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    boxesNeeded?: SortOrder
    boxesAssembled?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    boxesNeeded?: IntFilter<"OrderItem"> | number
    boxesAssembled?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    boxesNeeded?: SortOrder
    boxesAssembled?: SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    boxesNeeded?: IntWithAggregatesFilter<"OrderItem"> | number
    boxesAssembled?: IntWithAggregatesFilter<"OrderItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type InventoryAllocationWhereInput = {
    AND?: InventoryAllocationWhereInput | InventoryAllocationWhereInput[]
    OR?: InventoryAllocationWhereInput[]
    NOT?: InventoryAllocationWhereInput | InventoryAllocationWhereInput[]
    id?: StringFilter<"InventoryAllocation"> | string
    orderId?: StringFilter<"InventoryAllocation"> | string
    elementId?: StringFilter<"InventoryAllocation"> | string
    amountAllocated?: IntFilter<"InventoryAllocation"> | number
    createdAt?: DateTimeFilter<"InventoryAllocation"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    element?: XOR<ElementScalarRelationFilter, ElementWhereInput>
  }

  export type InventoryAllocationOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    elementId?: SortOrder
    amountAllocated?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    element?: ElementOrderByWithRelationInput
  }

  export type InventoryAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId_elementId?: InventoryAllocationOrderIdElementIdCompoundUniqueInput
    AND?: InventoryAllocationWhereInput | InventoryAllocationWhereInput[]
    OR?: InventoryAllocationWhereInput[]
    NOT?: InventoryAllocationWhereInput | InventoryAllocationWhereInput[]
    orderId?: StringFilter<"InventoryAllocation"> | string
    elementId?: StringFilter<"InventoryAllocation"> | string
    amountAllocated?: IntFilter<"InventoryAllocation"> | number
    createdAt?: DateTimeFilter<"InventoryAllocation"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    element?: XOR<ElementScalarRelationFilter, ElementWhereInput>
  }, "id" | "orderId_elementId">

  export type InventoryAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    elementId?: SortOrder
    amountAllocated?: SortOrder
    createdAt?: SortOrder
    _count?: InventoryAllocationCountOrderByAggregateInput
    _avg?: InventoryAllocationAvgOrderByAggregateInput
    _max?: InventoryAllocationMaxOrderByAggregateInput
    _min?: InventoryAllocationMinOrderByAggregateInput
    _sum?: InventoryAllocationSumOrderByAggregateInput
  }

  export type InventoryAllocationScalarWhereWithAggregatesInput = {
    AND?: InventoryAllocationScalarWhereWithAggregatesInput | InventoryAllocationScalarWhereWithAggregatesInput[]
    OR?: InventoryAllocationScalarWhereWithAggregatesInput[]
    NOT?: InventoryAllocationScalarWhereWithAggregatesInput | InventoryAllocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryAllocation"> | string
    orderId?: StringWithAggregatesFilter<"InventoryAllocation"> | string
    elementId?: StringWithAggregatesFilter<"InventoryAllocation"> | string
    amountAllocated?: IntWithAggregatesFilter<"InventoryAllocation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InventoryAllocation"> | Date | string
  }

  export type ManufacturingOrderWhereInput = {
    AND?: ManufacturingOrderWhereInput | ManufacturingOrderWhereInput[]
    OR?: ManufacturingOrderWhereInput[]
    NOT?: ManufacturingOrderWhereInput | ManufacturingOrderWhereInput[]
    id?: StringFilter<"ManufacturingOrder"> | string
    orderId?: StringFilter<"ManufacturingOrder"> | string
    productId?: StringFilter<"ManufacturingOrder"> | string
    quantityToMake?: IntFilter<"ManufacturingOrder"> | number
    status?: StringFilter<"ManufacturingOrder"> | string
    createdAt?: DateTimeFilter<"ManufacturingOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ManufacturingOrder"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    requirements?: MaterialRequirementListRelationFilter
  }

  export type ManufacturingOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantityToMake?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    requirements?: MaterialRequirementOrderByRelationAggregateInput
  }

  export type ManufacturingOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ManufacturingOrderWhereInput | ManufacturingOrderWhereInput[]
    OR?: ManufacturingOrderWhereInput[]
    NOT?: ManufacturingOrderWhereInput | ManufacturingOrderWhereInput[]
    orderId?: StringFilter<"ManufacturingOrder"> | string
    productId?: StringFilter<"ManufacturingOrder"> | string
    quantityToMake?: IntFilter<"ManufacturingOrder"> | number
    status?: StringFilter<"ManufacturingOrder"> | string
    createdAt?: DateTimeFilter<"ManufacturingOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ManufacturingOrder"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    requirements?: MaterialRequirementListRelationFilter
  }, "id">

  export type ManufacturingOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantityToMake?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ManufacturingOrderCountOrderByAggregateInput
    _avg?: ManufacturingOrderAvgOrderByAggregateInput
    _max?: ManufacturingOrderMaxOrderByAggregateInput
    _min?: ManufacturingOrderMinOrderByAggregateInput
    _sum?: ManufacturingOrderSumOrderByAggregateInput
  }

  export type ManufacturingOrderScalarWhereWithAggregatesInput = {
    AND?: ManufacturingOrderScalarWhereWithAggregatesInput | ManufacturingOrderScalarWhereWithAggregatesInput[]
    OR?: ManufacturingOrderScalarWhereWithAggregatesInput[]
    NOT?: ManufacturingOrderScalarWhereWithAggregatesInput | ManufacturingOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ManufacturingOrder"> | string
    orderId?: StringWithAggregatesFilter<"ManufacturingOrder"> | string
    productId?: StringWithAggregatesFilter<"ManufacturingOrder"> | string
    quantityToMake?: IntWithAggregatesFilter<"ManufacturingOrder"> | number
    status?: StringWithAggregatesFilter<"ManufacturingOrder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ManufacturingOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ManufacturingOrder"> | Date | string
  }

  export type MaterialRequirementWhereInput = {
    AND?: MaterialRequirementWhereInput | MaterialRequirementWhereInput[]
    OR?: MaterialRequirementWhereInput[]
    NOT?: MaterialRequirementWhereInput | MaterialRequirementWhereInput[]
    id?: StringFilter<"MaterialRequirement"> | string
    manufacturingOrderId?: StringFilter<"MaterialRequirement"> | string
    elementId?: StringFilter<"MaterialRequirement"> | string
    quantityNeeded?: IntFilter<"MaterialRequirement"> | number
    quantityProduced?: IntFilter<"MaterialRequirement"> | number
    totalWeightGrams?: DecimalFilter<"MaterialRequirement"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"MaterialRequirement"> | Date | string
    manufacturingOrder?: XOR<ManufacturingOrderScalarRelationFilter, ManufacturingOrderWhereInput>
    element?: XOR<ElementScalarRelationFilter, ElementWhereInput>
  }

  export type MaterialRequirementOrderByWithRelationInput = {
    id?: SortOrder
    manufacturingOrderId?: SortOrder
    elementId?: SortOrder
    quantityNeeded?: SortOrder
    quantityProduced?: SortOrder
    totalWeightGrams?: SortOrder
    createdAt?: SortOrder
    manufacturingOrder?: ManufacturingOrderOrderByWithRelationInput
    element?: ElementOrderByWithRelationInput
  }

  export type MaterialRequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    manufacturingOrderId_elementId?: MaterialRequirementManufacturingOrderIdElementIdCompoundUniqueInput
    AND?: MaterialRequirementWhereInput | MaterialRequirementWhereInput[]
    OR?: MaterialRequirementWhereInput[]
    NOT?: MaterialRequirementWhereInput | MaterialRequirementWhereInput[]
    manufacturingOrderId?: StringFilter<"MaterialRequirement"> | string
    elementId?: StringFilter<"MaterialRequirement"> | string
    quantityNeeded?: IntFilter<"MaterialRequirement"> | number
    quantityProduced?: IntFilter<"MaterialRequirement"> | number
    totalWeightGrams?: DecimalFilter<"MaterialRequirement"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"MaterialRequirement"> | Date | string
    manufacturingOrder?: XOR<ManufacturingOrderScalarRelationFilter, ManufacturingOrderWhereInput>
    element?: XOR<ElementScalarRelationFilter, ElementWhereInput>
  }, "id" | "manufacturingOrderId_elementId">

  export type MaterialRequirementOrderByWithAggregationInput = {
    id?: SortOrder
    manufacturingOrderId?: SortOrder
    elementId?: SortOrder
    quantityNeeded?: SortOrder
    quantityProduced?: SortOrder
    totalWeightGrams?: SortOrder
    createdAt?: SortOrder
    _count?: MaterialRequirementCountOrderByAggregateInput
    _avg?: MaterialRequirementAvgOrderByAggregateInput
    _max?: MaterialRequirementMaxOrderByAggregateInput
    _min?: MaterialRequirementMinOrderByAggregateInput
    _sum?: MaterialRequirementSumOrderByAggregateInput
  }

  export type MaterialRequirementScalarWhereWithAggregatesInput = {
    AND?: MaterialRequirementScalarWhereWithAggregatesInput | MaterialRequirementScalarWhereWithAggregatesInput[]
    OR?: MaterialRequirementScalarWhereWithAggregatesInput[]
    NOT?: MaterialRequirementScalarWhereWithAggregatesInput | MaterialRequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaterialRequirement"> | string
    manufacturingOrderId?: StringWithAggregatesFilter<"MaterialRequirement"> | string
    elementId?: StringWithAggregatesFilter<"MaterialRequirement"> | string
    quantityNeeded?: IntWithAggregatesFilter<"MaterialRequirement"> | number
    quantityProduced?: IntWithAggregatesFilter<"MaterialRequirement"> | number
    totalWeightGrams?: DecimalWithAggregatesFilter<"MaterialRequirement"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"MaterialRequirement"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    password: string
    createdAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    password: string
    createdAt?: Date | string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    password: string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawMaterialCreateInput = {
    id?: string
    name: string
    unit?: string
    stockQty?: number
    createdAt?: Date | string
    elements?: ElementCreateNestedManyWithoutRawMaterialInput
    packagingForProducts?: ProductCreateNestedManyWithoutBoxRawMaterialInput
    transactions?: RawMaterialTransactionCreateNestedManyWithoutRawMaterialInput
  }

  export type RawMaterialUncheckedCreateInput = {
    id?: string
    name: string
    unit?: string
    stockQty?: number
    createdAt?: Date | string
    elements?: ElementUncheckedCreateNestedManyWithoutRawMaterialInput
    packagingForProducts?: ProductUncheckedCreateNestedManyWithoutBoxRawMaterialInput
    transactions?: RawMaterialTransactionUncheckedCreateNestedManyWithoutRawMaterialInput
  }

  export type RawMaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    stockQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: ElementUpdateManyWithoutRawMaterialNestedInput
    packagingForProducts?: ProductUpdateManyWithoutBoxRawMaterialNestedInput
    transactions?: RawMaterialTransactionUpdateManyWithoutRawMaterialNestedInput
  }

  export type RawMaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    stockQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: ElementUncheckedUpdateManyWithoutRawMaterialNestedInput
    packagingForProducts?: ProductUncheckedUpdateManyWithoutBoxRawMaterialNestedInput
    transactions?: RawMaterialTransactionUncheckedUpdateManyWithoutRawMaterialNestedInput
  }

  export type RawMaterialCreateManyInput = {
    id?: string
    name: string
    unit?: string
    stockQty?: number
    createdAt?: Date | string
  }

  export type RawMaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    stockQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawMaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    stockQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawMaterialTransactionCreateInput = {
    id?: string
    changeAmount: number
    reason: string
    createdAt?: Date | string
    rawMaterial: RawMaterialCreateNestedOneWithoutTransactionsInput
  }

  export type RawMaterialTransactionUncheckedCreateInput = {
    id?: string
    rawMaterialId: string
    changeAmount: number
    reason: string
    createdAt?: Date | string
  }

  export type RawMaterialTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawMaterial?: RawMaterialUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type RawMaterialTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rawMaterialId?: StringFieldUpdateOperationsInput | string
    changeAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawMaterialTransactionCreateManyInput = {
    id?: string
    rawMaterialId: string
    changeAmount: number
    reason: string
    createdAt?: Date | string
  }

  export type RawMaterialTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawMaterialTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rawMaterialId?: StringFieldUpdateOperationsInput | string
    changeAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementCreateInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    rawMaterial?: RawMaterialCreateNestedOneWithoutElementsInput
    productElements?: ProductElementCreateNestedManyWithoutElementInput
    inventory?: InventoryCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationCreateNestedManyWithoutElementInput
  }

  export type ElementUncheckedCreateInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    rawMaterialId?: string | null
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutElementInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementUncheckedCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationUncheckedCreateNestedManyWithoutElementInput
  }

  export type ElementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawMaterial?: RawMaterialUpdateOneWithoutElementsNestedInput
    productElements?: ProductElementUpdateManyWithoutElementNestedInput
    inventory?: InventoryUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUpdateManyWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    rawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutElementNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUncheckedUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type ElementCreateManyInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    rawMaterialId?: string | null
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type ElementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    rawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    imageUrl?: string | null
    createdAt?: Date | string
    boxRawMaterial?: RawMaterialCreateNestedOneWithoutPackagingForProductsInput
    productElements?: ProductElementCreateNestedManyWithoutProductInput
    productStock?: ProductStockCreateNestedOneWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    manufacturingOrders?: ManufacturingOrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    boxRawMaterialId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutProductInput
    productStock?: ProductStockUncheckedCreateNestedOneWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    manufacturingOrders?: ManufacturingOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boxRawMaterial?: RawMaterialUpdateOneWithoutPackagingForProductsNestedInput
    productElements?: ProductElementUpdateManyWithoutProductNestedInput
    productStock?: ProductStockUpdateOneWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    manufacturingOrders?: ManufacturingOrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    boxRawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutProductNestedInput
    productStock?: ProductStockUncheckedUpdateOneWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    manufacturingOrders?: ManufacturingOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    boxRawMaterialId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    boxRawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductElementCreateInput = {
    id?: string
    quantityNeeded?: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutProductElementsInput
    element: ElementCreateNestedOneWithoutProductElementsInput
  }

  export type ProductElementUncheckedCreateInput = {
    id?: string
    productId: string
    elementId: string
    quantityNeeded?: number
    createdAt?: Date | string
  }

  export type ProductElementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductElementsNestedInput
    element?: ElementUpdateOneRequiredWithoutProductElementsNestedInput
  }

  export type ProductElementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductElementCreateManyInput = {
    id?: string
    productId: string
    elementId: string
    quantityNeeded?: number
    createdAt?: Date | string
  }

  export type ProductElementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductElementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    id?: string
    totalAmount?: number
    updatedAt?: Date | string
    element: ElementCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    elementId: string
    totalAmount?: number
    updatedAt?: Date | string
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: ElementUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyInput = {
    id?: string
    elementId: string
    totalAmount?: number
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockCreateInput = {
    id?: string
    stockBoxedAmount?: number
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductStockInput
  }

  export type ProductStockUncheckedCreateInput = {
    id?: string
    productId: string
    stockBoxedAmount?: number
    updatedAt?: Date | string
  }

  export type ProductStockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockBoxedAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductStockNestedInput
  }

  export type ProductStockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    stockBoxedAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockCreateManyInput = {
    id?: string
    productId: string
    stockBoxedAmount?: number
    updatedAt?: Date | string
  }

  export type ProductStockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockBoxedAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    stockBoxedAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionCreateInput = {
    id?: string
    changeAmount: number
    reason: string
    createdAt?: Date | string
    element?: ElementCreateNestedOneWithoutInventoryTransactionsInput
  }

  export type InventoryTransactionUncheckedCreateInput = {
    id?: string
    elementId?: string | null
    changeAmount: number
    reason: string
    createdAt?: Date | string
  }

  export type InventoryTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeAmount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: ElementUpdateOneWithoutInventoryTransactionsNestedInput
  }

  export type InventoryTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    changeAmount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionCreateManyInput = {
    id?: string
    elementId?: string | null
    changeAmount: number
    reason: string
    createdAt?: Date | string
  }

  export type InventoryTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeAmount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    changeAmount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: number
    clientName: string
    createdAt?: Date | string
    shippedAt?: Date | string | null
    status?: string
    notes?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    manufacturingOrders?: ManufacturingOrderCreateNestedManyWithoutOrderInput
    inventoryAllocations?: InventoryAllocationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNumber: number
    clientName: string
    createdAt?: Date | string
    shippedAt?: Date | string | null
    status?: string
    notes?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    manufacturingOrders?: ManufacturingOrderUncheckedCreateNestedManyWithoutOrderInput
    inventoryAllocations?: InventoryAllocationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    clientName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    manufacturingOrders?: ManufacturingOrderUpdateManyWithoutOrderNestedInput
    inventoryAllocations?: InventoryAllocationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    clientName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    manufacturingOrders?: ManufacturingOrderUncheckedUpdateManyWithoutOrderNestedInput
    inventoryAllocations?: InventoryAllocationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNumber: number
    clientName: string
    createdAt?: Date | string
    shippedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    clientName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    clientName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    boxesNeeded: number
    boxesAssembled?: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    boxesNeeded: number
    boxesAssembled?: number
    createdAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    boxesNeeded?: IntFieldUpdateOperationsInput | number
    boxesAssembled?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    boxesNeeded?: IntFieldUpdateOperationsInput | number
    boxesAssembled?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    boxesNeeded: number
    boxesAssembled?: number
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    boxesNeeded?: IntFieldUpdateOperationsInput | number
    boxesAssembled?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    boxesNeeded?: IntFieldUpdateOperationsInput | number
    boxesAssembled?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAllocationCreateInput = {
    id?: string
    amountAllocated?: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutInventoryAllocationsInput
    element: ElementCreateNestedOneWithoutInventoryAllocationsInput
  }

  export type InventoryAllocationUncheckedCreateInput = {
    id?: string
    orderId: string
    elementId: string
    amountAllocated?: number
    createdAt?: Date | string
  }

  export type InventoryAllocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountAllocated?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutInventoryAllocationsNestedInput
    element?: ElementUpdateOneRequiredWithoutInventoryAllocationsNestedInput
  }

  export type InventoryAllocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    amountAllocated?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAllocationCreateManyInput = {
    id?: string
    orderId: string
    elementId: string
    amountAllocated?: number
    createdAt?: Date | string
  }

  export type InventoryAllocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountAllocated?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAllocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    amountAllocated?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManufacturingOrderCreateInput = {
    id?: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutManufacturingOrdersInput
    product: ProductCreateNestedOneWithoutManufacturingOrdersInput
    requirements?: MaterialRequirementCreateNestedManyWithoutManufacturingOrderInput
  }

  export type ManufacturingOrderUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: MaterialRequirementUncheckedCreateNestedManyWithoutManufacturingOrderInput
  }

  export type ManufacturingOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutManufacturingOrdersNestedInput
    product?: ProductUpdateOneRequiredWithoutManufacturingOrdersNestedInput
    requirements?: MaterialRequirementUpdateManyWithoutManufacturingOrderNestedInput
  }

  export type ManufacturingOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: MaterialRequirementUncheckedUpdateManyWithoutManufacturingOrderNestedInput
  }

  export type ManufacturingOrderCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManufacturingOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManufacturingOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequirementCreateInput = {
    id?: string
    quantityNeeded: number
    quantityProduced?: number
    totalWeightGrams: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    manufacturingOrder: ManufacturingOrderCreateNestedOneWithoutRequirementsInput
    element: ElementCreateNestedOneWithoutMaterialRequirementsInput
  }

  export type MaterialRequirementUncheckedCreateInput = {
    id?: string
    manufacturingOrderId: string
    elementId: string
    quantityNeeded: number
    quantityProduced?: number
    totalWeightGrams: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type MaterialRequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    quantityProduced?: IntFieldUpdateOperationsInput | number
    totalWeightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manufacturingOrder?: ManufacturingOrderUpdateOneRequiredWithoutRequirementsNestedInput
    element?: ElementUpdateOneRequiredWithoutMaterialRequirementsNestedInput
  }

  export type MaterialRequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    manufacturingOrderId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    quantityProduced?: IntFieldUpdateOperationsInput | number
    totalWeightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequirementCreateManyInput = {
    id?: string
    manufacturingOrderId: string
    elementId: string
    quantityNeeded: number
    quantityProduced?: number
    totalWeightGrams: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type MaterialRequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    quantityProduced?: IntFieldUpdateOperationsInput | number
    totalWeightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    manufacturingOrderId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    quantityProduced?: IntFieldUpdateOperationsInput | number
    totalWeightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ElementListRelationFilter = {
    every?: ElementWhereInput
    some?: ElementWhereInput
    none?: ElementWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type RawMaterialTransactionListRelationFilter = {
    every?: RawMaterialTransactionWhereInput
    some?: RawMaterialTransactionWhereInput
    none?: RawMaterialTransactionWhereInput
  }

  export type ElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RawMaterialTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RawMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    stockQty?: SortOrder
    createdAt?: SortOrder
  }

  export type RawMaterialAvgOrderByAggregateInput = {
    stockQty?: SortOrder
  }

  export type RawMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    stockQty?: SortOrder
    createdAt?: SortOrder
  }

  export type RawMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    stockQty?: SortOrder
    createdAt?: SortOrder
  }

  export type RawMaterialSumOrderByAggregateInput = {
    stockQty?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RawMaterialScalarRelationFilter = {
    is?: RawMaterialWhereInput
    isNot?: RawMaterialWhereInput
  }

  export type RawMaterialTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    changeAmount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type RawMaterialTransactionAvgOrderByAggregateInput = {
    changeAmount?: SortOrder
  }

  export type RawMaterialTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    changeAmount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type RawMaterialTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    changeAmount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type RawMaterialTransactionSumOrderByAggregateInput = {
    changeAmount?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type RawMaterialNullableScalarRelationFilter = {
    is?: RawMaterialWhereInput | null
    isNot?: RawMaterialWhereInput | null
  }

  export type ProductElementListRelationFilter = {
    every?: ProductElementWhereInput
    some?: ProductElementWhereInput
    none?: ProductElementWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type InventoryTransactionListRelationFilter = {
    every?: InventoryTransactionWhereInput
    some?: InventoryTransactionWhereInput
    none?: InventoryTransactionWhereInput
  }

  export type MaterialRequirementListRelationFilter = {
    every?: MaterialRequirementWhereInput
    some?: MaterialRequirementWhereInput
    none?: MaterialRequirementWhereInput
  }

  export type InventoryAllocationListRelationFilter = {
    every?: InventoryAllocationWhereInput
    some?: InventoryAllocationWhereInput
    none?: InventoryAllocationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProductElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialRequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ElementCountOrderByAggregateInput = {
    id?: SortOrder
    uniqueName?: SortOrder
    label?: SortOrder
    color?: SortOrder
    color2?: SortOrder
    isDualColor?: SortOrder
    material?: SortOrder
    rawMaterialId?: SortOrder
    weightGrams?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ElementAvgOrderByAggregateInput = {
    weightGrams?: SortOrder
  }

  export type ElementMaxOrderByAggregateInput = {
    id?: SortOrder
    uniqueName?: SortOrder
    label?: SortOrder
    color?: SortOrder
    color2?: SortOrder
    isDualColor?: SortOrder
    material?: SortOrder
    rawMaterialId?: SortOrder
    weightGrams?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ElementMinOrderByAggregateInput = {
    id?: SortOrder
    uniqueName?: SortOrder
    label?: SortOrder
    color?: SortOrder
    color2?: SortOrder
    isDualColor?: SortOrder
    material?: SortOrder
    rawMaterialId?: SortOrder
    weightGrams?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ElementSumOrderByAggregateInput = {
    weightGrams?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProductStockNullableScalarRelationFilter = {
    is?: ProductStockWhereInput | null
    isNot?: ProductStockWhereInput | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type ManufacturingOrderListRelationFilter = {
    every?: ManufacturingOrderWhereInput
    some?: ManufacturingOrderWhereInput
    none?: ManufacturingOrderWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManufacturingOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    category?: SortOrder
    label?: SortOrder
    unitsPerAssembly?: SortOrder
    unitsPerBox?: SortOrder
    boxRawMaterialId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    unitsPerAssembly?: SortOrder
    unitsPerBox?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    category?: SortOrder
    label?: SortOrder
    unitsPerAssembly?: SortOrder
    unitsPerBox?: SortOrder
    boxRawMaterialId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    category?: SortOrder
    label?: SortOrder
    unitsPerAssembly?: SortOrder
    unitsPerBox?: SortOrder
    boxRawMaterialId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    unitsPerAssembly?: SortOrder
    unitsPerBox?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ElementScalarRelationFilter = {
    is?: ElementWhereInput
    isNot?: ElementWhereInput
  }

  export type ProductElementProductIdElementIdCompoundUniqueInput = {
    productId: string
    elementId: string
  }

  export type ProductElementCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    elementId?: SortOrder
    quantityNeeded?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductElementAvgOrderByAggregateInput = {
    quantityNeeded?: SortOrder
  }

  export type ProductElementMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    elementId?: SortOrder
    quantityNeeded?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductElementMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    elementId?: SortOrder
    quantityNeeded?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductElementSumOrderByAggregateInput = {
    quantityNeeded?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    totalAmount?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    totalAmount?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    totalAmount?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type ProductStockCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    stockBoxedAmount?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductStockAvgOrderByAggregateInput = {
    stockBoxedAmount?: SortOrder
  }

  export type ProductStockMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    stockBoxedAmount?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductStockMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    stockBoxedAmount?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductStockSumOrderByAggregateInput = {
    stockBoxedAmount?: SortOrder
  }

  export type ElementNullableScalarRelationFilter = {
    is?: ElementWhereInput | null
    isNot?: ElementWhereInput | null
  }

  export type InventoryTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    changeAmount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryTransactionAvgOrderByAggregateInput = {
    changeAmount?: SortOrder
  }

  export type InventoryTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    changeAmount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    changeAmount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryTransactionSumOrderByAggregateInput = {
    changeAmount?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientName?: SortOrder
    createdAt?: SortOrder
    shippedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    orderNumber?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientName?: SortOrder
    createdAt?: SortOrder
    shippedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientName?: SortOrder
    createdAt?: SortOrder
    shippedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    orderNumber?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    boxesNeeded?: SortOrder
    boxesAssembled?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    boxesNeeded?: SortOrder
    boxesAssembled?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    boxesNeeded?: SortOrder
    boxesAssembled?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    boxesNeeded?: SortOrder
    boxesAssembled?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    boxesNeeded?: SortOrder
    boxesAssembled?: SortOrder
  }

  export type InventoryAllocationOrderIdElementIdCompoundUniqueInput = {
    orderId: string
    elementId: string
  }

  export type InventoryAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    elementId?: SortOrder
    amountAllocated?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryAllocationAvgOrderByAggregateInput = {
    amountAllocated?: SortOrder
  }

  export type InventoryAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    elementId?: SortOrder
    amountAllocated?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    elementId?: SortOrder
    amountAllocated?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryAllocationSumOrderByAggregateInput = {
    amountAllocated?: SortOrder
  }

  export type ManufacturingOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantityToMake?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManufacturingOrderAvgOrderByAggregateInput = {
    quantityToMake?: SortOrder
  }

  export type ManufacturingOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantityToMake?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManufacturingOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantityToMake?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManufacturingOrderSumOrderByAggregateInput = {
    quantityToMake?: SortOrder
  }

  export type ManufacturingOrderScalarRelationFilter = {
    is?: ManufacturingOrderWhereInput
    isNot?: ManufacturingOrderWhereInput
  }

  export type MaterialRequirementManufacturingOrderIdElementIdCompoundUniqueInput = {
    manufacturingOrderId: string
    elementId: string
  }

  export type MaterialRequirementCountOrderByAggregateInput = {
    id?: SortOrder
    manufacturingOrderId?: SortOrder
    elementId?: SortOrder
    quantityNeeded?: SortOrder
    quantityProduced?: SortOrder
    totalWeightGrams?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialRequirementAvgOrderByAggregateInput = {
    quantityNeeded?: SortOrder
    quantityProduced?: SortOrder
    totalWeightGrams?: SortOrder
  }

  export type MaterialRequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    manufacturingOrderId?: SortOrder
    elementId?: SortOrder
    quantityNeeded?: SortOrder
    quantityProduced?: SortOrder
    totalWeightGrams?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialRequirementMinOrderByAggregateInput = {
    id?: SortOrder
    manufacturingOrderId?: SortOrder
    elementId?: SortOrder
    quantityNeeded?: SortOrder
    quantityProduced?: SortOrder
    totalWeightGrams?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialRequirementSumOrderByAggregateInput = {
    quantityNeeded?: SortOrder
    quantityProduced?: SortOrder
    totalWeightGrams?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ElementCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<ElementCreateWithoutRawMaterialInput, ElementUncheckedCreateWithoutRawMaterialInput> | ElementCreateWithoutRawMaterialInput[] | ElementUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: ElementCreateOrConnectWithoutRawMaterialInput | ElementCreateOrConnectWithoutRawMaterialInput[]
    createMany?: ElementCreateManyRawMaterialInputEnvelope
    connect?: ElementWhereUniqueInput | ElementWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutBoxRawMaterialInput = {
    create?: XOR<ProductCreateWithoutBoxRawMaterialInput, ProductUncheckedCreateWithoutBoxRawMaterialInput> | ProductCreateWithoutBoxRawMaterialInput[] | ProductUncheckedCreateWithoutBoxRawMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBoxRawMaterialInput | ProductCreateOrConnectWithoutBoxRawMaterialInput[]
    createMany?: ProductCreateManyBoxRawMaterialInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type RawMaterialTransactionCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<RawMaterialTransactionCreateWithoutRawMaterialInput, RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput> | RawMaterialTransactionCreateWithoutRawMaterialInput[] | RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RawMaterialTransactionCreateOrConnectWithoutRawMaterialInput | RawMaterialTransactionCreateOrConnectWithoutRawMaterialInput[]
    createMany?: RawMaterialTransactionCreateManyRawMaterialInputEnvelope
    connect?: RawMaterialTransactionWhereUniqueInput | RawMaterialTransactionWhereUniqueInput[]
  }

  export type ElementUncheckedCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<ElementCreateWithoutRawMaterialInput, ElementUncheckedCreateWithoutRawMaterialInput> | ElementCreateWithoutRawMaterialInput[] | ElementUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: ElementCreateOrConnectWithoutRawMaterialInput | ElementCreateOrConnectWithoutRawMaterialInput[]
    createMany?: ElementCreateManyRawMaterialInputEnvelope
    connect?: ElementWhereUniqueInput | ElementWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBoxRawMaterialInput = {
    create?: XOR<ProductCreateWithoutBoxRawMaterialInput, ProductUncheckedCreateWithoutBoxRawMaterialInput> | ProductCreateWithoutBoxRawMaterialInput[] | ProductUncheckedCreateWithoutBoxRawMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBoxRawMaterialInput | ProductCreateOrConnectWithoutBoxRawMaterialInput[]
    createMany?: ProductCreateManyBoxRawMaterialInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type RawMaterialTransactionUncheckedCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<RawMaterialTransactionCreateWithoutRawMaterialInput, RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput> | RawMaterialTransactionCreateWithoutRawMaterialInput[] | RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RawMaterialTransactionCreateOrConnectWithoutRawMaterialInput | RawMaterialTransactionCreateOrConnectWithoutRawMaterialInput[]
    createMany?: RawMaterialTransactionCreateManyRawMaterialInputEnvelope
    connect?: RawMaterialTransactionWhereUniqueInput | RawMaterialTransactionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ElementUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<ElementCreateWithoutRawMaterialInput, ElementUncheckedCreateWithoutRawMaterialInput> | ElementCreateWithoutRawMaterialInput[] | ElementUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: ElementCreateOrConnectWithoutRawMaterialInput | ElementCreateOrConnectWithoutRawMaterialInput[]
    upsert?: ElementUpsertWithWhereUniqueWithoutRawMaterialInput | ElementUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: ElementCreateManyRawMaterialInputEnvelope
    set?: ElementWhereUniqueInput | ElementWhereUniqueInput[]
    disconnect?: ElementWhereUniqueInput | ElementWhereUniqueInput[]
    delete?: ElementWhereUniqueInput | ElementWhereUniqueInput[]
    connect?: ElementWhereUniqueInput | ElementWhereUniqueInput[]
    update?: ElementUpdateWithWhereUniqueWithoutRawMaterialInput | ElementUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: ElementUpdateManyWithWhereWithoutRawMaterialInput | ElementUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: ElementScalarWhereInput | ElementScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutBoxRawMaterialNestedInput = {
    create?: XOR<ProductCreateWithoutBoxRawMaterialInput, ProductUncheckedCreateWithoutBoxRawMaterialInput> | ProductCreateWithoutBoxRawMaterialInput[] | ProductUncheckedCreateWithoutBoxRawMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBoxRawMaterialInput | ProductCreateOrConnectWithoutBoxRawMaterialInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBoxRawMaterialInput | ProductUpsertWithWhereUniqueWithoutBoxRawMaterialInput[]
    createMany?: ProductCreateManyBoxRawMaterialInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBoxRawMaterialInput | ProductUpdateWithWhereUniqueWithoutBoxRawMaterialInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBoxRawMaterialInput | ProductUpdateManyWithWhereWithoutBoxRawMaterialInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type RawMaterialTransactionUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<RawMaterialTransactionCreateWithoutRawMaterialInput, RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput> | RawMaterialTransactionCreateWithoutRawMaterialInput[] | RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RawMaterialTransactionCreateOrConnectWithoutRawMaterialInput | RawMaterialTransactionCreateOrConnectWithoutRawMaterialInput[]
    upsert?: RawMaterialTransactionUpsertWithWhereUniqueWithoutRawMaterialInput | RawMaterialTransactionUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: RawMaterialTransactionCreateManyRawMaterialInputEnvelope
    set?: RawMaterialTransactionWhereUniqueInput | RawMaterialTransactionWhereUniqueInput[]
    disconnect?: RawMaterialTransactionWhereUniqueInput | RawMaterialTransactionWhereUniqueInput[]
    delete?: RawMaterialTransactionWhereUniqueInput | RawMaterialTransactionWhereUniqueInput[]
    connect?: RawMaterialTransactionWhereUniqueInput | RawMaterialTransactionWhereUniqueInput[]
    update?: RawMaterialTransactionUpdateWithWhereUniqueWithoutRawMaterialInput | RawMaterialTransactionUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: RawMaterialTransactionUpdateManyWithWhereWithoutRawMaterialInput | RawMaterialTransactionUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: RawMaterialTransactionScalarWhereInput | RawMaterialTransactionScalarWhereInput[]
  }

  export type ElementUncheckedUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<ElementCreateWithoutRawMaterialInput, ElementUncheckedCreateWithoutRawMaterialInput> | ElementCreateWithoutRawMaterialInput[] | ElementUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: ElementCreateOrConnectWithoutRawMaterialInput | ElementCreateOrConnectWithoutRawMaterialInput[]
    upsert?: ElementUpsertWithWhereUniqueWithoutRawMaterialInput | ElementUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: ElementCreateManyRawMaterialInputEnvelope
    set?: ElementWhereUniqueInput | ElementWhereUniqueInput[]
    disconnect?: ElementWhereUniqueInput | ElementWhereUniqueInput[]
    delete?: ElementWhereUniqueInput | ElementWhereUniqueInput[]
    connect?: ElementWhereUniqueInput | ElementWhereUniqueInput[]
    update?: ElementUpdateWithWhereUniqueWithoutRawMaterialInput | ElementUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: ElementUpdateManyWithWhereWithoutRawMaterialInput | ElementUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: ElementScalarWhereInput | ElementScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBoxRawMaterialNestedInput = {
    create?: XOR<ProductCreateWithoutBoxRawMaterialInput, ProductUncheckedCreateWithoutBoxRawMaterialInput> | ProductCreateWithoutBoxRawMaterialInput[] | ProductUncheckedCreateWithoutBoxRawMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBoxRawMaterialInput | ProductCreateOrConnectWithoutBoxRawMaterialInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBoxRawMaterialInput | ProductUpsertWithWhereUniqueWithoutBoxRawMaterialInput[]
    createMany?: ProductCreateManyBoxRawMaterialInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBoxRawMaterialInput | ProductUpdateWithWhereUniqueWithoutBoxRawMaterialInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBoxRawMaterialInput | ProductUpdateManyWithWhereWithoutBoxRawMaterialInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type RawMaterialTransactionUncheckedUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<RawMaterialTransactionCreateWithoutRawMaterialInput, RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput> | RawMaterialTransactionCreateWithoutRawMaterialInput[] | RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RawMaterialTransactionCreateOrConnectWithoutRawMaterialInput | RawMaterialTransactionCreateOrConnectWithoutRawMaterialInput[]
    upsert?: RawMaterialTransactionUpsertWithWhereUniqueWithoutRawMaterialInput | RawMaterialTransactionUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: RawMaterialTransactionCreateManyRawMaterialInputEnvelope
    set?: RawMaterialTransactionWhereUniqueInput | RawMaterialTransactionWhereUniqueInput[]
    disconnect?: RawMaterialTransactionWhereUniqueInput | RawMaterialTransactionWhereUniqueInput[]
    delete?: RawMaterialTransactionWhereUniqueInput | RawMaterialTransactionWhereUniqueInput[]
    connect?: RawMaterialTransactionWhereUniqueInput | RawMaterialTransactionWhereUniqueInput[]
    update?: RawMaterialTransactionUpdateWithWhereUniqueWithoutRawMaterialInput | RawMaterialTransactionUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: RawMaterialTransactionUpdateManyWithWhereWithoutRawMaterialInput | RawMaterialTransactionUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: RawMaterialTransactionScalarWhereInput | RawMaterialTransactionScalarWhereInput[]
  }

  export type RawMaterialCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<RawMaterialCreateWithoutTransactionsInput, RawMaterialUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: RawMaterialCreateOrConnectWithoutTransactionsInput
    connect?: RawMaterialWhereUniqueInput
  }

  export type RawMaterialUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<RawMaterialCreateWithoutTransactionsInput, RawMaterialUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: RawMaterialCreateOrConnectWithoutTransactionsInput
    upsert?: RawMaterialUpsertWithoutTransactionsInput
    connect?: RawMaterialWhereUniqueInput
    update?: XOR<XOR<RawMaterialUpdateToOneWithWhereWithoutTransactionsInput, RawMaterialUpdateWithoutTransactionsInput>, RawMaterialUncheckedUpdateWithoutTransactionsInput>
  }

  export type RawMaterialCreateNestedOneWithoutElementsInput = {
    create?: XOR<RawMaterialCreateWithoutElementsInput, RawMaterialUncheckedCreateWithoutElementsInput>
    connectOrCreate?: RawMaterialCreateOrConnectWithoutElementsInput
    connect?: RawMaterialWhereUniqueInput
  }

  export type ProductElementCreateNestedManyWithoutElementInput = {
    create?: XOR<ProductElementCreateWithoutElementInput, ProductElementUncheckedCreateWithoutElementInput> | ProductElementCreateWithoutElementInput[] | ProductElementUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ProductElementCreateOrConnectWithoutElementInput | ProductElementCreateOrConnectWithoutElementInput[]
    createMany?: ProductElementCreateManyElementInputEnvelope
    connect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutElementInput = {
    create?: XOR<InventoryCreateWithoutElementInput, InventoryUncheckedCreateWithoutElementInput> | InventoryCreateWithoutElementInput[] | InventoryUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutElementInput | InventoryCreateOrConnectWithoutElementInput[]
    createMany?: InventoryCreateManyElementInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutElementInput = {
    create?: XOR<InventoryTransactionCreateWithoutElementInput, InventoryTransactionUncheckedCreateWithoutElementInput> | InventoryTransactionCreateWithoutElementInput[] | InventoryTransactionUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutElementInput | InventoryTransactionCreateOrConnectWithoutElementInput[]
    createMany?: InventoryTransactionCreateManyElementInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type MaterialRequirementCreateNestedManyWithoutElementInput = {
    create?: XOR<MaterialRequirementCreateWithoutElementInput, MaterialRequirementUncheckedCreateWithoutElementInput> | MaterialRequirementCreateWithoutElementInput[] | MaterialRequirementUncheckedCreateWithoutElementInput[]
    connectOrCreate?: MaterialRequirementCreateOrConnectWithoutElementInput | MaterialRequirementCreateOrConnectWithoutElementInput[]
    createMany?: MaterialRequirementCreateManyElementInputEnvelope
    connect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
  }

  export type InventoryAllocationCreateNestedManyWithoutElementInput = {
    create?: XOR<InventoryAllocationCreateWithoutElementInput, InventoryAllocationUncheckedCreateWithoutElementInput> | InventoryAllocationCreateWithoutElementInput[] | InventoryAllocationUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryAllocationCreateOrConnectWithoutElementInput | InventoryAllocationCreateOrConnectWithoutElementInput[]
    createMany?: InventoryAllocationCreateManyElementInputEnvelope
    connect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
  }

  export type ProductElementUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<ProductElementCreateWithoutElementInput, ProductElementUncheckedCreateWithoutElementInput> | ProductElementCreateWithoutElementInput[] | ProductElementUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ProductElementCreateOrConnectWithoutElementInput | ProductElementCreateOrConnectWithoutElementInput[]
    createMany?: ProductElementCreateManyElementInputEnvelope
    connect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<InventoryCreateWithoutElementInput, InventoryUncheckedCreateWithoutElementInput> | InventoryCreateWithoutElementInput[] | InventoryUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutElementInput | InventoryCreateOrConnectWithoutElementInput[]
    createMany?: InventoryCreateManyElementInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<InventoryTransactionCreateWithoutElementInput, InventoryTransactionUncheckedCreateWithoutElementInput> | InventoryTransactionCreateWithoutElementInput[] | InventoryTransactionUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutElementInput | InventoryTransactionCreateOrConnectWithoutElementInput[]
    createMany?: InventoryTransactionCreateManyElementInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type MaterialRequirementUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<MaterialRequirementCreateWithoutElementInput, MaterialRequirementUncheckedCreateWithoutElementInput> | MaterialRequirementCreateWithoutElementInput[] | MaterialRequirementUncheckedCreateWithoutElementInput[]
    connectOrCreate?: MaterialRequirementCreateOrConnectWithoutElementInput | MaterialRequirementCreateOrConnectWithoutElementInput[]
    createMany?: MaterialRequirementCreateManyElementInputEnvelope
    connect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
  }

  export type InventoryAllocationUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<InventoryAllocationCreateWithoutElementInput, InventoryAllocationUncheckedCreateWithoutElementInput> | InventoryAllocationCreateWithoutElementInput[] | InventoryAllocationUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryAllocationCreateOrConnectWithoutElementInput | InventoryAllocationCreateOrConnectWithoutElementInput[]
    createMany?: InventoryAllocationCreateManyElementInputEnvelope
    connect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type RawMaterialUpdateOneWithoutElementsNestedInput = {
    create?: XOR<RawMaterialCreateWithoutElementsInput, RawMaterialUncheckedCreateWithoutElementsInput>
    connectOrCreate?: RawMaterialCreateOrConnectWithoutElementsInput
    upsert?: RawMaterialUpsertWithoutElementsInput
    disconnect?: RawMaterialWhereInput | boolean
    delete?: RawMaterialWhereInput | boolean
    connect?: RawMaterialWhereUniqueInput
    update?: XOR<XOR<RawMaterialUpdateToOneWithWhereWithoutElementsInput, RawMaterialUpdateWithoutElementsInput>, RawMaterialUncheckedUpdateWithoutElementsInput>
  }

  export type ProductElementUpdateManyWithoutElementNestedInput = {
    create?: XOR<ProductElementCreateWithoutElementInput, ProductElementUncheckedCreateWithoutElementInput> | ProductElementCreateWithoutElementInput[] | ProductElementUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ProductElementCreateOrConnectWithoutElementInput | ProductElementCreateOrConnectWithoutElementInput[]
    upsert?: ProductElementUpsertWithWhereUniqueWithoutElementInput | ProductElementUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: ProductElementCreateManyElementInputEnvelope
    set?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    disconnect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    delete?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    connect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    update?: ProductElementUpdateWithWhereUniqueWithoutElementInput | ProductElementUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: ProductElementUpdateManyWithWhereWithoutElementInput | ProductElementUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: ProductElementScalarWhereInput | ProductElementScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutElementNestedInput = {
    create?: XOR<InventoryCreateWithoutElementInput, InventoryUncheckedCreateWithoutElementInput> | InventoryCreateWithoutElementInput[] | InventoryUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutElementInput | InventoryCreateOrConnectWithoutElementInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutElementInput | InventoryUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: InventoryCreateManyElementInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutElementInput | InventoryUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutElementInput | InventoryUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutElementNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutElementInput, InventoryTransactionUncheckedCreateWithoutElementInput> | InventoryTransactionCreateWithoutElementInput[] | InventoryTransactionUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutElementInput | InventoryTransactionCreateOrConnectWithoutElementInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutElementInput | InventoryTransactionUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: InventoryTransactionCreateManyElementInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutElementInput | InventoryTransactionUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutElementInput | InventoryTransactionUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type MaterialRequirementUpdateManyWithoutElementNestedInput = {
    create?: XOR<MaterialRequirementCreateWithoutElementInput, MaterialRequirementUncheckedCreateWithoutElementInput> | MaterialRequirementCreateWithoutElementInput[] | MaterialRequirementUncheckedCreateWithoutElementInput[]
    connectOrCreate?: MaterialRequirementCreateOrConnectWithoutElementInput | MaterialRequirementCreateOrConnectWithoutElementInput[]
    upsert?: MaterialRequirementUpsertWithWhereUniqueWithoutElementInput | MaterialRequirementUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: MaterialRequirementCreateManyElementInputEnvelope
    set?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    disconnect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    delete?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    connect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    update?: MaterialRequirementUpdateWithWhereUniqueWithoutElementInput | MaterialRequirementUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: MaterialRequirementUpdateManyWithWhereWithoutElementInput | MaterialRequirementUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: MaterialRequirementScalarWhereInput | MaterialRequirementScalarWhereInput[]
  }

  export type InventoryAllocationUpdateManyWithoutElementNestedInput = {
    create?: XOR<InventoryAllocationCreateWithoutElementInput, InventoryAllocationUncheckedCreateWithoutElementInput> | InventoryAllocationCreateWithoutElementInput[] | InventoryAllocationUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryAllocationCreateOrConnectWithoutElementInput | InventoryAllocationCreateOrConnectWithoutElementInput[]
    upsert?: InventoryAllocationUpsertWithWhereUniqueWithoutElementInput | InventoryAllocationUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: InventoryAllocationCreateManyElementInputEnvelope
    set?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    disconnect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    delete?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    connect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    update?: InventoryAllocationUpdateWithWhereUniqueWithoutElementInput | InventoryAllocationUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: InventoryAllocationUpdateManyWithWhereWithoutElementInput | InventoryAllocationUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: InventoryAllocationScalarWhereInput | InventoryAllocationScalarWhereInput[]
  }

  export type ProductElementUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<ProductElementCreateWithoutElementInput, ProductElementUncheckedCreateWithoutElementInput> | ProductElementCreateWithoutElementInput[] | ProductElementUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ProductElementCreateOrConnectWithoutElementInput | ProductElementCreateOrConnectWithoutElementInput[]
    upsert?: ProductElementUpsertWithWhereUniqueWithoutElementInput | ProductElementUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: ProductElementCreateManyElementInputEnvelope
    set?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    disconnect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    delete?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    connect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    update?: ProductElementUpdateWithWhereUniqueWithoutElementInput | ProductElementUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: ProductElementUpdateManyWithWhereWithoutElementInput | ProductElementUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: ProductElementScalarWhereInput | ProductElementScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<InventoryCreateWithoutElementInput, InventoryUncheckedCreateWithoutElementInput> | InventoryCreateWithoutElementInput[] | InventoryUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutElementInput | InventoryCreateOrConnectWithoutElementInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutElementInput | InventoryUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: InventoryCreateManyElementInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutElementInput | InventoryUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutElementInput | InventoryUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutElementInput, InventoryTransactionUncheckedCreateWithoutElementInput> | InventoryTransactionCreateWithoutElementInput[] | InventoryTransactionUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutElementInput | InventoryTransactionCreateOrConnectWithoutElementInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutElementInput | InventoryTransactionUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: InventoryTransactionCreateManyElementInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutElementInput | InventoryTransactionUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutElementInput | InventoryTransactionUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type MaterialRequirementUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<MaterialRequirementCreateWithoutElementInput, MaterialRequirementUncheckedCreateWithoutElementInput> | MaterialRequirementCreateWithoutElementInput[] | MaterialRequirementUncheckedCreateWithoutElementInput[]
    connectOrCreate?: MaterialRequirementCreateOrConnectWithoutElementInput | MaterialRequirementCreateOrConnectWithoutElementInput[]
    upsert?: MaterialRequirementUpsertWithWhereUniqueWithoutElementInput | MaterialRequirementUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: MaterialRequirementCreateManyElementInputEnvelope
    set?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    disconnect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    delete?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    connect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    update?: MaterialRequirementUpdateWithWhereUniqueWithoutElementInput | MaterialRequirementUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: MaterialRequirementUpdateManyWithWhereWithoutElementInput | MaterialRequirementUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: MaterialRequirementScalarWhereInput | MaterialRequirementScalarWhereInput[]
  }

  export type InventoryAllocationUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<InventoryAllocationCreateWithoutElementInput, InventoryAllocationUncheckedCreateWithoutElementInput> | InventoryAllocationCreateWithoutElementInput[] | InventoryAllocationUncheckedCreateWithoutElementInput[]
    connectOrCreate?: InventoryAllocationCreateOrConnectWithoutElementInput | InventoryAllocationCreateOrConnectWithoutElementInput[]
    upsert?: InventoryAllocationUpsertWithWhereUniqueWithoutElementInput | InventoryAllocationUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: InventoryAllocationCreateManyElementInputEnvelope
    set?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    disconnect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    delete?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    connect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    update?: InventoryAllocationUpdateWithWhereUniqueWithoutElementInput | InventoryAllocationUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: InventoryAllocationUpdateManyWithWhereWithoutElementInput | InventoryAllocationUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: InventoryAllocationScalarWhereInput | InventoryAllocationScalarWhereInput[]
  }

  export type RawMaterialCreateNestedOneWithoutPackagingForProductsInput = {
    create?: XOR<RawMaterialCreateWithoutPackagingForProductsInput, RawMaterialUncheckedCreateWithoutPackagingForProductsInput>
    connectOrCreate?: RawMaterialCreateOrConnectWithoutPackagingForProductsInput
    connect?: RawMaterialWhereUniqueInput
  }

  export type ProductElementCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductElementCreateWithoutProductInput, ProductElementUncheckedCreateWithoutProductInput> | ProductElementCreateWithoutProductInput[] | ProductElementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductElementCreateOrConnectWithoutProductInput | ProductElementCreateOrConnectWithoutProductInput[]
    createMany?: ProductElementCreateManyProductInputEnvelope
    connect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
  }

  export type ProductStockCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput
    connect?: ProductStockWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ManufacturingOrderCreateNestedManyWithoutProductInput = {
    create?: XOR<ManufacturingOrderCreateWithoutProductInput, ManufacturingOrderUncheckedCreateWithoutProductInput> | ManufacturingOrderCreateWithoutProductInput[] | ManufacturingOrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ManufacturingOrderCreateOrConnectWithoutProductInput | ManufacturingOrderCreateOrConnectWithoutProductInput[]
    createMany?: ManufacturingOrderCreateManyProductInputEnvelope
    connect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
  }

  export type ProductElementUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductElementCreateWithoutProductInput, ProductElementUncheckedCreateWithoutProductInput> | ProductElementCreateWithoutProductInput[] | ProductElementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductElementCreateOrConnectWithoutProductInput | ProductElementCreateOrConnectWithoutProductInput[]
    createMany?: ProductElementCreateManyProductInputEnvelope
    connect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
  }

  export type ProductStockUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput
    connect?: ProductStockWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ManufacturingOrderUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ManufacturingOrderCreateWithoutProductInput, ManufacturingOrderUncheckedCreateWithoutProductInput> | ManufacturingOrderCreateWithoutProductInput[] | ManufacturingOrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ManufacturingOrderCreateOrConnectWithoutProductInput | ManufacturingOrderCreateOrConnectWithoutProductInput[]
    createMany?: ManufacturingOrderCreateManyProductInputEnvelope
    connect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RawMaterialUpdateOneWithoutPackagingForProductsNestedInput = {
    create?: XOR<RawMaterialCreateWithoutPackagingForProductsInput, RawMaterialUncheckedCreateWithoutPackagingForProductsInput>
    connectOrCreate?: RawMaterialCreateOrConnectWithoutPackagingForProductsInput
    upsert?: RawMaterialUpsertWithoutPackagingForProductsInput
    disconnect?: RawMaterialWhereInput | boolean
    delete?: RawMaterialWhereInput | boolean
    connect?: RawMaterialWhereUniqueInput
    update?: XOR<XOR<RawMaterialUpdateToOneWithWhereWithoutPackagingForProductsInput, RawMaterialUpdateWithoutPackagingForProductsInput>, RawMaterialUncheckedUpdateWithoutPackagingForProductsInput>
  }

  export type ProductElementUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductElementCreateWithoutProductInput, ProductElementUncheckedCreateWithoutProductInput> | ProductElementCreateWithoutProductInput[] | ProductElementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductElementCreateOrConnectWithoutProductInput | ProductElementCreateOrConnectWithoutProductInput[]
    upsert?: ProductElementUpsertWithWhereUniqueWithoutProductInput | ProductElementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductElementCreateManyProductInputEnvelope
    set?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    disconnect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    delete?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    connect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    update?: ProductElementUpdateWithWhereUniqueWithoutProductInput | ProductElementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductElementUpdateManyWithWhereWithoutProductInput | ProductElementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductElementScalarWhereInput | ProductElementScalarWhereInput[]
  }

  export type ProductStockUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput
    upsert?: ProductStockUpsertWithoutProductInput
    disconnect?: ProductStockWhereInput | boolean
    delete?: ProductStockWhereInput | boolean
    connect?: ProductStockWhereUniqueInput
    update?: XOR<XOR<ProductStockUpdateToOneWithWhereWithoutProductInput, ProductStockUpdateWithoutProductInput>, ProductStockUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ManufacturingOrderUpdateManyWithoutProductNestedInput = {
    create?: XOR<ManufacturingOrderCreateWithoutProductInput, ManufacturingOrderUncheckedCreateWithoutProductInput> | ManufacturingOrderCreateWithoutProductInput[] | ManufacturingOrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ManufacturingOrderCreateOrConnectWithoutProductInput | ManufacturingOrderCreateOrConnectWithoutProductInput[]
    upsert?: ManufacturingOrderUpsertWithWhereUniqueWithoutProductInput | ManufacturingOrderUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ManufacturingOrderCreateManyProductInputEnvelope
    set?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    disconnect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    delete?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    connect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    update?: ManufacturingOrderUpdateWithWhereUniqueWithoutProductInput | ManufacturingOrderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ManufacturingOrderUpdateManyWithWhereWithoutProductInput | ManufacturingOrderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ManufacturingOrderScalarWhereInput | ManufacturingOrderScalarWhereInput[]
  }

  export type ProductElementUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductElementCreateWithoutProductInput, ProductElementUncheckedCreateWithoutProductInput> | ProductElementCreateWithoutProductInput[] | ProductElementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductElementCreateOrConnectWithoutProductInput | ProductElementCreateOrConnectWithoutProductInput[]
    upsert?: ProductElementUpsertWithWhereUniqueWithoutProductInput | ProductElementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductElementCreateManyProductInputEnvelope
    set?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    disconnect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    delete?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    connect?: ProductElementWhereUniqueInput | ProductElementWhereUniqueInput[]
    update?: ProductElementUpdateWithWhereUniqueWithoutProductInput | ProductElementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductElementUpdateManyWithWhereWithoutProductInput | ProductElementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductElementScalarWhereInput | ProductElementScalarWhereInput[]
  }

  export type ProductStockUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput
    upsert?: ProductStockUpsertWithoutProductInput
    disconnect?: ProductStockWhereInput | boolean
    delete?: ProductStockWhereInput | boolean
    connect?: ProductStockWhereUniqueInput
    update?: XOR<XOR<ProductStockUpdateToOneWithWhereWithoutProductInput, ProductStockUpdateWithoutProductInput>, ProductStockUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ManufacturingOrderUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ManufacturingOrderCreateWithoutProductInput, ManufacturingOrderUncheckedCreateWithoutProductInput> | ManufacturingOrderCreateWithoutProductInput[] | ManufacturingOrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ManufacturingOrderCreateOrConnectWithoutProductInput | ManufacturingOrderCreateOrConnectWithoutProductInput[]
    upsert?: ManufacturingOrderUpsertWithWhereUniqueWithoutProductInput | ManufacturingOrderUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ManufacturingOrderCreateManyProductInputEnvelope
    set?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    disconnect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    delete?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    connect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    update?: ManufacturingOrderUpdateWithWhereUniqueWithoutProductInput | ManufacturingOrderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ManufacturingOrderUpdateManyWithWhereWithoutProductInput | ManufacturingOrderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ManufacturingOrderScalarWhereInput | ManufacturingOrderScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductElementsInput = {
    create?: XOR<ProductCreateWithoutProductElementsInput, ProductUncheckedCreateWithoutProductElementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductElementsInput
    connect?: ProductWhereUniqueInput
  }

  export type ElementCreateNestedOneWithoutProductElementsInput = {
    create?: XOR<ElementCreateWithoutProductElementsInput, ElementUncheckedCreateWithoutProductElementsInput>
    connectOrCreate?: ElementCreateOrConnectWithoutProductElementsInput
    connect?: ElementWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductElementsNestedInput = {
    create?: XOR<ProductCreateWithoutProductElementsInput, ProductUncheckedCreateWithoutProductElementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductElementsInput
    upsert?: ProductUpsertWithoutProductElementsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductElementsInput, ProductUpdateWithoutProductElementsInput>, ProductUncheckedUpdateWithoutProductElementsInput>
  }

  export type ElementUpdateOneRequiredWithoutProductElementsNestedInput = {
    create?: XOR<ElementCreateWithoutProductElementsInput, ElementUncheckedCreateWithoutProductElementsInput>
    connectOrCreate?: ElementCreateOrConnectWithoutProductElementsInput
    upsert?: ElementUpsertWithoutProductElementsInput
    connect?: ElementWhereUniqueInput
    update?: XOR<XOR<ElementUpdateToOneWithWhereWithoutProductElementsInput, ElementUpdateWithoutProductElementsInput>, ElementUncheckedUpdateWithoutProductElementsInput>
  }

  export type ElementCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ElementCreateWithoutInventoryInput, ElementUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ElementCreateOrConnectWithoutInventoryInput
    connect?: ElementWhereUniqueInput
  }

  export type ElementUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<ElementCreateWithoutInventoryInput, ElementUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ElementCreateOrConnectWithoutInventoryInput
    upsert?: ElementUpsertWithoutInventoryInput
    connect?: ElementWhereUniqueInput
    update?: XOR<XOR<ElementUpdateToOneWithWhereWithoutInventoryInput, ElementUpdateWithoutInventoryInput>, ElementUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductCreateNestedOneWithoutProductStockInput = {
    create?: XOR<ProductCreateWithoutProductStockInput, ProductUncheckedCreateWithoutProductStockInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductStockInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductStockNestedInput = {
    create?: XOR<ProductCreateWithoutProductStockInput, ProductUncheckedCreateWithoutProductStockInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductStockInput
    upsert?: ProductUpsertWithoutProductStockInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductStockInput, ProductUpdateWithoutProductStockInput>, ProductUncheckedUpdateWithoutProductStockInput>
  }

  export type ElementCreateNestedOneWithoutInventoryTransactionsInput = {
    create?: XOR<ElementCreateWithoutInventoryTransactionsInput, ElementUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: ElementCreateOrConnectWithoutInventoryTransactionsInput
    connect?: ElementWhereUniqueInput
  }

  export type ElementUpdateOneWithoutInventoryTransactionsNestedInput = {
    create?: XOR<ElementCreateWithoutInventoryTransactionsInput, ElementUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: ElementCreateOrConnectWithoutInventoryTransactionsInput
    upsert?: ElementUpsertWithoutInventoryTransactionsInput
    disconnect?: ElementWhereInput | boolean
    delete?: ElementWhereInput | boolean
    connect?: ElementWhereUniqueInput
    update?: XOR<XOR<ElementUpdateToOneWithWhereWithoutInventoryTransactionsInput, ElementUpdateWithoutInventoryTransactionsInput>, ElementUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ManufacturingOrderCreateNestedManyWithoutOrderInput = {
    create?: XOR<ManufacturingOrderCreateWithoutOrderInput, ManufacturingOrderUncheckedCreateWithoutOrderInput> | ManufacturingOrderCreateWithoutOrderInput[] | ManufacturingOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ManufacturingOrderCreateOrConnectWithoutOrderInput | ManufacturingOrderCreateOrConnectWithoutOrderInput[]
    createMany?: ManufacturingOrderCreateManyOrderInputEnvelope
    connect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
  }

  export type InventoryAllocationCreateNestedManyWithoutOrderInput = {
    create?: XOR<InventoryAllocationCreateWithoutOrderInput, InventoryAllocationUncheckedCreateWithoutOrderInput> | InventoryAllocationCreateWithoutOrderInput[] | InventoryAllocationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InventoryAllocationCreateOrConnectWithoutOrderInput | InventoryAllocationCreateOrConnectWithoutOrderInput[]
    createMany?: InventoryAllocationCreateManyOrderInputEnvelope
    connect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ManufacturingOrderUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ManufacturingOrderCreateWithoutOrderInput, ManufacturingOrderUncheckedCreateWithoutOrderInput> | ManufacturingOrderCreateWithoutOrderInput[] | ManufacturingOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ManufacturingOrderCreateOrConnectWithoutOrderInput | ManufacturingOrderCreateOrConnectWithoutOrderInput[]
    createMany?: ManufacturingOrderCreateManyOrderInputEnvelope
    connect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
  }

  export type InventoryAllocationUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<InventoryAllocationCreateWithoutOrderInput, InventoryAllocationUncheckedCreateWithoutOrderInput> | InventoryAllocationCreateWithoutOrderInput[] | InventoryAllocationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InventoryAllocationCreateOrConnectWithoutOrderInput | InventoryAllocationCreateOrConnectWithoutOrderInput[]
    createMany?: InventoryAllocationCreateManyOrderInputEnvelope
    connect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ManufacturingOrderUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ManufacturingOrderCreateWithoutOrderInput, ManufacturingOrderUncheckedCreateWithoutOrderInput> | ManufacturingOrderCreateWithoutOrderInput[] | ManufacturingOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ManufacturingOrderCreateOrConnectWithoutOrderInput | ManufacturingOrderCreateOrConnectWithoutOrderInput[]
    upsert?: ManufacturingOrderUpsertWithWhereUniqueWithoutOrderInput | ManufacturingOrderUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ManufacturingOrderCreateManyOrderInputEnvelope
    set?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    disconnect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    delete?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    connect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    update?: ManufacturingOrderUpdateWithWhereUniqueWithoutOrderInput | ManufacturingOrderUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ManufacturingOrderUpdateManyWithWhereWithoutOrderInput | ManufacturingOrderUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ManufacturingOrderScalarWhereInput | ManufacturingOrderScalarWhereInput[]
  }

  export type InventoryAllocationUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InventoryAllocationCreateWithoutOrderInput, InventoryAllocationUncheckedCreateWithoutOrderInput> | InventoryAllocationCreateWithoutOrderInput[] | InventoryAllocationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InventoryAllocationCreateOrConnectWithoutOrderInput | InventoryAllocationCreateOrConnectWithoutOrderInput[]
    upsert?: InventoryAllocationUpsertWithWhereUniqueWithoutOrderInput | InventoryAllocationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InventoryAllocationCreateManyOrderInputEnvelope
    set?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    disconnect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    delete?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    connect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    update?: InventoryAllocationUpdateWithWhereUniqueWithoutOrderInput | InventoryAllocationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InventoryAllocationUpdateManyWithWhereWithoutOrderInput | InventoryAllocationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InventoryAllocationScalarWhereInput | InventoryAllocationScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ManufacturingOrderUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ManufacturingOrderCreateWithoutOrderInput, ManufacturingOrderUncheckedCreateWithoutOrderInput> | ManufacturingOrderCreateWithoutOrderInput[] | ManufacturingOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ManufacturingOrderCreateOrConnectWithoutOrderInput | ManufacturingOrderCreateOrConnectWithoutOrderInput[]
    upsert?: ManufacturingOrderUpsertWithWhereUniqueWithoutOrderInput | ManufacturingOrderUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ManufacturingOrderCreateManyOrderInputEnvelope
    set?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    disconnect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    delete?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    connect?: ManufacturingOrderWhereUniqueInput | ManufacturingOrderWhereUniqueInput[]
    update?: ManufacturingOrderUpdateWithWhereUniqueWithoutOrderInput | ManufacturingOrderUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ManufacturingOrderUpdateManyWithWhereWithoutOrderInput | ManufacturingOrderUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ManufacturingOrderScalarWhereInput | ManufacturingOrderScalarWhereInput[]
  }

  export type InventoryAllocationUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InventoryAllocationCreateWithoutOrderInput, InventoryAllocationUncheckedCreateWithoutOrderInput> | InventoryAllocationCreateWithoutOrderInput[] | InventoryAllocationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InventoryAllocationCreateOrConnectWithoutOrderInput | InventoryAllocationCreateOrConnectWithoutOrderInput[]
    upsert?: InventoryAllocationUpsertWithWhereUniqueWithoutOrderInput | InventoryAllocationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InventoryAllocationCreateManyOrderInputEnvelope
    set?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    disconnect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    delete?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    connect?: InventoryAllocationWhereUniqueInput | InventoryAllocationWhereUniqueInput[]
    update?: InventoryAllocationUpdateWithWhereUniqueWithoutOrderInput | InventoryAllocationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InventoryAllocationUpdateManyWithWhereWithoutOrderInput | InventoryAllocationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InventoryAllocationScalarWhereInput | InventoryAllocationScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemsInput, OrderUpdateWithoutOrderItemsInput>, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderCreateNestedOneWithoutInventoryAllocationsInput = {
    create?: XOR<OrderCreateWithoutInventoryAllocationsInput, OrderUncheckedCreateWithoutInventoryAllocationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInventoryAllocationsInput
    connect?: OrderWhereUniqueInput
  }

  export type ElementCreateNestedOneWithoutInventoryAllocationsInput = {
    create?: XOR<ElementCreateWithoutInventoryAllocationsInput, ElementUncheckedCreateWithoutInventoryAllocationsInput>
    connectOrCreate?: ElementCreateOrConnectWithoutInventoryAllocationsInput
    connect?: ElementWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutInventoryAllocationsNestedInput = {
    create?: XOR<OrderCreateWithoutInventoryAllocationsInput, OrderUncheckedCreateWithoutInventoryAllocationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInventoryAllocationsInput
    upsert?: OrderUpsertWithoutInventoryAllocationsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInventoryAllocationsInput, OrderUpdateWithoutInventoryAllocationsInput>, OrderUncheckedUpdateWithoutInventoryAllocationsInput>
  }

  export type ElementUpdateOneRequiredWithoutInventoryAllocationsNestedInput = {
    create?: XOR<ElementCreateWithoutInventoryAllocationsInput, ElementUncheckedCreateWithoutInventoryAllocationsInput>
    connectOrCreate?: ElementCreateOrConnectWithoutInventoryAllocationsInput
    upsert?: ElementUpsertWithoutInventoryAllocationsInput
    connect?: ElementWhereUniqueInput
    update?: XOR<XOR<ElementUpdateToOneWithWhereWithoutInventoryAllocationsInput, ElementUpdateWithoutInventoryAllocationsInput>, ElementUncheckedUpdateWithoutInventoryAllocationsInput>
  }

  export type OrderCreateNestedOneWithoutManufacturingOrdersInput = {
    create?: XOR<OrderCreateWithoutManufacturingOrdersInput, OrderUncheckedCreateWithoutManufacturingOrdersInput>
    connectOrCreate?: OrderCreateOrConnectWithoutManufacturingOrdersInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutManufacturingOrdersInput = {
    create?: XOR<ProductCreateWithoutManufacturingOrdersInput, ProductUncheckedCreateWithoutManufacturingOrdersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutManufacturingOrdersInput
    connect?: ProductWhereUniqueInput
  }

  export type MaterialRequirementCreateNestedManyWithoutManufacturingOrderInput = {
    create?: XOR<MaterialRequirementCreateWithoutManufacturingOrderInput, MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput> | MaterialRequirementCreateWithoutManufacturingOrderInput[] | MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput[]
    connectOrCreate?: MaterialRequirementCreateOrConnectWithoutManufacturingOrderInput | MaterialRequirementCreateOrConnectWithoutManufacturingOrderInput[]
    createMany?: MaterialRequirementCreateManyManufacturingOrderInputEnvelope
    connect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
  }

  export type MaterialRequirementUncheckedCreateNestedManyWithoutManufacturingOrderInput = {
    create?: XOR<MaterialRequirementCreateWithoutManufacturingOrderInput, MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput> | MaterialRequirementCreateWithoutManufacturingOrderInput[] | MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput[]
    connectOrCreate?: MaterialRequirementCreateOrConnectWithoutManufacturingOrderInput | MaterialRequirementCreateOrConnectWithoutManufacturingOrderInput[]
    createMany?: MaterialRequirementCreateManyManufacturingOrderInputEnvelope
    connect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
  }

  export type OrderUpdateOneRequiredWithoutManufacturingOrdersNestedInput = {
    create?: XOR<OrderCreateWithoutManufacturingOrdersInput, OrderUncheckedCreateWithoutManufacturingOrdersInput>
    connectOrCreate?: OrderCreateOrConnectWithoutManufacturingOrdersInput
    upsert?: OrderUpsertWithoutManufacturingOrdersInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutManufacturingOrdersInput, OrderUpdateWithoutManufacturingOrdersInput>, OrderUncheckedUpdateWithoutManufacturingOrdersInput>
  }

  export type ProductUpdateOneRequiredWithoutManufacturingOrdersNestedInput = {
    create?: XOR<ProductCreateWithoutManufacturingOrdersInput, ProductUncheckedCreateWithoutManufacturingOrdersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutManufacturingOrdersInput
    upsert?: ProductUpsertWithoutManufacturingOrdersInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutManufacturingOrdersInput, ProductUpdateWithoutManufacturingOrdersInput>, ProductUncheckedUpdateWithoutManufacturingOrdersInput>
  }

  export type MaterialRequirementUpdateManyWithoutManufacturingOrderNestedInput = {
    create?: XOR<MaterialRequirementCreateWithoutManufacturingOrderInput, MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput> | MaterialRequirementCreateWithoutManufacturingOrderInput[] | MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput[]
    connectOrCreate?: MaterialRequirementCreateOrConnectWithoutManufacturingOrderInput | MaterialRequirementCreateOrConnectWithoutManufacturingOrderInput[]
    upsert?: MaterialRequirementUpsertWithWhereUniqueWithoutManufacturingOrderInput | MaterialRequirementUpsertWithWhereUniqueWithoutManufacturingOrderInput[]
    createMany?: MaterialRequirementCreateManyManufacturingOrderInputEnvelope
    set?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    disconnect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    delete?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    connect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    update?: MaterialRequirementUpdateWithWhereUniqueWithoutManufacturingOrderInput | MaterialRequirementUpdateWithWhereUniqueWithoutManufacturingOrderInput[]
    updateMany?: MaterialRequirementUpdateManyWithWhereWithoutManufacturingOrderInput | MaterialRequirementUpdateManyWithWhereWithoutManufacturingOrderInput[]
    deleteMany?: MaterialRequirementScalarWhereInput | MaterialRequirementScalarWhereInput[]
  }

  export type MaterialRequirementUncheckedUpdateManyWithoutManufacturingOrderNestedInput = {
    create?: XOR<MaterialRequirementCreateWithoutManufacturingOrderInput, MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput> | MaterialRequirementCreateWithoutManufacturingOrderInput[] | MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput[]
    connectOrCreate?: MaterialRequirementCreateOrConnectWithoutManufacturingOrderInput | MaterialRequirementCreateOrConnectWithoutManufacturingOrderInput[]
    upsert?: MaterialRequirementUpsertWithWhereUniqueWithoutManufacturingOrderInput | MaterialRequirementUpsertWithWhereUniqueWithoutManufacturingOrderInput[]
    createMany?: MaterialRequirementCreateManyManufacturingOrderInputEnvelope
    set?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    disconnect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    delete?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    connect?: MaterialRequirementWhereUniqueInput | MaterialRequirementWhereUniqueInput[]
    update?: MaterialRequirementUpdateWithWhereUniqueWithoutManufacturingOrderInput | MaterialRequirementUpdateWithWhereUniqueWithoutManufacturingOrderInput[]
    updateMany?: MaterialRequirementUpdateManyWithWhereWithoutManufacturingOrderInput | MaterialRequirementUpdateManyWithWhereWithoutManufacturingOrderInput[]
    deleteMany?: MaterialRequirementScalarWhereInput | MaterialRequirementScalarWhereInput[]
  }

  export type ManufacturingOrderCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<ManufacturingOrderCreateWithoutRequirementsInput, ManufacturingOrderUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: ManufacturingOrderCreateOrConnectWithoutRequirementsInput
    connect?: ManufacturingOrderWhereUniqueInput
  }

  export type ElementCreateNestedOneWithoutMaterialRequirementsInput = {
    create?: XOR<ElementCreateWithoutMaterialRequirementsInput, ElementUncheckedCreateWithoutMaterialRequirementsInput>
    connectOrCreate?: ElementCreateOrConnectWithoutMaterialRequirementsInput
    connect?: ElementWhereUniqueInput
  }

  export type ManufacturingOrderUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<ManufacturingOrderCreateWithoutRequirementsInput, ManufacturingOrderUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: ManufacturingOrderCreateOrConnectWithoutRequirementsInput
    upsert?: ManufacturingOrderUpsertWithoutRequirementsInput
    connect?: ManufacturingOrderWhereUniqueInput
    update?: XOR<XOR<ManufacturingOrderUpdateToOneWithWhereWithoutRequirementsInput, ManufacturingOrderUpdateWithoutRequirementsInput>, ManufacturingOrderUncheckedUpdateWithoutRequirementsInput>
  }

  export type ElementUpdateOneRequiredWithoutMaterialRequirementsNestedInput = {
    create?: XOR<ElementCreateWithoutMaterialRequirementsInput, ElementUncheckedCreateWithoutMaterialRequirementsInput>
    connectOrCreate?: ElementCreateOrConnectWithoutMaterialRequirementsInput
    upsert?: ElementUpsertWithoutMaterialRequirementsInput
    connect?: ElementWhereUniqueInput
    update?: XOR<XOR<ElementUpdateToOneWithWhereWithoutMaterialRequirementsInput, ElementUpdateWithoutMaterialRequirementsInput>, ElementUncheckedUpdateWithoutMaterialRequirementsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ElementCreateWithoutRawMaterialInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementCreateNestedManyWithoutElementInput
    inventory?: InventoryCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationCreateNestedManyWithoutElementInput
  }

  export type ElementUncheckedCreateWithoutRawMaterialInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutElementInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementUncheckedCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationUncheckedCreateNestedManyWithoutElementInput
  }

  export type ElementCreateOrConnectWithoutRawMaterialInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutRawMaterialInput, ElementUncheckedCreateWithoutRawMaterialInput>
  }

  export type ElementCreateManyRawMaterialInputEnvelope = {
    data: ElementCreateManyRawMaterialInput | ElementCreateManyRawMaterialInput[]
  }

  export type ProductCreateWithoutBoxRawMaterialInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementCreateNestedManyWithoutProductInput
    productStock?: ProductStockCreateNestedOneWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    manufacturingOrders?: ManufacturingOrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBoxRawMaterialInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutProductInput
    productStock?: ProductStockUncheckedCreateNestedOneWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    manufacturingOrders?: ManufacturingOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBoxRawMaterialInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBoxRawMaterialInput, ProductUncheckedCreateWithoutBoxRawMaterialInput>
  }

  export type ProductCreateManyBoxRawMaterialInputEnvelope = {
    data: ProductCreateManyBoxRawMaterialInput | ProductCreateManyBoxRawMaterialInput[]
  }

  export type RawMaterialTransactionCreateWithoutRawMaterialInput = {
    id?: string
    changeAmount: number
    reason: string
    createdAt?: Date | string
  }

  export type RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput = {
    id?: string
    changeAmount: number
    reason: string
    createdAt?: Date | string
  }

  export type RawMaterialTransactionCreateOrConnectWithoutRawMaterialInput = {
    where: RawMaterialTransactionWhereUniqueInput
    create: XOR<RawMaterialTransactionCreateWithoutRawMaterialInput, RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput>
  }

  export type RawMaterialTransactionCreateManyRawMaterialInputEnvelope = {
    data: RawMaterialTransactionCreateManyRawMaterialInput | RawMaterialTransactionCreateManyRawMaterialInput[]
  }

  export type ElementUpsertWithWhereUniqueWithoutRawMaterialInput = {
    where: ElementWhereUniqueInput
    update: XOR<ElementUpdateWithoutRawMaterialInput, ElementUncheckedUpdateWithoutRawMaterialInput>
    create: XOR<ElementCreateWithoutRawMaterialInput, ElementUncheckedCreateWithoutRawMaterialInput>
  }

  export type ElementUpdateWithWhereUniqueWithoutRawMaterialInput = {
    where: ElementWhereUniqueInput
    data: XOR<ElementUpdateWithoutRawMaterialInput, ElementUncheckedUpdateWithoutRawMaterialInput>
  }

  export type ElementUpdateManyWithWhereWithoutRawMaterialInput = {
    where: ElementScalarWhereInput
    data: XOR<ElementUpdateManyMutationInput, ElementUncheckedUpdateManyWithoutRawMaterialInput>
  }

  export type ElementScalarWhereInput = {
    AND?: ElementScalarWhereInput | ElementScalarWhereInput[]
    OR?: ElementScalarWhereInput[]
    NOT?: ElementScalarWhereInput | ElementScalarWhereInput[]
    id?: StringFilter<"Element"> | string
    uniqueName?: StringFilter<"Element"> | string
    label?: StringFilter<"Element"> | string
    color?: StringFilter<"Element"> | string
    color2?: StringNullableFilter<"Element"> | string | null
    isDualColor?: BoolFilter<"Element"> | boolean
    material?: StringFilter<"Element"> | string
    rawMaterialId?: StringNullableFilter<"Element"> | string | null
    weightGrams?: DecimalFilter<"Element"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableFilter<"Element"> | string | null
    createdAt?: DateTimeFilter<"Element"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutBoxRawMaterialInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBoxRawMaterialInput, ProductUncheckedUpdateWithoutBoxRawMaterialInput>
    create: XOR<ProductCreateWithoutBoxRawMaterialInput, ProductUncheckedCreateWithoutBoxRawMaterialInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBoxRawMaterialInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBoxRawMaterialInput, ProductUncheckedUpdateWithoutBoxRawMaterialInput>
  }

  export type ProductUpdateManyWithWhereWithoutBoxRawMaterialInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBoxRawMaterialInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    serialNumber?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    label?: StringFilter<"Product"> | string
    unitsPerAssembly?: IntFilter<"Product"> | number
    unitsPerBox?: IntFilter<"Product"> | number
    boxRawMaterialId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type RawMaterialTransactionUpsertWithWhereUniqueWithoutRawMaterialInput = {
    where: RawMaterialTransactionWhereUniqueInput
    update: XOR<RawMaterialTransactionUpdateWithoutRawMaterialInput, RawMaterialTransactionUncheckedUpdateWithoutRawMaterialInput>
    create: XOR<RawMaterialTransactionCreateWithoutRawMaterialInput, RawMaterialTransactionUncheckedCreateWithoutRawMaterialInput>
  }

  export type RawMaterialTransactionUpdateWithWhereUniqueWithoutRawMaterialInput = {
    where: RawMaterialTransactionWhereUniqueInput
    data: XOR<RawMaterialTransactionUpdateWithoutRawMaterialInput, RawMaterialTransactionUncheckedUpdateWithoutRawMaterialInput>
  }

  export type RawMaterialTransactionUpdateManyWithWhereWithoutRawMaterialInput = {
    where: RawMaterialTransactionScalarWhereInput
    data: XOR<RawMaterialTransactionUpdateManyMutationInput, RawMaterialTransactionUncheckedUpdateManyWithoutRawMaterialInput>
  }

  export type RawMaterialTransactionScalarWhereInput = {
    AND?: RawMaterialTransactionScalarWhereInput | RawMaterialTransactionScalarWhereInput[]
    OR?: RawMaterialTransactionScalarWhereInput[]
    NOT?: RawMaterialTransactionScalarWhereInput | RawMaterialTransactionScalarWhereInput[]
    id?: StringFilter<"RawMaterialTransaction"> | string
    rawMaterialId?: StringFilter<"RawMaterialTransaction"> | string
    changeAmount?: FloatFilter<"RawMaterialTransaction"> | number
    reason?: StringFilter<"RawMaterialTransaction"> | string
    createdAt?: DateTimeFilter<"RawMaterialTransaction"> | Date | string
  }

  export type RawMaterialCreateWithoutTransactionsInput = {
    id?: string
    name: string
    unit?: string
    stockQty?: number
    createdAt?: Date | string
    elements?: ElementCreateNestedManyWithoutRawMaterialInput
    packagingForProducts?: ProductCreateNestedManyWithoutBoxRawMaterialInput
  }

  export type RawMaterialUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    unit?: string
    stockQty?: number
    createdAt?: Date | string
    elements?: ElementUncheckedCreateNestedManyWithoutRawMaterialInput
    packagingForProducts?: ProductUncheckedCreateNestedManyWithoutBoxRawMaterialInput
  }

  export type RawMaterialCreateOrConnectWithoutTransactionsInput = {
    where: RawMaterialWhereUniqueInput
    create: XOR<RawMaterialCreateWithoutTransactionsInput, RawMaterialUncheckedCreateWithoutTransactionsInput>
  }

  export type RawMaterialUpsertWithoutTransactionsInput = {
    update: XOR<RawMaterialUpdateWithoutTransactionsInput, RawMaterialUncheckedUpdateWithoutTransactionsInput>
    create: XOR<RawMaterialCreateWithoutTransactionsInput, RawMaterialUncheckedCreateWithoutTransactionsInput>
    where?: RawMaterialWhereInput
  }

  export type RawMaterialUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: RawMaterialWhereInput
    data: XOR<RawMaterialUpdateWithoutTransactionsInput, RawMaterialUncheckedUpdateWithoutTransactionsInput>
  }

  export type RawMaterialUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    stockQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: ElementUpdateManyWithoutRawMaterialNestedInput
    packagingForProducts?: ProductUpdateManyWithoutBoxRawMaterialNestedInput
  }

  export type RawMaterialUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    stockQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: ElementUncheckedUpdateManyWithoutRawMaterialNestedInput
    packagingForProducts?: ProductUncheckedUpdateManyWithoutBoxRawMaterialNestedInput
  }

  export type RawMaterialCreateWithoutElementsInput = {
    id?: string
    name: string
    unit?: string
    stockQty?: number
    createdAt?: Date | string
    packagingForProducts?: ProductCreateNestedManyWithoutBoxRawMaterialInput
    transactions?: RawMaterialTransactionCreateNestedManyWithoutRawMaterialInput
  }

  export type RawMaterialUncheckedCreateWithoutElementsInput = {
    id?: string
    name: string
    unit?: string
    stockQty?: number
    createdAt?: Date | string
    packagingForProducts?: ProductUncheckedCreateNestedManyWithoutBoxRawMaterialInput
    transactions?: RawMaterialTransactionUncheckedCreateNestedManyWithoutRawMaterialInput
  }

  export type RawMaterialCreateOrConnectWithoutElementsInput = {
    where: RawMaterialWhereUniqueInput
    create: XOR<RawMaterialCreateWithoutElementsInput, RawMaterialUncheckedCreateWithoutElementsInput>
  }

  export type ProductElementCreateWithoutElementInput = {
    id?: string
    quantityNeeded?: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutProductElementsInput
  }

  export type ProductElementUncheckedCreateWithoutElementInput = {
    id?: string
    productId: string
    quantityNeeded?: number
    createdAt?: Date | string
  }

  export type ProductElementCreateOrConnectWithoutElementInput = {
    where: ProductElementWhereUniqueInput
    create: XOR<ProductElementCreateWithoutElementInput, ProductElementUncheckedCreateWithoutElementInput>
  }

  export type ProductElementCreateManyElementInputEnvelope = {
    data: ProductElementCreateManyElementInput | ProductElementCreateManyElementInput[]
  }

  export type InventoryCreateWithoutElementInput = {
    id?: string
    totalAmount?: number
    updatedAt?: Date | string
  }

  export type InventoryUncheckedCreateWithoutElementInput = {
    id?: string
    totalAmount?: number
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutElementInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutElementInput, InventoryUncheckedCreateWithoutElementInput>
  }

  export type InventoryCreateManyElementInputEnvelope = {
    data: InventoryCreateManyElementInput | InventoryCreateManyElementInput[]
  }

  export type InventoryTransactionCreateWithoutElementInput = {
    id?: string
    changeAmount: number
    reason: string
    createdAt?: Date | string
  }

  export type InventoryTransactionUncheckedCreateWithoutElementInput = {
    id?: string
    changeAmount: number
    reason: string
    createdAt?: Date | string
  }

  export type InventoryTransactionCreateOrConnectWithoutElementInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutElementInput, InventoryTransactionUncheckedCreateWithoutElementInput>
  }

  export type InventoryTransactionCreateManyElementInputEnvelope = {
    data: InventoryTransactionCreateManyElementInput | InventoryTransactionCreateManyElementInput[]
  }

  export type MaterialRequirementCreateWithoutElementInput = {
    id?: string
    quantityNeeded: number
    quantityProduced?: number
    totalWeightGrams: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    manufacturingOrder: ManufacturingOrderCreateNestedOneWithoutRequirementsInput
  }

  export type MaterialRequirementUncheckedCreateWithoutElementInput = {
    id?: string
    manufacturingOrderId: string
    quantityNeeded: number
    quantityProduced?: number
    totalWeightGrams: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type MaterialRequirementCreateOrConnectWithoutElementInput = {
    where: MaterialRequirementWhereUniqueInput
    create: XOR<MaterialRequirementCreateWithoutElementInput, MaterialRequirementUncheckedCreateWithoutElementInput>
  }

  export type MaterialRequirementCreateManyElementInputEnvelope = {
    data: MaterialRequirementCreateManyElementInput | MaterialRequirementCreateManyElementInput[]
  }

  export type InventoryAllocationCreateWithoutElementInput = {
    id?: string
    amountAllocated?: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutInventoryAllocationsInput
  }

  export type InventoryAllocationUncheckedCreateWithoutElementInput = {
    id?: string
    orderId: string
    amountAllocated?: number
    createdAt?: Date | string
  }

  export type InventoryAllocationCreateOrConnectWithoutElementInput = {
    where: InventoryAllocationWhereUniqueInput
    create: XOR<InventoryAllocationCreateWithoutElementInput, InventoryAllocationUncheckedCreateWithoutElementInput>
  }

  export type InventoryAllocationCreateManyElementInputEnvelope = {
    data: InventoryAllocationCreateManyElementInput | InventoryAllocationCreateManyElementInput[]
  }

  export type RawMaterialUpsertWithoutElementsInput = {
    update: XOR<RawMaterialUpdateWithoutElementsInput, RawMaterialUncheckedUpdateWithoutElementsInput>
    create: XOR<RawMaterialCreateWithoutElementsInput, RawMaterialUncheckedCreateWithoutElementsInput>
    where?: RawMaterialWhereInput
  }

  export type RawMaterialUpdateToOneWithWhereWithoutElementsInput = {
    where?: RawMaterialWhereInput
    data: XOR<RawMaterialUpdateWithoutElementsInput, RawMaterialUncheckedUpdateWithoutElementsInput>
  }

  export type RawMaterialUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    stockQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packagingForProducts?: ProductUpdateManyWithoutBoxRawMaterialNestedInput
    transactions?: RawMaterialTransactionUpdateManyWithoutRawMaterialNestedInput
  }

  export type RawMaterialUncheckedUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    stockQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packagingForProducts?: ProductUncheckedUpdateManyWithoutBoxRawMaterialNestedInput
    transactions?: RawMaterialTransactionUncheckedUpdateManyWithoutRawMaterialNestedInput
  }

  export type ProductElementUpsertWithWhereUniqueWithoutElementInput = {
    where: ProductElementWhereUniqueInput
    update: XOR<ProductElementUpdateWithoutElementInput, ProductElementUncheckedUpdateWithoutElementInput>
    create: XOR<ProductElementCreateWithoutElementInput, ProductElementUncheckedCreateWithoutElementInput>
  }

  export type ProductElementUpdateWithWhereUniqueWithoutElementInput = {
    where: ProductElementWhereUniqueInput
    data: XOR<ProductElementUpdateWithoutElementInput, ProductElementUncheckedUpdateWithoutElementInput>
  }

  export type ProductElementUpdateManyWithWhereWithoutElementInput = {
    where: ProductElementScalarWhereInput
    data: XOR<ProductElementUpdateManyMutationInput, ProductElementUncheckedUpdateManyWithoutElementInput>
  }

  export type ProductElementScalarWhereInput = {
    AND?: ProductElementScalarWhereInput | ProductElementScalarWhereInput[]
    OR?: ProductElementScalarWhereInput[]
    NOT?: ProductElementScalarWhereInput | ProductElementScalarWhereInput[]
    id?: StringFilter<"ProductElement"> | string
    productId?: StringFilter<"ProductElement"> | string
    elementId?: StringFilter<"ProductElement"> | string
    quantityNeeded?: IntFilter<"ProductElement"> | number
    createdAt?: DateTimeFilter<"ProductElement"> | Date | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutElementInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutElementInput, InventoryUncheckedUpdateWithoutElementInput>
    create: XOR<InventoryCreateWithoutElementInput, InventoryUncheckedCreateWithoutElementInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutElementInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutElementInput, InventoryUncheckedUpdateWithoutElementInput>
  }

  export type InventoryUpdateManyWithWhereWithoutElementInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutElementInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: StringFilter<"Inventory"> | string
    elementId?: StringFilter<"Inventory"> | string
    totalAmount?: IntFilter<"Inventory"> | number
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutElementInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutElementInput, InventoryTransactionUncheckedUpdateWithoutElementInput>
    create: XOR<InventoryTransactionCreateWithoutElementInput, InventoryTransactionUncheckedCreateWithoutElementInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutElementInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutElementInput, InventoryTransactionUncheckedUpdateWithoutElementInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutElementInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutElementInput>
  }

  export type InventoryTransactionScalarWhereInput = {
    AND?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    OR?: InventoryTransactionScalarWhereInput[]
    NOT?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    id?: StringFilter<"InventoryTransaction"> | string
    elementId?: StringNullableFilter<"InventoryTransaction"> | string | null
    changeAmount?: IntFilter<"InventoryTransaction"> | number
    reason?: StringFilter<"InventoryTransaction"> | string
    createdAt?: DateTimeFilter<"InventoryTransaction"> | Date | string
  }

  export type MaterialRequirementUpsertWithWhereUniqueWithoutElementInput = {
    where: MaterialRequirementWhereUniqueInput
    update: XOR<MaterialRequirementUpdateWithoutElementInput, MaterialRequirementUncheckedUpdateWithoutElementInput>
    create: XOR<MaterialRequirementCreateWithoutElementInput, MaterialRequirementUncheckedCreateWithoutElementInput>
  }

  export type MaterialRequirementUpdateWithWhereUniqueWithoutElementInput = {
    where: MaterialRequirementWhereUniqueInput
    data: XOR<MaterialRequirementUpdateWithoutElementInput, MaterialRequirementUncheckedUpdateWithoutElementInput>
  }

  export type MaterialRequirementUpdateManyWithWhereWithoutElementInput = {
    where: MaterialRequirementScalarWhereInput
    data: XOR<MaterialRequirementUpdateManyMutationInput, MaterialRequirementUncheckedUpdateManyWithoutElementInput>
  }

  export type MaterialRequirementScalarWhereInput = {
    AND?: MaterialRequirementScalarWhereInput | MaterialRequirementScalarWhereInput[]
    OR?: MaterialRequirementScalarWhereInput[]
    NOT?: MaterialRequirementScalarWhereInput | MaterialRequirementScalarWhereInput[]
    id?: StringFilter<"MaterialRequirement"> | string
    manufacturingOrderId?: StringFilter<"MaterialRequirement"> | string
    elementId?: StringFilter<"MaterialRequirement"> | string
    quantityNeeded?: IntFilter<"MaterialRequirement"> | number
    quantityProduced?: IntFilter<"MaterialRequirement"> | number
    totalWeightGrams?: DecimalFilter<"MaterialRequirement"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"MaterialRequirement"> | Date | string
  }

  export type InventoryAllocationUpsertWithWhereUniqueWithoutElementInput = {
    where: InventoryAllocationWhereUniqueInput
    update: XOR<InventoryAllocationUpdateWithoutElementInput, InventoryAllocationUncheckedUpdateWithoutElementInput>
    create: XOR<InventoryAllocationCreateWithoutElementInput, InventoryAllocationUncheckedCreateWithoutElementInput>
  }

  export type InventoryAllocationUpdateWithWhereUniqueWithoutElementInput = {
    where: InventoryAllocationWhereUniqueInput
    data: XOR<InventoryAllocationUpdateWithoutElementInput, InventoryAllocationUncheckedUpdateWithoutElementInput>
  }

  export type InventoryAllocationUpdateManyWithWhereWithoutElementInput = {
    where: InventoryAllocationScalarWhereInput
    data: XOR<InventoryAllocationUpdateManyMutationInput, InventoryAllocationUncheckedUpdateManyWithoutElementInput>
  }

  export type InventoryAllocationScalarWhereInput = {
    AND?: InventoryAllocationScalarWhereInput | InventoryAllocationScalarWhereInput[]
    OR?: InventoryAllocationScalarWhereInput[]
    NOT?: InventoryAllocationScalarWhereInput | InventoryAllocationScalarWhereInput[]
    id?: StringFilter<"InventoryAllocation"> | string
    orderId?: StringFilter<"InventoryAllocation"> | string
    elementId?: StringFilter<"InventoryAllocation"> | string
    amountAllocated?: IntFilter<"InventoryAllocation"> | number
    createdAt?: DateTimeFilter<"InventoryAllocation"> | Date | string
  }

  export type RawMaterialCreateWithoutPackagingForProductsInput = {
    id?: string
    name: string
    unit?: string
    stockQty?: number
    createdAt?: Date | string
    elements?: ElementCreateNestedManyWithoutRawMaterialInput
    transactions?: RawMaterialTransactionCreateNestedManyWithoutRawMaterialInput
  }

  export type RawMaterialUncheckedCreateWithoutPackagingForProductsInput = {
    id?: string
    name: string
    unit?: string
    stockQty?: number
    createdAt?: Date | string
    elements?: ElementUncheckedCreateNestedManyWithoutRawMaterialInput
    transactions?: RawMaterialTransactionUncheckedCreateNestedManyWithoutRawMaterialInput
  }

  export type RawMaterialCreateOrConnectWithoutPackagingForProductsInput = {
    where: RawMaterialWhereUniqueInput
    create: XOR<RawMaterialCreateWithoutPackagingForProductsInput, RawMaterialUncheckedCreateWithoutPackagingForProductsInput>
  }

  export type ProductElementCreateWithoutProductInput = {
    id?: string
    quantityNeeded?: number
    createdAt?: Date | string
    element: ElementCreateNestedOneWithoutProductElementsInput
  }

  export type ProductElementUncheckedCreateWithoutProductInput = {
    id?: string
    elementId: string
    quantityNeeded?: number
    createdAt?: Date | string
  }

  export type ProductElementCreateOrConnectWithoutProductInput = {
    where: ProductElementWhereUniqueInput
    create: XOR<ProductElementCreateWithoutProductInput, ProductElementUncheckedCreateWithoutProductInput>
  }

  export type ProductElementCreateManyProductInputEnvelope = {
    data: ProductElementCreateManyProductInput | ProductElementCreateManyProductInput[]
  }

  export type ProductStockCreateWithoutProductInput = {
    id?: string
    stockBoxedAmount?: number
    updatedAt?: Date | string
  }

  export type ProductStockUncheckedCreateWithoutProductInput = {
    id?: string
    stockBoxedAmount?: number
    updatedAt?: Date | string
  }

  export type ProductStockCreateOrConnectWithoutProductInput = {
    where: ProductStockWhereUniqueInput
    create: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    boxesNeeded: number
    boxesAssembled?: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    boxesNeeded: number
    boxesAssembled?: number
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
  }

  export type ManufacturingOrderCreateWithoutProductInput = {
    id?: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutManufacturingOrdersInput
    requirements?: MaterialRequirementCreateNestedManyWithoutManufacturingOrderInput
  }

  export type ManufacturingOrderUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: MaterialRequirementUncheckedCreateNestedManyWithoutManufacturingOrderInput
  }

  export type ManufacturingOrderCreateOrConnectWithoutProductInput = {
    where: ManufacturingOrderWhereUniqueInput
    create: XOR<ManufacturingOrderCreateWithoutProductInput, ManufacturingOrderUncheckedCreateWithoutProductInput>
  }

  export type ManufacturingOrderCreateManyProductInputEnvelope = {
    data: ManufacturingOrderCreateManyProductInput | ManufacturingOrderCreateManyProductInput[]
  }

  export type RawMaterialUpsertWithoutPackagingForProductsInput = {
    update: XOR<RawMaterialUpdateWithoutPackagingForProductsInput, RawMaterialUncheckedUpdateWithoutPackagingForProductsInput>
    create: XOR<RawMaterialCreateWithoutPackagingForProductsInput, RawMaterialUncheckedCreateWithoutPackagingForProductsInput>
    where?: RawMaterialWhereInput
  }

  export type RawMaterialUpdateToOneWithWhereWithoutPackagingForProductsInput = {
    where?: RawMaterialWhereInput
    data: XOR<RawMaterialUpdateWithoutPackagingForProductsInput, RawMaterialUncheckedUpdateWithoutPackagingForProductsInput>
  }

  export type RawMaterialUpdateWithoutPackagingForProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    stockQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: ElementUpdateManyWithoutRawMaterialNestedInput
    transactions?: RawMaterialTransactionUpdateManyWithoutRawMaterialNestedInput
  }

  export type RawMaterialUncheckedUpdateWithoutPackagingForProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    stockQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: ElementUncheckedUpdateManyWithoutRawMaterialNestedInput
    transactions?: RawMaterialTransactionUncheckedUpdateManyWithoutRawMaterialNestedInput
  }

  export type ProductElementUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductElementWhereUniqueInput
    update: XOR<ProductElementUpdateWithoutProductInput, ProductElementUncheckedUpdateWithoutProductInput>
    create: XOR<ProductElementCreateWithoutProductInput, ProductElementUncheckedCreateWithoutProductInput>
  }

  export type ProductElementUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductElementWhereUniqueInput
    data: XOR<ProductElementUpdateWithoutProductInput, ProductElementUncheckedUpdateWithoutProductInput>
  }

  export type ProductElementUpdateManyWithWhereWithoutProductInput = {
    where: ProductElementScalarWhereInput
    data: XOR<ProductElementUpdateManyMutationInput, ProductElementUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductStockUpsertWithoutProductInput = {
    update: XOR<ProductStockUpdateWithoutProductInput, ProductStockUncheckedUpdateWithoutProductInput>
    create: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput>
    where?: ProductStockWhereInput
  }

  export type ProductStockUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductStockWhereInput
    data: XOR<ProductStockUpdateWithoutProductInput, ProductStockUncheckedUpdateWithoutProductInput>
  }

  export type ProductStockUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockBoxedAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockBoxedAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    boxesNeeded?: IntFilter<"OrderItem"> | number
    boxesAssembled?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type ManufacturingOrderUpsertWithWhereUniqueWithoutProductInput = {
    where: ManufacturingOrderWhereUniqueInput
    update: XOR<ManufacturingOrderUpdateWithoutProductInput, ManufacturingOrderUncheckedUpdateWithoutProductInput>
    create: XOR<ManufacturingOrderCreateWithoutProductInput, ManufacturingOrderUncheckedCreateWithoutProductInput>
  }

  export type ManufacturingOrderUpdateWithWhereUniqueWithoutProductInput = {
    where: ManufacturingOrderWhereUniqueInput
    data: XOR<ManufacturingOrderUpdateWithoutProductInput, ManufacturingOrderUncheckedUpdateWithoutProductInput>
  }

  export type ManufacturingOrderUpdateManyWithWhereWithoutProductInput = {
    where: ManufacturingOrderScalarWhereInput
    data: XOR<ManufacturingOrderUpdateManyMutationInput, ManufacturingOrderUncheckedUpdateManyWithoutProductInput>
  }

  export type ManufacturingOrderScalarWhereInput = {
    AND?: ManufacturingOrderScalarWhereInput | ManufacturingOrderScalarWhereInput[]
    OR?: ManufacturingOrderScalarWhereInput[]
    NOT?: ManufacturingOrderScalarWhereInput | ManufacturingOrderScalarWhereInput[]
    id?: StringFilter<"ManufacturingOrder"> | string
    orderId?: StringFilter<"ManufacturingOrder"> | string
    productId?: StringFilter<"ManufacturingOrder"> | string
    quantityToMake?: IntFilter<"ManufacturingOrder"> | number
    status?: StringFilter<"ManufacturingOrder"> | string
    createdAt?: DateTimeFilter<"ManufacturingOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ManufacturingOrder"> | Date | string
  }

  export type ProductCreateWithoutProductElementsInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    imageUrl?: string | null
    createdAt?: Date | string
    boxRawMaterial?: RawMaterialCreateNestedOneWithoutPackagingForProductsInput
    productStock?: ProductStockCreateNestedOneWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    manufacturingOrders?: ManufacturingOrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductElementsInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    boxRawMaterialId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    productStock?: ProductStockUncheckedCreateNestedOneWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    manufacturingOrders?: ManufacturingOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductElementsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductElementsInput, ProductUncheckedCreateWithoutProductElementsInput>
  }

  export type ElementCreateWithoutProductElementsInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    rawMaterial?: RawMaterialCreateNestedOneWithoutElementsInput
    inventory?: InventoryCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationCreateNestedManyWithoutElementInput
  }

  export type ElementUncheckedCreateWithoutProductElementsInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    rawMaterialId?: string | null
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementUncheckedCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationUncheckedCreateNestedManyWithoutElementInput
  }

  export type ElementCreateOrConnectWithoutProductElementsInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutProductElementsInput, ElementUncheckedCreateWithoutProductElementsInput>
  }

  export type ProductUpsertWithoutProductElementsInput = {
    update: XOR<ProductUpdateWithoutProductElementsInput, ProductUncheckedUpdateWithoutProductElementsInput>
    create: XOR<ProductCreateWithoutProductElementsInput, ProductUncheckedCreateWithoutProductElementsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductElementsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductElementsInput, ProductUncheckedUpdateWithoutProductElementsInput>
  }

  export type ProductUpdateWithoutProductElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boxRawMaterial?: RawMaterialUpdateOneWithoutPackagingForProductsNestedInput
    productStock?: ProductStockUpdateOneWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    manufacturingOrders?: ManufacturingOrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    boxRawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productStock?: ProductStockUncheckedUpdateOneWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    manufacturingOrders?: ManufacturingOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ElementUpsertWithoutProductElementsInput = {
    update: XOR<ElementUpdateWithoutProductElementsInput, ElementUncheckedUpdateWithoutProductElementsInput>
    create: XOR<ElementCreateWithoutProductElementsInput, ElementUncheckedCreateWithoutProductElementsInput>
    where?: ElementWhereInput
  }

  export type ElementUpdateToOneWithWhereWithoutProductElementsInput = {
    where?: ElementWhereInput
    data: XOR<ElementUpdateWithoutProductElementsInput, ElementUncheckedUpdateWithoutProductElementsInput>
  }

  export type ElementUpdateWithoutProductElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawMaterial?: RawMaterialUpdateOneWithoutElementsNestedInput
    inventory?: InventoryUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUpdateManyWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateWithoutProductElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    rawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUncheckedUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type ElementCreateWithoutInventoryInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    rawMaterial?: RawMaterialCreateNestedOneWithoutElementsInput
    productElements?: ProductElementCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationCreateNestedManyWithoutElementInput
  }

  export type ElementUncheckedCreateWithoutInventoryInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    rawMaterialId?: string | null
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementUncheckedCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationUncheckedCreateNestedManyWithoutElementInput
  }

  export type ElementCreateOrConnectWithoutInventoryInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutInventoryInput, ElementUncheckedCreateWithoutInventoryInput>
  }

  export type ElementUpsertWithoutInventoryInput = {
    update: XOR<ElementUpdateWithoutInventoryInput, ElementUncheckedUpdateWithoutInventoryInput>
    create: XOR<ElementCreateWithoutInventoryInput, ElementUncheckedCreateWithoutInventoryInput>
    where?: ElementWhereInput
  }

  export type ElementUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ElementWhereInput
    data: XOR<ElementUpdateWithoutInventoryInput, ElementUncheckedUpdateWithoutInventoryInput>
  }

  export type ElementUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawMaterial?: RawMaterialUpdateOneWithoutElementsNestedInput
    productElements?: ProductElementUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUpdateManyWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    rawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUncheckedUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type ProductCreateWithoutProductStockInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    imageUrl?: string | null
    createdAt?: Date | string
    boxRawMaterial?: RawMaterialCreateNestedOneWithoutPackagingForProductsInput
    productElements?: ProductElementCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    manufacturingOrders?: ManufacturingOrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductStockInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    boxRawMaterialId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    manufacturingOrders?: ManufacturingOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductStockInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductStockInput, ProductUncheckedCreateWithoutProductStockInput>
  }

  export type ProductUpsertWithoutProductStockInput = {
    update: XOR<ProductUpdateWithoutProductStockInput, ProductUncheckedUpdateWithoutProductStockInput>
    create: XOR<ProductCreateWithoutProductStockInput, ProductUncheckedCreateWithoutProductStockInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductStockInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductStockInput, ProductUncheckedUpdateWithoutProductStockInput>
  }

  export type ProductUpdateWithoutProductStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boxRawMaterial?: RawMaterialUpdateOneWithoutPackagingForProductsNestedInput
    productElements?: ProductElementUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    manufacturingOrders?: ManufacturingOrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    boxRawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    manufacturingOrders?: ManufacturingOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ElementCreateWithoutInventoryTransactionsInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    rawMaterial?: RawMaterialCreateNestedOneWithoutElementsInput
    productElements?: ProductElementCreateNestedManyWithoutElementInput
    inventory?: InventoryCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationCreateNestedManyWithoutElementInput
  }

  export type ElementUncheckedCreateWithoutInventoryTransactionsInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    rawMaterialId?: string | null
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutElementInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementUncheckedCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationUncheckedCreateNestedManyWithoutElementInput
  }

  export type ElementCreateOrConnectWithoutInventoryTransactionsInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutInventoryTransactionsInput, ElementUncheckedCreateWithoutInventoryTransactionsInput>
  }

  export type ElementUpsertWithoutInventoryTransactionsInput = {
    update: XOR<ElementUpdateWithoutInventoryTransactionsInput, ElementUncheckedUpdateWithoutInventoryTransactionsInput>
    create: XOR<ElementCreateWithoutInventoryTransactionsInput, ElementUncheckedCreateWithoutInventoryTransactionsInput>
    where?: ElementWhereInput
  }

  export type ElementUpdateToOneWithWhereWithoutInventoryTransactionsInput = {
    where?: ElementWhereInput
    data: XOR<ElementUpdateWithoutInventoryTransactionsInput, ElementUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type ElementUpdateWithoutInventoryTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawMaterial?: RawMaterialUpdateOneWithoutElementsNestedInput
    productElements?: ProductElementUpdateManyWithoutElementNestedInput
    inventory?: InventoryUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUpdateManyWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateWithoutInventoryTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    rawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutElementNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUncheckedUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    boxesNeeded: number
    boxesAssembled?: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    boxesNeeded: number
    boxesAssembled?: number
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
  }

  export type ManufacturingOrderCreateWithoutOrderInput = {
    id?: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutManufacturingOrdersInput
    requirements?: MaterialRequirementCreateNestedManyWithoutManufacturingOrderInput
  }

  export type ManufacturingOrderUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: MaterialRequirementUncheckedCreateNestedManyWithoutManufacturingOrderInput
  }

  export type ManufacturingOrderCreateOrConnectWithoutOrderInput = {
    where: ManufacturingOrderWhereUniqueInput
    create: XOR<ManufacturingOrderCreateWithoutOrderInput, ManufacturingOrderUncheckedCreateWithoutOrderInput>
  }

  export type ManufacturingOrderCreateManyOrderInputEnvelope = {
    data: ManufacturingOrderCreateManyOrderInput | ManufacturingOrderCreateManyOrderInput[]
  }

  export type InventoryAllocationCreateWithoutOrderInput = {
    id?: string
    amountAllocated?: number
    createdAt?: Date | string
    element: ElementCreateNestedOneWithoutInventoryAllocationsInput
  }

  export type InventoryAllocationUncheckedCreateWithoutOrderInput = {
    id?: string
    elementId: string
    amountAllocated?: number
    createdAt?: Date | string
  }

  export type InventoryAllocationCreateOrConnectWithoutOrderInput = {
    where: InventoryAllocationWhereUniqueInput
    create: XOR<InventoryAllocationCreateWithoutOrderInput, InventoryAllocationUncheckedCreateWithoutOrderInput>
  }

  export type InventoryAllocationCreateManyOrderInputEnvelope = {
    data: InventoryAllocationCreateManyOrderInput | InventoryAllocationCreateManyOrderInput[]
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type ManufacturingOrderUpsertWithWhereUniqueWithoutOrderInput = {
    where: ManufacturingOrderWhereUniqueInput
    update: XOR<ManufacturingOrderUpdateWithoutOrderInput, ManufacturingOrderUncheckedUpdateWithoutOrderInput>
    create: XOR<ManufacturingOrderCreateWithoutOrderInput, ManufacturingOrderUncheckedCreateWithoutOrderInput>
  }

  export type ManufacturingOrderUpdateWithWhereUniqueWithoutOrderInput = {
    where: ManufacturingOrderWhereUniqueInput
    data: XOR<ManufacturingOrderUpdateWithoutOrderInput, ManufacturingOrderUncheckedUpdateWithoutOrderInput>
  }

  export type ManufacturingOrderUpdateManyWithWhereWithoutOrderInput = {
    where: ManufacturingOrderScalarWhereInput
    data: XOR<ManufacturingOrderUpdateManyMutationInput, ManufacturingOrderUncheckedUpdateManyWithoutOrderInput>
  }

  export type InventoryAllocationUpsertWithWhereUniqueWithoutOrderInput = {
    where: InventoryAllocationWhereUniqueInput
    update: XOR<InventoryAllocationUpdateWithoutOrderInput, InventoryAllocationUncheckedUpdateWithoutOrderInput>
    create: XOR<InventoryAllocationCreateWithoutOrderInput, InventoryAllocationUncheckedCreateWithoutOrderInput>
  }

  export type InventoryAllocationUpdateWithWhereUniqueWithoutOrderInput = {
    where: InventoryAllocationWhereUniqueInput
    data: XOR<InventoryAllocationUpdateWithoutOrderInput, InventoryAllocationUncheckedUpdateWithoutOrderInput>
  }

  export type InventoryAllocationUpdateManyWithWhereWithoutOrderInput = {
    where: InventoryAllocationScalarWhereInput
    data: XOR<InventoryAllocationUpdateManyMutationInput, InventoryAllocationUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutOrderItemsInput = {
    id?: string
    orderNumber: number
    clientName: string
    createdAt?: Date | string
    shippedAt?: Date | string | null
    status?: string
    notes?: string | null
    manufacturingOrders?: ManufacturingOrderCreateNestedManyWithoutOrderInput
    inventoryAllocations?: InventoryAllocationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    orderNumber: number
    clientName: string
    createdAt?: Date | string
    shippedAt?: Date | string | null
    status?: string
    notes?: string | null
    manufacturingOrders?: ManufacturingOrderUncheckedCreateNestedManyWithoutOrderInput
    inventoryAllocations?: InventoryAllocationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    imageUrl?: string | null
    createdAt?: Date | string
    boxRawMaterial?: RawMaterialCreateNestedOneWithoutPackagingForProductsInput
    productElements?: ProductElementCreateNestedManyWithoutProductInput
    productStock?: ProductStockCreateNestedOneWithoutProductInput
    manufacturingOrders?: ManufacturingOrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    boxRawMaterialId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutProductInput
    productStock?: ProductStockUncheckedCreateNestedOneWithoutProductInput
    manufacturingOrders?: ManufacturingOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    clientName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingOrders?: ManufacturingOrderUpdateManyWithoutOrderNestedInput
    inventoryAllocations?: InventoryAllocationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    clientName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingOrders?: ManufacturingOrderUncheckedUpdateManyWithoutOrderNestedInput
    inventoryAllocations?: InventoryAllocationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boxRawMaterial?: RawMaterialUpdateOneWithoutPackagingForProductsNestedInput
    productElements?: ProductElementUpdateManyWithoutProductNestedInput
    productStock?: ProductStockUpdateOneWithoutProductNestedInput
    manufacturingOrders?: ManufacturingOrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    boxRawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutProductNestedInput
    productStock?: ProductStockUncheckedUpdateOneWithoutProductNestedInput
    manufacturingOrders?: ManufacturingOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutInventoryAllocationsInput = {
    id?: string
    orderNumber: number
    clientName: string
    createdAt?: Date | string
    shippedAt?: Date | string | null
    status?: string
    notes?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    manufacturingOrders?: ManufacturingOrderCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutInventoryAllocationsInput = {
    id?: string
    orderNumber: number
    clientName: string
    createdAt?: Date | string
    shippedAt?: Date | string | null
    status?: string
    notes?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    manufacturingOrders?: ManufacturingOrderUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInventoryAllocationsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInventoryAllocationsInput, OrderUncheckedCreateWithoutInventoryAllocationsInput>
  }

  export type ElementCreateWithoutInventoryAllocationsInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    rawMaterial?: RawMaterialCreateNestedOneWithoutElementsInput
    productElements?: ProductElementCreateNestedManyWithoutElementInput
    inventory?: InventoryCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementCreateNestedManyWithoutElementInput
  }

  export type ElementUncheckedCreateWithoutInventoryAllocationsInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    rawMaterialId?: string | null
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutElementInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutElementInput
    materialRequirements?: MaterialRequirementUncheckedCreateNestedManyWithoutElementInput
  }

  export type ElementCreateOrConnectWithoutInventoryAllocationsInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutInventoryAllocationsInput, ElementUncheckedCreateWithoutInventoryAllocationsInput>
  }

  export type OrderUpsertWithoutInventoryAllocationsInput = {
    update: XOR<OrderUpdateWithoutInventoryAllocationsInput, OrderUncheckedUpdateWithoutInventoryAllocationsInput>
    create: XOR<OrderCreateWithoutInventoryAllocationsInput, OrderUncheckedCreateWithoutInventoryAllocationsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutInventoryAllocationsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutInventoryAllocationsInput, OrderUncheckedUpdateWithoutInventoryAllocationsInput>
  }

  export type OrderUpdateWithoutInventoryAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    clientName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    manufacturingOrders?: ManufacturingOrderUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutInventoryAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    clientName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    manufacturingOrders?: ManufacturingOrderUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ElementUpsertWithoutInventoryAllocationsInput = {
    update: XOR<ElementUpdateWithoutInventoryAllocationsInput, ElementUncheckedUpdateWithoutInventoryAllocationsInput>
    create: XOR<ElementCreateWithoutInventoryAllocationsInput, ElementUncheckedCreateWithoutInventoryAllocationsInput>
    where?: ElementWhereInput
  }

  export type ElementUpdateToOneWithWhereWithoutInventoryAllocationsInput = {
    where?: ElementWhereInput
    data: XOR<ElementUpdateWithoutInventoryAllocationsInput, ElementUncheckedUpdateWithoutInventoryAllocationsInput>
  }

  export type ElementUpdateWithoutInventoryAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawMaterial?: RawMaterialUpdateOneWithoutElementsNestedInput
    productElements?: ProductElementUpdateManyWithoutElementNestedInput
    inventory?: InventoryUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUpdateManyWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateWithoutInventoryAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    rawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutElementNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUncheckedUpdateManyWithoutElementNestedInput
  }

  export type OrderCreateWithoutManufacturingOrdersInput = {
    id?: string
    orderNumber: number
    clientName: string
    createdAt?: Date | string
    shippedAt?: Date | string | null
    status?: string
    notes?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    inventoryAllocations?: InventoryAllocationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutManufacturingOrdersInput = {
    id?: string
    orderNumber: number
    clientName: string
    createdAt?: Date | string
    shippedAt?: Date | string | null
    status?: string
    notes?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    inventoryAllocations?: InventoryAllocationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutManufacturingOrdersInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutManufacturingOrdersInput, OrderUncheckedCreateWithoutManufacturingOrdersInput>
  }

  export type ProductCreateWithoutManufacturingOrdersInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    imageUrl?: string | null
    createdAt?: Date | string
    boxRawMaterial?: RawMaterialCreateNestedOneWithoutPackagingForProductsInput
    productElements?: ProductElementCreateNestedManyWithoutProductInput
    productStock?: ProductStockCreateNestedOneWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutManufacturingOrdersInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    boxRawMaterialId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutProductInput
    productStock?: ProductStockUncheckedCreateNestedOneWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutManufacturingOrdersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutManufacturingOrdersInput, ProductUncheckedCreateWithoutManufacturingOrdersInput>
  }

  export type MaterialRequirementCreateWithoutManufacturingOrderInput = {
    id?: string
    quantityNeeded: number
    quantityProduced?: number
    totalWeightGrams: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    element: ElementCreateNestedOneWithoutMaterialRequirementsInput
  }

  export type MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput = {
    id?: string
    elementId: string
    quantityNeeded: number
    quantityProduced?: number
    totalWeightGrams: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type MaterialRequirementCreateOrConnectWithoutManufacturingOrderInput = {
    where: MaterialRequirementWhereUniqueInput
    create: XOR<MaterialRequirementCreateWithoutManufacturingOrderInput, MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput>
  }

  export type MaterialRequirementCreateManyManufacturingOrderInputEnvelope = {
    data: MaterialRequirementCreateManyManufacturingOrderInput | MaterialRequirementCreateManyManufacturingOrderInput[]
  }

  export type OrderUpsertWithoutManufacturingOrdersInput = {
    update: XOR<OrderUpdateWithoutManufacturingOrdersInput, OrderUncheckedUpdateWithoutManufacturingOrdersInput>
    create: XOR<OrderCreateWithoutManufacturingOrdersInput, OrderUncheckedCreateWithoutManufacturingOrdersInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutManufacturingOrdersInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutManufacturingOrdersInput, OrderUncheckedUpdateWithoutManufacturingOrdersInput>
  }

  export type OrderUpdateWithoutManufacturingOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    clientName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    inventoryAllocations?: InventoryAllocationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutManufacturingOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: IntFieldUpdateOperationsInput | number
    clientName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    inventoryAllocations?: InventoryAllocationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutManufacturingOrdersInput = {
    update: XOR<ProductUpdateWithoutManufacturingOrdersInput, ProductUncheckedUpdateWithoutManufacturingOrdersInput>
    create: XOR<ProductCreateWithoutManufacturingOrdersInput, ProductUncheckedCreateWithoutManufacturingOrdersInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutManufacturingOrdersInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutManufacturingOrdersInput, ProductUncheckedUpdateWithoutManufacturingOrdersInput>
  }

  export type ProductUpdateWithoutManufacturingOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boxRawMaterial?: RawMaterialUpdateOneWithoutPackagingForProductsNestedInput
    productElements?: ProductElementUpdateManyWithoutProductNestedInput
    productStock?: ProductStockUpdateOneWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutManufacturingOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    boxRawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutProductNestedInput
    productStock?: ProductStockUncheckedUpdateOneWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type MaterialRequirementUpsertWithWhereUniqueWithoutManufacturingOrderInput = {
    where: MaterialRequirementWhereUniqueInput
    update: XOR<MaterialRequirementUpdateWithoutManufacturingOrderInput, MaterialRequirementUncheckedUpdateWithoutManufacturingOrderInput>
    create: XOR<MaterialRequirementCreateWithoutManufacturingOrderInput, MaterialRequirementUncheckedCreateWithoutManufacturingOrderInput>
  }

  export type MaterialRequirementUpdateWithWhereUniqueWithoutManufacturingOrderInput = {
    where: MaterialRequirementWhereUniqueInput
    data: XOR<MaterialRequirementUpdateWithoutManufacturingOrderInput, MaterialRequirementUncheckedUpdateWithoutManufacturingOrderInput>
  }

  export type MaterialRequirementUpdateManyWithWhereWithoutManufacturingOrderInput = {
    where: MaterialRequirementScalarWhereInput
    data: XOR<MaterialRequirementUpdateManyMutationInput, MaterialRequirementUncheckedUpdateManyWithoutManufacturingOrderInput>
  }

  export type ManufacturingOrderCreateWithoutRequirementsInput = {
    id?: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutManufacturingOrdersInput
    product: ProductCreateNestedOneWithoutManufacturingOrdersInput
  }

  export type ManufacturingOrderUncheckedCreateWithoutRequirementsInput = {
    id?: string
    orderId: string
    productId: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManufacturingOrderCreateOrConnectWithoutRequirementsInput = {
    where: ManufacturingOrderWhereUniqueInput
    create: XOR<ManufacturingOrderCreateWithoutRequirementsInput, ManufacturingOrderUncheckedCreateWithoutRequirementsInput>
  }

  export type ElementCreateWithoutMaterialRequirementsInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    rawMaterial?: RawMaterialCreateNestedOneWithoutElementsInput
    productElements?: ProductElementCreateNestedManyWithoutElementInput
    inventory?: InventoryCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationCreateNestedManyWithoutElementInput
  }

  export type ElementUncheckedCreateWithoutMaterialRequirementsInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    rawMaterialId?: string | null
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
    productElements?: ProductElementUncheckedCreateNestedManyWithoutElementInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutElementInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutElementInput
    inventoryAllocations?: InventoryAllocationUncheckedCreateNestedManyWithoutElementInput
  }

  export type ElementCreateOrConnectWithoutMaterialRequirementsInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutMaterialRequirementsInput, ElementUncheckedCreateWithoutMaterialRequirementsInput>
  }

  export type ManufacturingOrderUpsertWithoutRequirementsInput = {
    update: XOR<ManufacturingOrderUpdateWithoutRequirementsInput, ManufacturingOrderUncheckedUpdateWithoutRequirementsInput>
    create: XOR<ManufacturingOrderCreateWithoutRequirementsInput, ManufacturingOrderUncheckedCreateWithoutRequirementsInput>
    where?: ManufacturingOrderWhereInput
  }

  export type ManufacturingOrderUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: ManufacturingOrderWhereInput
    data: XOR<ManufacturingOrderUpdateWithoutRequirementsInput, ManufacturingOrderUncheckedUpdateWithoutRequirementsInput>
  }

  export type ManufacturingOrderUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutManufacturingOrdersNestedInput
    product?: ProductUpdateOneRequiredWithoutManufacturingOrdersNestedInput
  }

  export type ManufacturingOrderUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementUpsertWithoutMaterialRequirementsInput = {
    update: XOR<ElementUpdateWithoutMaterialRequirementsInput, ElementUncheckedUpdateWithoutMaterialRequirementsInput>
    create: XOR<ElementCreateWithoutMaterialRequirementsInput, ElementUncheckedCreateWithoutMaterialRequirementsInput>
    where?: ElementWhereInput
  }

  export type ElementUpdateToOneWithWhereWithoutMaterialRequirementsInput = {
    where?: ElementWhereInput
    data: XOR<ElementUpdateWithoutMaterialRequirementsInput, ElementUncheckedUpdateWithoutMaterialRequirementsInput>
  }

  export type ElementUpdateWithoutMaterialRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawMaterial?: RawMaterialUpdateOneWithoutElementsNestedInput
    productElements?: ProductElementUpdateManyWithoutElementNestedInput
    inventory?: InventoryUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUpdateManyWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateWithoutMaterialRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    rawMaterialId?: NullableStringFieldUpdateOperationsInput | string | null
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutElementNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type ElementCreateManyRawMaterialInput = {
    id?: string
    uniqueName: string
    label?: string
    color: string
    color2?: string | null
    isDualColor?: boolean
    material: string
    weightGrams?: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type ProductCreateManyBoxRawMaterialInput = {
    id?: string
    serialNumber: string
    category: string
    label?: string
    unitsPerAssembly?: number
    unitsPerBox?: number
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type RawMaterialTransactionCreateManyRawMaterialInput = {
    id?: string
    changeAmount: number
    reason: string
    createdAt?: Date | string
  }

  export type ElementUpdateWithoutRawMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUpdateManyWithoutElementNestedInput
    inventory?: InventoryUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUpdateManyWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateWithoutRawMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutElementNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutElementNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutElementNestedInput
    materialRequirements?: MaterialRequirementUncheckedUpdateManyWithoutElementNestedInput
    inventoryAllocations?: InventoryAllocationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateManyWithoutRawMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    isDualColor?: BoolFieldUpdateOperationsInput | boolean
    material?: StringFieldUpdateOperationsInput | string
    weightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutBoxRawMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUpdateManyWithoutProductNestedInput
    productStock?: ProductStockUpdateOneWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    manufacturingOrders?: ManufacturingOrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBoxRawMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productElements?: ProductElementUncheckedUpdateManyWithoutProductNestedInput
    productStock?: ProductStockUncheckedUpdateOneWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    manufacturingOrders?: ManufacturingOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBoxRawMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    unitsPerAssembly?: IntFieldUpdateOperationsInput | number
    unitsPerBox?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawMaterialTransactionUpdateWithoutRawMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawMaterialTransactionUncheckedUpdateWithoutRawMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawMaterialTransactionUncheckedUpdateManyWithoutRawMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductElementCreateManyElementInput = {
    id?: string
    productId: string
    quantityNeeded?: number
    createdAt?: Date | string
  }

  export type InventoryCreateManyElementInput = {
    id?: string
    totalAmount?: number
    updatedAt?: Date | string
  }

  export type InventoryTransactionCreateManyElementInput = {
    id?: string
    changeAmount: number
    reason: string
    createdAt?: Date | string
  }

  export type MaterialRequirementCreateManyElementInput = {
    id?: string
    manufacturingOrderId: string
    quantityNeeded: number
    quantityProduced?: number
    totalWeightGrams: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type InventoryAllocationCreateManyElementInput = {
    id?: string
    orderId: string
    amountAllocated?: number
    createdAt?: Date | string
  }

  export type ProductElementUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductElementsNestedInput
  }

  export type ProductElementUncheckedUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductElementUncheckedUpdateManyWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeAmount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeAmount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeAmount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequirementUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    quantityProduced?: IntFieldUpdateOperationsInput | number
    totalWeightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manufacturingOrder?: ManufacturingOrderUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type MaterialRequirementUncheckedUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    manufacturingOrderId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    quantityProduced?: IntFieldUpdateOperationsInput | number
    totalWeightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequirementUncheckedUpdateManyWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    manufacturingOrderId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    quantityProduced?: IntFieldUpdateOperationsInput | number
    totalWeightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAllocationUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountAllocated?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutInventoryAllocationsNestedInput
  }

  export type InventoryAllocationUncheckedUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amountAllocated?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAllocationUncheckedUpdateManyWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amountAllocated?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductElementCreateManyProductInput = {
    id?: string
    elementId: string
    quantityNeeded?: number
    createdAt?: Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    boxesNeeded: number
    boxesAssembled?: number
    createdAt?: Date | string
  }

  export type ManufacturingOrderCreateManyProductInput = {
    id?: string
    orderId: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductElementUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: ElementUpdateOneRequiredWithoutProductElementsNestedInput
  }

  export type ProductElementUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductElementUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    boxesNeeded?: IntFieldUpdateOperationsInput | number
    boxesAssembled?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    boxesNeeded?: IntFieldUpdateOperationsInput | number
    boxesAssembled?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    boxesNeeded?: IntFieldUpdateOperationsInput | number
    boxesAssembled?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManufacturingOrderUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutManufacturingOrdersNestedInput
    requirements?: MaterialRequirementUpdateManyWithoutManufacturingOrderNestedInput
  }

  export type ManufacturingOrderUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: MaterialRequirementUncheckedUpdateManyWithoutManufacturingOrderNestedInput
  }

  export type ManufacturingOrderUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    boxesNeeded: number
    boxesAssembled?: number
    createdAt?: Date | string
  }

  export type ManufacturingOrderCreateManyOrderInput = {
    id?: string
    productId: string
    quantityToMake: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAllocationCreateManyOrderInput = {
    id?: string
    elementId: string
    amountAllocated?: number
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    boxesNeeded?: IntFieldUpdateOperationsInput | number
    boxesAssembled?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    boxesNeeded?: IntFieldUpdateOperationsInput | number
    boxesAssembled?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    boxesNeeded?: IntFieldUpdateOperationsInput | number
    boxesAssembled?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManufacturingOrderUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutManufacturingOrdersNestedInput
    requirements?: MaterialRequirementUpdateManyWithoutManufacturingOrderNestedInput
  }

  export type ManufacturingOrderUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: MaterialRequirementUncheckedUpdateManyWithoutManufacturingOrderNestedInput
  }

  export type ManufacturingOrderUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityToMake?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAllocationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountAllocated?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: ElementUpdateOneRequiredWithoutInventoryAllocationsNestedInput
  }

  export type InventoryAllocationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    amountAllocated?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAllocationUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    amountAllocated?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequirementCreateManyManufacturingOrderInput = {
    id?: string
    elementId: string
    quantityNeeded: number
    quantityProduced?: number
    totalWeightGrams: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type MaterialRequirementUpdateWithoutManufacturingOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    quantityProduced?: IntFieldUpdateOperationsInput | number
    totalWeightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: ElementUpdateOneRequiredWithoutMaterialRequirementsNestedInput
  }

  export type MaterialRequirementUncheckedUpdateWithoutManufacturingOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    quantityProduced?: IntFieldUpdateOperationsInput | number
    totalWeightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequirementUncheckedUpdateManyWithoutManufacturingOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    quantityNeeded?: IntFieldUpdateOperationsInput | number
    quantityProduced?: IntFieldUpdateOperationsInput | number
    totalWeightGrams?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}